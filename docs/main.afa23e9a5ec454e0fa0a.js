(self.webpackChunkclient=self.webpackChunkclient||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},80:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(S){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return I;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+l),n);if(l<8){var d=o(u(n,l));a=a.mul(d).add(o(h))}else a=(a=a.mul(s)).add(o(h))}return a.unsigned=t,a}function h(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var x=i(1,!0);n.UONE=x;var v=i(-1);n.NEG_ONE=v;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var I=l(0,-2147483648,!1);n.MIN_VALUE=I;var N=n.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1==(1&this.low)},N.isEven=function(){return 0==(1&this.low)},N.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(b)},N.neg=N.negate,N.add=function(e){r(e)||(e=h(e));var t=0,n=0,s=0,a=0;return s+=(a+=(65535&this.low)+(65535&e.low))>>>16,n+=(s+=(this.low>>>16)+(e.low>>>16))>>>16,t+=(n+=(65535&this.high)+(65535&e.high))>>>16,t+=(this.high>>>16)+(e.high>>>16),l((s&=65535)<<16|(a&=65535),(t&=65535)<<16|(n&=65535),this.unsigned)},N.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(I))return e.isOdd()?I:g;if(e.eq(I))return this.isOdd()?I:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=65535&e.high,u=e.low>>>16,c=65535&e.low,d=0,p=0,f=0,y=0;return f+=(y+=a*c)>>>16,p+=(f+=s*c)>>>16,f&=65535,p+=(f+=a*u)>>>16,d+=(p+=n*c)>>>16,p&=65535,d+=(p+=s*u)>>>16,p&=65535,d+=(p+=a*i)>>>16,d+=(this.high>>>16)*c+n*u+s*i+a*(e.high>>>16),l((f&=65535)<<16|(y&=65535),(d&=65535)<<16|(p&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;a=y}else{if(this.eq(I))return e.eq(b)||e.eq(v)?I:e.eq(I)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:v:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(I))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=b),a=a.add(d),s=s.sub(p)}return a},N.div=N.divide,N.modulo=function(e){return r(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return l(~this.low,~this.high,this.unsigned)},N.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},901:(e,t,n)=>{var r=n(366),s=n(678),a=n(278),i=n(457),o=n(594),l=n(35),u=n(507);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},366:function(e,t,n){var r;!function(e,s,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.alea=l}(0,e=n.nmd(e))},35:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.tychei=l}(0,e=n.nmd(e))},678:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.xor128=l}(0,e=n.nmd(e))},594:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n=s[a]=(n^=n>>>15)^(e^=e>>>12),t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(s=0==(n=o[127&a]^=r+(i=i+1640531527|0))?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,o[s]=(r^=r>>>15)^(n^=n>>>12);e.w=i,e.X=o,e.i=s}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.xor4096=l}(0,e=n.nmd(e))},457:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],r[s]=n^=(e^=e<<13)^e<<9,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.xorshift7=l}(0,e=n.nmd(e))},278:function(e,t,n){var r;!function(e,s,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=(function(){return l}).call(t,n,t,s))||(s.exports=r):this.xorwow=l}(0,e=n.nmd(e))},507:(e,t,n)=>{var r;!function(s,a){var i,o=this,l=256,u=a.pow(l,6),c=a.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,b(s)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(b(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(a.random=e,t):e})(x,d,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=d&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*l+i[d&(i[s]=i[a=d&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(a.seedrandom=p,y(a.random(),s),e.exports){e.exports=p;try{i=n(42)}catch(x){}}else void 0===(r=(function(){return p}).call(t,n,t,e))||(e.exports=r)}([],Math)},275:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{assertParamsValid:()=>Mb,computeFlatOffset:()=>Xb,computeOutShape:()=>zb,getNormalizedAxes:()=>Wb,isSliceContinous:()=>Kb,maskToAxes:()=>Lb,parseSliceParams:()=>Zb,sliceInfo:()=>Yb,startForAxis:()=>jb,startIndicesWithElidedDims:()=>Ub,stopForAxis:()=>qb,stopIndicesWithElidedDims:()=>Hb,stridesForAxis:()=>Gb,stridesWithElidedDims:()=>Pb});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>LI,computeOutShape:()=>MI,segOpComputeOptimalWindowSize:()=>OI});var a={};n.r(a),n.d(a,{ERF_A1:()=>dI,ERF_A2:()=>pI,ERF_A3:()=>fI,ERF_A4:()=>mI,ERF_A5:()=>gI,ERF_P:()=>hI,PARALLELIZE_THRESHOLD:()=>Yk,SELU_SCALE:()=>cI,SELU_SCALEALPHA:()=>uI,applyActivation:()=>Ew,assertAndGetBroadcastShape:()=>ev,assertAxesAreInnerMostDims:()=>$v,assertParamsConsistent:()=>Xk,assignToTypedArray:()=>NI,axesAreInnerMostDims:()=>Nv,calculateShapes:()=>lI,checkEinsumDimSizes:()=>_I,combineLocations:()=>Sv,complexWithEvenIndex:()=>wI,complexWithOddIndex:()=>kI,computeConv2DInfo:()=>bx,computeConv3DInfo:()=>xx,computeDefaultPad:()=>vx,computeDilation2DInfo:()=>mx,computeOptimalWindowSize:()=>Jk,computeOutAndReduceShapes:()=>Cv,computeOutShape:()=>Zk,computePool2DInfo:()=>gx,computePool3DInfo:()=>yx,convertConv2DDataFormat:()=>Tx,decodeEinsumEquation:()=>$I,eitherStridesOrDilationsAreOne:()=>Cx,expandShapeToKeepDim:()=>Tv,exponent:()=>CI,exponents:()=>SI,fromStringArrayToUint8:()=>PI,fromUint8ToStringArray:()=>zI,getAxesPermutation:()=>Ev,getBroadcastDims:()=>Jx,getComplexWithIndex:()=>II,getEinsumComputePath:()=>AI,getEinsumPermutation:()=>EI,getFusedBiasGradient:()=>$w,getFusedDyActivation:()=>Tw,getImageCenter:()=>Qk,getInnerMostAxes:()=>Av,getPermuted:()=>tI,getReductionAxes:()=>Qx,getReshaped:()=>eI,getReshapedPermuted:()=>nI,getSliceBeginCoords:()=>rI,getSliceSize:()=>sI,getUndoAxesPermutation:()=>_v,isIdentityPermutation:()=>RI,log:()=>bI,mergeRealAndImagArrays:()=>xI,prepareAndValidate:()=>aI,prepareSplitSize:()=>DI,segment_util:()=>s,shouldFuse:()=>_w,slice_util:()=>r,splitRealAndImagArrays:()=>vI,tupleValuesAreOne:()=>Sx,upcastType:()=>by,validateInput:()=>oI,validateUpdateShape:()=>iI,warn:()=>yI});var i={};n.r(i),n.d(i,{json:()=>F_});var o={};n.r(o),n.d(o,{json:()=>D_});var l={};n.r(l),n.d(l,{json:()=>O_});var u={};n.r(u),n.d(u,{json:()=>M_});var c={};n.r(c),n.d(c,{json:()=>L_});var h={};n.r(h),n.d(h,{json:()=>z_});var d={};n.r(d),n.d(d,{json:()=>P_});var p={};n.r(p),n.d(p,{json:()=>B_});var f={};n.r(f),n.d(f,{json:()=>V_});var m={};n.r(m),n.d(m,{json:()=>W_});var g={};n.r(g),n.d(g,{json:()=>U_});var y={};n.r(y),n.d(y,{json:()=>H_});var b={};n.r(b),n.d(b,{json:()=>G_});var x={};n.r(x),n.d(x,{json:()=>j_});var v={};n.r(v),n.d(v,{json:()=>q_});var w={};n.r(w),n.d(w,{json:()=>K_});var k={};n.r(k),n.d(k,{json:()=>X_});var I={};n.r(I),n.d(I,{json:()=>Z_});var N={};n.r(N),n.d(N,{json:()=>Y_});var S={};function C(e){return"function"==typeof e}n.r(S),n.d(S,{addImpl:()=>$R,bincountImpl:()=>vF,bincountReduceImpl:()=>wF,ceilImpl:()=>NF,concatImpl:()=>_F,equalImpl:()=>dD,expImpl:()=>ID,expm1Impl:()=>$D,floorImpl:()=>GD,gatherNdImpl:()=>QD,gatherV2Impl:()=>tO,greaterEqualImpl:()=>iO,greaterImpl:()=>rO,lessEqualImpl:()=>xO,lessImpl:()=>gO,linSpaceImpl:()=>kO,logImpl:()=>NO,maxImpl:()=>PO,maximumImpl:()=>WO,minimumImpl:()=>JO,multiplyImpl:()=>sD,negImpl:()=>lM,notEqualImpl:()=>gM,prodImpl:()=>EM,rangeImpl:()=>AM,rsqrtImpl:()=>UM,simpleAbsImpl:()=>LR,sliceImpl:()=>gF,sparseFillEmptyRowsImpl:()=>uL,sparseReshapeImpl:()=>hL,sparseSegmentReductionImpl:()=>pL,squaredDifferenceImpl:()=>wL,stridedSliceImpl:()=>CL,stringNGramsImpl:()=>EL,stringSplitImpl:()=>RL,stringToHashBucketFastImpl:()=>DL,subImpl:()=>DD,tileImpl:()=>PL,topKImpl:()=>BL,transposeImpl:()=>HR,uniqueImpl:()=>GL});let T=!1;const $={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else T&&console.log("RxJS: Back to a better error behavior. Thank you. <3");T=e},get useDeprecatedSynchronousErrorHandling(){return T}};function E(e){setTimeout(()=>{throw e},0)}const _={closed:!0,next(e){},error(e){if($.useDeprecatedSynchronousErrorHandling)throw e;E(e)},complete(){}},A=Array.isArray||(e=>e&&"number"==typeof e.length);function R(e){return null!==e&&"object"==typeof e}const F=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();class D{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:t,_ctorUnsubscribe:n,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,t instanceof D)t.remove(this);else if(null!==t)for(let i=0;i<t.length;++i)t[i].remove(this);if(C(r)){n&&(this._unsubscribe=void 0);try{r.call(this)}catch(a){e=a instanceof F?O(a.errors):[a]}}if(A(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(R(n))try{n.unsubscribe()}catch(a){e=e||[],a instanceof F?e=e.concat(O(a.errors)):e.push(a)}}}if(e)throw new F(e)}add(e){let t=e;if(!e)return D.EMPTY;switch(typeof e){case"function":t=new D(e);case"object":if(t===this||t.closed||"function"!=typeof t.unsubscribe)return t;if(this.closed)return t.unsubscribe(),t;if(!(t instanceof D)){const e=t;t=new D,t._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:n}=t;if(null===n)t._parentOrParents=this;else if(n instanceof D){if(n===this)return t;t._parentOrParents=[n,this]}else{if(-1!==n.indexOf(this))return t;n.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[t]:r.push(t),t}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}function O(e){return e.reduce((e,t)=>e.concat(t instanceof F?t.errors:t),[])}D.EMPTY=function(e){return e.closed=!0,e}(new D);const M="function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random();class L extends D{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=_;break;case 1:if(!e){this.destination=_;break}if("object"==typeof e){e instanceof L?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new z(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new z(this,e,t,n)}}[M](){return this}static create(e,t,n){const r=new L(e,t,n);return r.syncErrorThrowable=!1,r}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class z extends L{constructor(e,t,n,r){let s;super(),this._parentSubscriber=e;let a=this;C(t)?s=t:t&&(s=t.next,n=t.error,r=t.complete,t!==_&&(a=Object.create(t),C(a.unsubscribe)&&this.add(a.unsubscribe.bind(a)),a.unsubscribe=this.unsubscribe.bind(this))),this._context=a,this._next=s,this._error=n,this._complete=r}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;$.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=$;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):E(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;E(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);$.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),$.useDeprecatedSynchronousErrorHandling)throw n;E(n)}}__tryOrSetError(e,t,n){if(!$.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(r){return $.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=r,e.syncErrorThrown=!0,!0):(E(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const P="function"==typeof Symbol&&Symbol.observable||"@@observable";function B(e){return e}let V=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:r}=this,s=function(e,t,n){if(e){if(e instanceof L)return e;if(e[M])return e[M]()}return e||t||n?new L(e,t,n):new L(_)}(e,t,n);if(s.add(r?r.call(s,this.source):this.source||$.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),$.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(e){try{return this._subscribe(e)}catch(t){$.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:r}=e;if(t||r)return!1;e=n&&n instanceof L?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=W(t))((t,n)=>{let r;r=this.subscribe(t=>{try{e(t)}catch(s){n(s),r&&r.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[P](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?B:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=W(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function W(e){if(e||(e=$.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const U=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class H extends D{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class G extends L{constructor(e){super(e),this.destination=e}}let j=(()=>{class e extends V{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[M](){return new G(this)}lift(e){const t=new q(this,this);return t.operator=e,t}next(e){if(this.closed)throw new U;if(!this.isStopped){const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].next(e)}}error(e){if(this.closed)throw new U;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].error(e);this.observers.length=0}complete(){if(this.closed)throw new U;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let r=0;r<t;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new U;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new U;return this.hasError?(e.error(this.thrownError),D.EMPTY):this.isStopped?(e.complete(),D.EMPTY):(this.observers.push(e),new H(this,e))}asObservable(){const e=new V;return e.source=this,e}}return e.create=(e,t)=>new q(e,t),e})();class q extends j{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):D.EMPTY}}function K(e){return e&&"function"==typeof e.schedule}function X(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new Z(e,t))}}class Z{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new Y(e,this.project,this.thisArg))}}class Y extends L{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const J=e=>t=>{for(let n=0,r=e.length;n<r&&!t.closed;n++)t.next(e[n]);t.complete()},Q="function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator",ee=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function te(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const ne=e=>{if(e&&"function"==typeof e[P])return n=e,e=>{const t=n[P]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(ee(e))return J(e);if(te(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,E),t))(e);if(e&&"function"==typeof e[Q])return t=e,e=>{const n=t[Q]();for(;;){let t;try{t=n.next()}catch(r){return e.error(r),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=R(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function re(e,t){return new V(n=>{const r=new D;let s=0;return r.add(t.schedule(function(){s!==e.length?(n.next(e[s++]),n.closed||r.add(this.schedule())):n.complete()})),r})}function se(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[P]}(e))return function(e,t){return new V(n=>{const r=new D;return r.add(t.schedule(()=>{const s=e[P]();r.add(s.subscribe({next(e){r.add(t.schedule(()=>n.next(e)))},error(e){r.add(t.schedule(()=>n.error(e)))},complete(){r.add(t.schedule(()=>n.complete()))}}))})),r})}(e,t);if(te(e))return function(e,t){return new V(n=>{const r=new D;return r.add(t.schedule(()=>e.then(e=>{r.add(t.schedule(()=>{n.next(e),r.add(t.schedule(()=>n.complete()))}))},e=>{r.add(t.schedule(()=>n.error(e)))}))),r})}(e,t);if(ee(e))return re(e,t);if(function(e){return e&&"function"==typeof e[Q]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new V(n=>{const r=new D;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(t.schedule(()=>{s=e[Q](),r.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=s.next();e=n.value,t=n.done}catch(r){return void n.error(r)}t?n.complete():(n.next(e),this.schedule())}))})),r})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof V?e:new V(ne(e))}class ae extends L{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class ie extends L{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function oe(e,t){if(t.closed)return;if(e instanceof V)return e.subscribe(t);let n;try{n=ne(e)(t)}catch(r){t.error(r)}return n}function le(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?r=>r.pipe(le((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))),n)):("number"==typeof t&&(n=t),t=>t.lift(new ue(e,n)))}class ue{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new ce(e,this.project,this.concurrent))}}class ce extends ie{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(t)}_innerSub(e){const t=new ae(this),n=this.destination;n.add(t);const r=oe(e,t);r!==t&&n.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function he(e=Number.POSITIVE_INFINITY){return le(B,e)}function de(e,t){return t?re(e,t):new V(J(e))}function pe(){return function(e){return e.lift(new fe(e))}}class fe{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const r=new me(e,n),s=t.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class me extends L{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,r=e._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class ge extends V{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new D,e.add(this.source.subscribe(new be(this.getSubject(),this))),e.closed&&(this._connection=null,e=D.EMPTY)),e}refCount(){return pe()(this)}}const ye=(()=>{const e=ge.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class be extends G{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function xe(){return new j}function ve(e){for(let t in e)if(e[t]===ve)return t;throw Error("Could not find renamed property on target object.")}function we(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(we).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function ke(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const Ie=ve({__forward_ref__:ve});function Ne(e){return e.__forward_ref__=Ne,e.toString=function(){return we(this())},e}function Se(e){return"function"==typeof(t=e)&&t.hasOwnProperty(Ie)&&t.__forward_ref__===Ne?e():e;var t}class Ce extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function Te(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():function(e){return"string"==typeof e?e:null==e?"":String(e)}(e)}function $e(e,t){const n=t?` in ${t}`:"";throw new Ce("201",`No provider for ${Te(e)} found${n}`)}function Ee(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function _e(e){return{providers:e.providers||[],imports:e.imports||[]}}function Ae(e){return Re(e,De)||Re(e,Me)}function Re(e,t){return e.hasOwnProperty(t)?e[t]:null}function Fe(e){return e&&(e.hasOwnProperty(Oe)||e.hasOwnProperty(Le))?e[Oe]:null}const De=ve({"\u0275prov":ve}),Oe=ve({"\u0275inj":ve}),Me=ve({ngInjectableDef:ve}),Le=ve({ngInjectorDef:ve});var ze=(()=>((ze=ze||{})[ze.Default=0]="Default",ze[ze.Host=1]="Host",ze[ze.Self=2]="Self",ze[ze.SkipSelf=4]="SkipSelf",ze[ze.Optional=8]="Optional",ze))();let Pe;function Be(e){const t=Pe;return Pe=e,t}function Ve(e,t,n){const r=Ae(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:n&ze.Optional?null:void 0!==t?t:void $e(we(e),"Injector")}function We(e){return{toString:e}.toString()}var Ue=(()=>((Ue=Ue||{})[Ue.OnPush=0]="OnPush",Ue[Ue.Default=1]="Default",Ue))(),He=(()=>((He=He||{})[He.Emulated=0]="Emulated",He[He.None=2]="None",He[He.ShadowDom=3]="ShadowDom",He))();const Ge="undefined"!=typeof globalThis&&globalThis,je="undefined"!=typeof window&&window,qe="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Ke="undefined"!=typeof global&&global,Xe=Ge||Ke||je||qe,Ze={},Ye=[],Je=ve({"\u0275cmp":ve}),Qe=ve({"\u0275dir":ve}),et=ve({"\u0275pipe":ve}),tt=ve({"\u0275mod":ve}),nt=ve({"\u0275loc":ve}),rt=ve({"\u0275fac":ve}),st=ve({__NG_ELEMENT_ID__:ve});let at=0;function it(e){return We(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===Ue.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||Ye,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||He.Emulated,id:"c",styles:e.styles||Ye,_:null,setInput:null,schemas:e.schemas||null,tView:null},r=e.directives,s=e.features,a=e.pipes;return n.id+=at++,n.inputs=ht(e.inputs,t),n.outputs=ht(e.outputs),s&&s.forEach(e=>e(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(ot):null,n.pipeDefs=a?()=>("function"==typeof a?a():a).map(lt):null,n})}function ot(e){return pt(e)||function(e){return e[Qe]||null}(e)}function lt(e){return function(e){return e[et]||null}(e)}const ut={};function ct(e){return We(()=>{const t={type:e.type,bootstrap:e.bootstrap||Ye,declarations:e.declarations||Ye,imports:e.imports||Ye,exports:e.exports||Ye,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(ut[e.id]=e.type),t})}function ht(e,t){if(null==e)return Ze;const n={};for(const r in e)if(e.hasOwnProperty(r)){let s=e[r],a=s;Array.isArray(s)&&(a=s[1],s=s[0]),n[s]=r,t&&(t[s]=a)}return n}const dt=it;function pt(e){return e[Je]||null}function ft(e,t){const n=e[tt]||null;if(!n&&!0===t)throw new Error(`Type ${we(e)} does not have '\u0275mod' property.`);return n}const mt=10;function gt(e){return Array.isArray(e)&&"object"==typeof e[1]}function yt(e){return Array.isArray(e)&&!0===e[1]}function bt(e){return 0!=(8&e.flags)}function xt(e){return 2==(2&e.flags)}function vt(e){return 1==(1&e.flags)}function wt(e){return null!==e.template}function kt(e,t){return e.hasOwnProperty(rt)?e[rt]:null}class It{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function Nt(){const e=Ct(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Ze)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function St(e,t,n,r){const s=Ct(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Ze,current:null}),a=s.current||(s.current={}),i=s.previous,o=this.declaredInputs[n],l=i[o];a[o]=new It(l&&l.currentValue,t,i===Ze),e[r]=t}function Ct(e){return e.__ngSimpleChanges__||null}let Tt;function $t(e){return!!e.listen}const Et={createRenderer:(e,t)=>void 0!==Tt?Tt:"undefined"!=typeof document?document:void 0};function _t(e){for(;Array.isArray(e);)e=e[0];return e}function At(e,t){return _t(t[e.index])}function Rt(e,t){const n=t[e];return gt(n)?n:n[0]}function Ft(e){return 4==(4&e[2])}function Dt(e){return 128==(128&e[2])}function Ot(e,t){return null==t?null:e[t]}function Mt(e){e[18]=0}function Lt(e,t){e[5]+=t;let n=e,r=e[3];for(;null!==r&&(1===t&&1===n[5]||-1===t&&0===n[5]);)r[5]+=t,n=r,r=r[3]}const zt={lFrame:nn(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function Pt(){return zt.bindingsEnabled}function Bt(){return zt.lFrame.lView}function Vt(){return zt.lFrame.tView}function Wt(){let e=Ut();for(;null!==e&&64===e.type;)e=e.parent;return e}function Ut(){return zt.lFrame.currentTNode}function Ht(e,t){const n=zt.lFrame;n.currentTNode=e,n.isParent=t}function Gt(){return zt.lFrame.isParent}function jt(){return zt.isInCheckNoChangesMode}function qt(e){zt.isInCheckNoChangesMode=e}function Kt(e,t){const n=zt.lFrame;n.bindingIndex=n.bindingRootIndex=e,Xt(t)}function Xt(e){zt.lFrame.currentDirectiveIndex=e}function Zt(){return zt.lFrame.currentQueryIndex}function Yt(e){zt.lFrame.currentQueryIndex=e}function Jt(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function Qt(e,t,n){if(n&ze.SkipSelf){let r=t,s=e;for(;r=r.parent,!(null!==r||n&ze.Host||(r=Jt(s),null===r)||(s=s[15],10&r.type)););if(null===r)return!1;t=r,e=s}const r=zt.lFrame=tn();return r.currentTNode=t,r.lView=e,!0}function en(e){const t=tn(),n=e[1];zt.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function tn(){const e=zt.lFrame,t=null===e?null:e.child;return null===t?nn(e):t}function nn(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function rn(){const e=zt.lFrame;return zt.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const sn=rn;function an(){const e=rn();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function on(e){zt.lFrame.selectedIndex=e}function ln(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:a,ngAfterViewChecked:i,ngOnDestroy:o}=t;r&&(e.contentHooks||(e.contentHooks=[])).push(-n,r),s&&((e.contentHooks||(e.contentHooks=[])).push(n,s),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,s)),a&&(e.viewHooks||(e.viewHooks=[])).push(-n,a),i&&((e.viewHooks||(e.viewHooks=[])).push(n,i),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,i)),null!=o&&(e.destroyHooks||(e.destroyHooks=[])).push(n,o)}}function un(e,t,n){dn(e,t,3,n)}function cn(e,t,n,r){(3&e[2])===n&&dn(e,t,n,r)}function hn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function dn(e,t,n,r){const s=null!=r?r:-1,a=t.length-1;let i=0;for(let o=void 0!==r?65535&e[18]:0;o<a;o++)if("number"==typeof t[o+1]){if(i=t[o],null!=r&&i>=r)break}else t[o]<0&&(e[18]+=65536),(i<s||-1==s)&&(pn(e,n,t,o),e[18]=(4294901760&e[18])+o+2),o++}function pn(e,t,n,r){const s=n[r]<0,a=n[r+1],i=e[s?-n[r]:n[r]];if(s){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{a.call(i)}finally{}}}else try{a.call(i)}finally{}}const fn=-1;class mn{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function gn(e,t,n){const r=$t(e);let s=0;for(;s<n.length;){const a=n[s];if("number"==typeof a){if(0!==a)break;s++;const i=n[s++],o=n[s++],l=n[s++];r?e.setAttribute(t,o,l,i):t.setAttributeNS(i,o,l)}else{const i=a,o=n[++s];64===i.charCodeAt(0)?r&&e.setProperty(t,i,o):r?e.setAttribute(t,i,o):t.setAttribute(i,o),s++}}return s}function yn(e){return 3===e||4===e||6===e}function bn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?n=s:0===n||xn(e,n,s,null,-1===n||2===n?t[++r]:null)}}return e}function xn(e,t,n,r,s){let a=0,i=e.length;if(-1===t)i=-1;else for(;a<e.length;){const n=e[a++];if("number"==typeof n){if(n===t){i=-1;break}if(n>t){i=a-1;break}}}for(;a<e.length;){const t=e[a];if("number"==typeof t)break;if(t===n){if(null===r)return void(null!==s&&(e[a+1]=s));if(r===e[a+1])return void(e[a+2]=s)}a++,null!==r&&a++,null!==s&&a++}-1!==i&&(e.splice(i,0,t),a=i+1),e.splice(a++,0,n),null!==r&&e.splice(a++,0,r),null!==s&&e.splice(a++,0,s)}function vn(e){return e!==fn}function wn(e){return 32767&e}function kn(e,t){let n=e>>16,r=t;for(;n>0;)r=r[15],n--;return r}let In=!0;function Nn(e){const t=In;return In=e,t}let Sn=0;function Cn(e,t){const n=$n(e,t);if(-1!==n)return n;const r=t[1];r.firstCreatePass&&(e.injectorIndex=t.length,Tn(r.data,e),Tn(t,null),Tn(r.blueprint,null));const s=En(e,t),a=e.injectorIndex;if(vn(s)){const e=wn(s),n=kn(s,t),r=n[1].data;for(let s=0;s<8;s++)t[a+s]=n[e+s]|r[e+s]}return t[a+8]=s,a}function Tn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function $n(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function En(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,r=null,s=t;for(;null!==s;){const e=s[1],t=e.type;if(r=2===t?e.declTNode:1===t?s[6]:null,null===r)return fn;if(n++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return fn}function _n(e,t,n){!function(e,t,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(st)&&(r=n[st]),null==r&&(r=n[st]=Sn++);const s=255&r;t.data[e+(s>>5)]|=1<<s}(e,t,n)}function An(e,t,n){if(n&ze.Optional)return e;$e(t,"NodeInjector")}function Rn(e,t,n,r){if(n&ze.Optional&&void 0===r&&(r=null),0==(n&(ze.Self|ze.Host))){const s=e[9],a=Be(void 0);try{return s?s.get(t,r,n&ze.Optional):Ve(t,r,n&ze.Optional)}finally{Be(a)}}return An(r,t,n)}function Fn(e,t,n,r=ze.Default,s){if(null!==e){const a=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(st)?e[st]:void 0;return"number"==typeof t?t>=0?255&t:On:t}(n);if("function"==typeof a){if(!Qt(t,e,r))return r&ze.Host?An(s,n,r):Rn(t,n,r,s);try{const e=a(r);if(null!=e||r&ze.Optional)return e;$e(n)}finally{sn()}}else if("number"==typeof a){let s=null,i=$n(e,t),o=fn,l=r&ze.Host?t[16][6]:null;for((-1===i||r&ze.SkipSelf)&&(o=-1===i?En(e,t):t[i+8],o!==fn&&Bn(r,!1)?(s=t[1],i=wn(o),t=kn(o,t)):i=-1);-1!==i;){const e=t[1];if(Pn(a,i,e.data)){const e=Mn(i,t,n,s,r,l);if(e!==Dn)return e}o=t[i+8],o!==fn&&Bn(r,t[1].data[i+8]===l)&&Pn(a,i,t)?(s=e,i=wn(o),t=kn(o,t)):i=-1}}}return Rn(t,n,r,s)}const Dn={};function On(){return new Vn(Wt(),Bt())}function Mn(e,t,n,r,s,a){const i=t[1],o=i.data[e+8],l=Ln(o,i,n,null==r?xt(o)&&In:r!=i&&0!=(3&o.type),s&ze.Host&&a===o);return null!==l?zn(t,i,l,o):Dn}function Ln(e,t,n,r,s){const a=e.providerIndexes,i=t.data,o=1048575&a,l=e.directiveStart,u=a>>20,c=s?o+u:e.directiveEnd;for(let h=r?o:o+u;h<c;h++){const e=i[h];if(h<l&&n===e||h>=l&&e.type===n)return h}if(s){const e=i[l];if(e&&wt(e)&&e.type===n)return l}return null}function zn(e,t,n,r){let s=e[n];const a=t.data;if(s instanceof mn){const i=s;i.resolving&&function(e,t){throw new Ce("200",`Circular dependency in DI detected for ${e}`)}(Te(a[n]));const o=Nn(i.canSeeViewProviders);i.resolving=!0;const l=i.injectImpl?Be(i.injectImpl):null;Qt(e,r,ze.Default);try{s=e[n]=i.factory(void 0,a,e,r),t.firstCreatePass&&n>=r.directiveStart&&function(e,t,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:a}=t.type.prototype;if(r){const r=((i=t).type.prototype.ngOnChanges&&(i.setInput=St),Nt);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,r)}var i;s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,s),a&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,a),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,a))}(n,a[n],t)}finally{null!==l&&Be(l),Nn(o),i.resolving=!1,sn()}}return s}function Pn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Bn(e,t){return!(e&ze.Self||e&ze.Host&&t)}class Vn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Fn(this._tNode,this._lView,e,void 0,t)}}const Wn="__parameters__";function Un(e,t,n){return We(()=>{const r=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function s(...e){if(this instanceof s)return r.apply(this,e),this;const t=new s(...e);return n.annotation=t,n;function n(e,n,r){const s=e.hasOwnProperty(Wn)?e[Wn]:Object.defineProperty(e,Wn,{value:[]})[Wn];for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(t),e}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}class Hn{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=Ee({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Gn=new Hn("AnalyzeForEntryComponents"),jn=Function;function qn(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let r=e[n];Array.isArray(r)?(t===e&&(t=e.slice(0,n)),qn(r,t)):t!==e&&t.push(r)}return t}function Kn(e,t){e.forEach(e=>Array.isArray(e)?Kn(e,t):t(e))}function Xn(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function Zn(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}const Yn={},Jn=/\n/gm,Qn="__source",er=ve({provide:String,useValue:ve});let tr;function nr(e){const t=tr;return tr=e,t}function rr(e,t=ze.Default){if(void 0===tr)throw new Error("inject() must be called from an injection context");return null===tr?Ve(e,void 0,t):tr.get(e,t&ze.Optional?null:void 0,t)}function sr(e,t=ze.Default){return(Pe||rr)(Se(e),t)}function ar(e){const t=[];for(let n=0;n<e.length;n++){const r=Se(e[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let e,n=ze.Default;for(let t=0;t<r.length;t++){const s=r[t],a=s.__NG_DI_FLAG__;"number"==typeof a?-1===a?e=s.token:n|=a:e=s}t.push(sr(e,n))}else t.push(sr(r))}return t}function ir(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const or=ir(Un("Inject",e=>({token:e})),-1),lr=ir(Un("Optional"),8),ur=ir(Un("SkipSelf"),4);function cr(e,t){e.__ngContext__=t}function hr(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function dr(e){return e.ngDebugContext}function pr(e){return e.ngOriginalError}function fr(e,...t){e.error(...t)}class mr{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),r=function(e){return e.ngErrorLogger||fr}(e);r(this._console,"ERROR",e),t&&r(this._console,"ORIGINAL ERROR",t),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?dr(e)?dr(e):this._findContext(pr(e)):null}_findOriginalError(e){let t=pr(e);for(;t&&pr(t);)t=pr(t);return t}}const gr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Xe))();function yr(e){return e instanceof Function?e():e}var br=(()=>((br=br||{})[br.Important=1]="Important",br[br.DashCase=2]="DashCase",br))();function xr(e,t){return(void 0)(e,t)}function vr(e){const t=e[3];return yt(t)?t[3]:t}function wr(e){return Ir(e[13])}function kr(e){return Ir(e[4])}function Ir(e){for(;null!==e&&!yt(e);)e=e[4];return e}function Nr(e,t,n,r,s){if(null!=r){let a,i=!1;yt(r)?a=r:gt(r)&&(i=!0,r=r[0]);const o=_t(r);0===e&&null!==n?null==s?Ar(t,n,o):_r(t,n,o,s||null,!0):1===e&&null!==n?_r(t,n,o,s||null,!0):2===e?function(e,t,n){const r=Fr(e,t);r&&function(e,t,n,r){$t(e)?e.removeChild(t,n,r):t.removeChild(n)}(e,r,t,n)}(t,o,i):3===e&&t.destroyNode(o),null!=a&&function(e,t,n,r,s){const a=n[7];a!==_t(n)&&Nr(t,e,r,a,s);for(let i=mt;i<n.length;i++){const s=n[i];Pr(s[1],s,e,t,r,a)}}(t,e,a,n,s)}}function Sr(e,t,n){return $t(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Cr(e,t){const n=e[9],r=n.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,Lt(s,-1)),n.splice(r,1)}function Tr(e,t){if(e.length<=mt)return;const n=mt+t,r=e[n];if(r){const a=r[17];null!==a&&a!==e&&Cr(a,r),t>0&&(e[n-1][4]=r[4]);const i=Zn(e,mt+t);Pr(r[1],s=r,s[11],2,null,null),s[0]=null,s[6]=null;const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}var s;return r}function $r(e,t){if(!(256&t[2])){const n=t[11];$t(n)&&n.destroyNode&&Pr(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Er(e[1],e);for(;t;){let n=null;if(gt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)gt(t)&&Er(t[1],t),t=t[3];null===t&&(t=e),gt(t)&&Er(t[1],t),n=t&&t[4]}t=n}}(t)}}function Er(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let r=0;r<n.length;r+=2){const e=t[n[r]];if(!(e instanceof mn)){const t=n[r+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const r=e[t[n]],s=t[n+1];try{s.call(r)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,r=t[7];let s=-1;if(null!==n)for(let a=0;a<n.length-1;a+=2)if("string"==typeof n[a]){const e=n[a+1],i="function"==typeof e?e(t):_t(t[e]),o=r[s=n[a+2]],l=n[a+3];"boolean"==typeof l?i.removeEventListener(n[a],o,l):l>=0?r[s=l]():r[s=-l].unsubscribe(),a+=2}else{const e=r[s=n[a+1]];n[a].call(e)}if(null!==r){for(let e=s+1;e<r.length;e++)(0,r[e])();t[7]=null}}(e,t),1===t[1].type&&$t(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&yt(t[3])){n!==t[3]&&Cr(n,t);const r=t[19];null!==r&&r.detachView(e)}}}function _r(e,t,n,r,s){$t(e)?e.insertBefore(t,n,r,s):t.insertBefore(n,r,s)}function Ar(e,t,n){$t(e)?e.appendChild(t,n):t.appendChild(n)}function Rr(e,t,n,r,s){null!==r?_r(e,t,n,r,s):Ar(e,t,n)}function Fr(e,t){return $t(e)?e.parentNode(t):t.parentNode}function Dr(e,t,n,r){const s=function(e,t,n){return function(e,t,n){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return n[0];if(2&r.flags){const t=e.data[r.directiveStart].encapsulation;if(t===He.None||t===He.Emulated)return null}return At(r,n)}(e,t.parent,n)}(e,r,t),a=t[11],i=function(e,t,n){return function(e,t,n){return 40&e.type?At(e,n):null}(e,0,n)}(r.parent||t[6],0,t);if(null!=s)if(Array.isArray(n))for(let o=0;o<n.length;o++)Rr(a,s,n[o],i,!1);else Rr(a,s,n,i,!1)}function Or(e,t){if(null!==t){const n=t.type;if(3&n)return At(t,e);if(4&n)return Lr(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Or(e,n);{const n=e[t.index];return yt(n)?Lr(-1,n):_t(n)}}if(32&n)return xr(t,e)()||_t(e[t.index]);{const n=Mr(e,t);return null!==n?Array.isArray(n)?n[0]:Or(vr(e[16]),n):Or(e,t.next)}}return null}function Mr(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Lr(e,t){const n=mt+e+1;if(n<t.length){const e=t[n],r=e[1].firstChild;if(null!==r)return Or(e,r)}return t[7]}function zr(e,t,n,r,s,a,i){for(;null!=n;){const o=r[n.index],l=n.type;if(i&&0===t&&(o&&cr(_t(o),r),n.flags|=4),64!=(64&n.flags))if(8&l)zr(e,t,n.child,r,s,a,!1),Nr(t,e,s,o,a);else if(32&l){const i=xr(n,r);let l;for(;l=i();)Nr(t,e,s,l,a);Nr(t,e,s,o,a)}else 16&l?Br(e,t,r,n,s,a):Nr(t,e,s,o,a);n=i?n.projectionNext:n.next}}function Pr(e,t,n,r,s,a){zr(n,r,e.firstChild,t,s,a,!1)}function Br(e,t,n,r,s,a){const i=n[16],o=i[6].projection[r.projection];if(Array.isArray(o))for(let l=0;l<o.length;l++)Nr(t,e,s,o[l],a);else zr(e,t,o,i[3],s,a,!0)}function Vr(e,t,n){$t(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Wr(e,t,n){$t(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function Ur(e,t,n){let r=e.length;for(;;){const s=e.indexOf(t,n);if(-1===s)return s;if(0===s||e.charCodeAt(s-1)<=32){const n=t.length;if(s+n===r||e.charCodeAt(s+n)<=32)return s}n=s+1}}const Hr="ng-template";function Gr(e,t,n){let r=0;for(;r<e.length;){let s=e[r++];if(n&&"class"===s){if(s=e[r],-1!==Ur(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<e.length&&"string"==typeof(s=e[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function jr(e){return 4===e.type&&e.value!==Hr}function qr(e,t,n){return t===(4!==e.type||n?e.value:Hr)}function Kr(e,t,n){let r=4;const s=e.attrs||[],a=function(e){for(let t=0;t<e.length;t++)if(yn(e[t]))return t;return e.length}(s);let i=!1;for(let o=0;o<t.length;o++){const l=t[o];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!qr(e,l,n)||""===l&&1===t.length){if(Xr(r))return!1;i=!0}}else{const u=8&r?l:t[++o];if(8&r&&null!==e.attrs){if(!Gr(e.attrs,u,n)){if(Xr(r))return!1;i=!0}continue}const c=Zr(8&r?"class":l,s,jr(e),n);if(-1===c){if(Xr(r))return!1;i=!0;continue}if(""!==u){let e;e=c>a?"":s[c+1].toLowerCase();const t=8&r?e:null;if(t&&-1!==Ur(t,u,0)||2&r&&u!==e){if(Xr(r))return!1;i=!0}}}}else{if(!i&&!Xr(r)&&!Xr(l))return!1;if(i&&Xr(l))continue;i=!1,r=l|1&r}}return Xr(r)||i}function Xr(e){return 0==(1&e)}function Zr(e,t,n,r){if(null===t)return-1;let s=0;if(r||!n){let n=!1;for(;s<t.length;){const r=t[s];if(r===e)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let e=t[++s];for(;"string"==typeof e;)e=t[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const r=e[n];if("number"==typeof r)return-1;if(r===t)return n;n++}return-1}(t,e)}function Yr(e,t,n=!1){for(let r=0;r<t.length;r++)if(Kr(e,t[r],n))return!0;return!1}function Jr(e,t){return e?":not("+t.trim()+")":t}function Qr(e){let t=e[0],n=1,r=2,s="",a=!1;for(;n<e.length;){let i=e[n];if("string"==typeof i)if(2&r){const t=e[++n];s+="["+i+(t.length>0?'="'+t+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""===s||Xr(i)||(t+=Jr(a,s),s=""),r=i,a=a||!Xr(r);n++}return""!==s&&(t+=Jr(a,s)),t}const es={};function ts(e,t){const n=e.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],a=n[r+1];if(-1!==a){const n=e.data[a];Yt(s),n.contentQueries(2,t[a],a)}}}function ns(e,t,n,r,s,a,i,o,l,u){const c=t.blueprint.slice();return c[0]=s,c[2]=140|r,Mt(c),c[3]=c[15]=e,c[8]=n,c[10]=i||e&&e[10],c[11]=o||e&&e[11],c[12]=l||e&&e[12]||null,c[9]=u||e&&e[9]||null,c[6]=a,c[16]=2==t.type?e[16]:c,c}function rs(e,t,n,r,s){let a=e.data[t];if(null===a)a=function(e,t,n,r,s){const a=Ut(),i=Gt(),o=e.data[t]=function(e,t,n,r,s,a){return{type:n,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:a,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?a:a&&a.parent,n,t,r,s);return null===e.firstChild&&(e.firstChild=o),null!==a&&(i?null==a.child&&null!==o.parent&&(a.child=o):null===a.next&&(a.next=o)),o}(e,t,n,r,s),zt.lFrame.inI18n&&(a.flags|=64);else if(64&a.type){a.type=n,a.value=r,a.attrs=s;const e=function(){const e=zt.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();a.injectorIndex=null===e?-1:e.injectorIndex}return Ht(a,!0),a}function ss(e,t,n,r){if(0===n)return-1;const s=t.length;for(let a=0;a<n;a++)t.push(r),e.blueprint.push(r),e.data.push(null);return s}function as(e,t,n){en(t);try{const r=e.viewQuery;null!==r&&Es(1,r,n);const s=e.template;null!==s&&ls(e,t,s,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&ts(e,t),e.staticViewQueries&&Es(2,e.viewQuery,n);const a=e.components;null!==a&&function(e,t){for(let n=0;n<t.length;n++)Ns(e,t[n])}(t,a)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),r}finally{t[2]&=-5,an()}}function is(e,t,n,r){const s=t[2];if(256==(256&s))return;en(t);const a=jt();try{Mt(t),zt.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&ls(e,t,n,2,r);const i=3==(3&s);if(!a)if(i){const n=e.preOrderCheckHooks;null!==n&&un(t,n,null)}else{const n=e.preOrderHooks;null!==n&&cn(t,n,0,null),hn(t,0)}if(function(e){for(let t=wr(e);null!==t;t=kr(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],r=n[3];0==(1024&n[2])&&Lt(r,1),n[2]|=1024}}}(t),function(e){for(let t=wr(e);null!==t;t=kr(t))for(let e=mt;e<t.length;e++){const n=t[e],r=n[1];Dt(n)&&is(r,n,r.template,n[8])}}(t),null!==e.contentQueries&&ts(e,t),!a)if(i){const n=e.contentCheckHooks;null!==n&&un(t,n)}else{const n=e.contentHooks;null!==n&&cn(t,n,1),hn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const r=n[e];if(r<0)on(~r);else{const s=r,a=n[++e],i=n[++e];Kt(a,s),i(2,t[s])}}}finally{on(-1)}}(e,t);const o=e.components;null!==o&&function(e,t){for(let n=0;n<t.length;n++)ks(e,t[n])}(t,o);const l=e.viewQuery;if(null!==l&&Es(2,l,r),!a)if(i){const n=e.viewCheckHooks;null!==n&&un(t,n)}else{const n=e.viewHooks;null!==n&&cn(t,n,2),hn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),a||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Lt(t[3],-1))}finally{an()}}function os(e,t,n,r){const s=t[10],a=!jt(),i=Ft(t);try{a&&!i&&s.begin&&s.begin(),i&&as(e,t,r),is(e,t,n,r)}finally{a&&!i&&s.end&&s.end()}}function ls(e,t,n,r,s){const a=zt.lFrame.selectedIndex,i=2&r;try{on(-1),i&&t.length>20&&function(e,t,n,r){if(!r)if(3==(3&t[2])){const n=e.preOrderCheckHooks;null!==n&&un(t,n,20)}else{const n=e.preOrderHooks;null!==n&&cn(t,n,0,20)}on(20)}(e,t,0,jt()),n(r,s)}finally{on(a)}}function us(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=cs(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function cs(e,t,n,r,s,a,i,o,l,u){const c=20+r,h=c+s,d=function(e,t){const n=[];for(let r=0;r<t;r++)n.push(r<e?null:es);return n}(c,h),p="function"==typeof u?u():u;return d[1]={type:e,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:t,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof a?a():a,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function hs(e,t,n,r){const s=As(t);null===n?s.push(r):(s.push(n),e.firstCreatePass&&Rs(e).push(r,s.length-1))}function ds(e,t,n){for(let r in e)if(e.hasOwnProperty(r)){const s=e[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(t,s):n[r]=[t,s]}return n}function ps(e,t,n,r,s,a){const i=a.hostBindings;if(i){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const a=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=a&&n.push(a),n.push(r,s,i)}}function fs(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function ms(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function gs(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;wt(t)&&(n[""]=e)}}function ys(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function bs(e,t,n,r,s){e.data[r]=s;const a=s.factory||(s.factory=kt(s.type)),i=new mn(a,wt(s),null);e.blueprint[r]=i,n[r]=i,ps(e,t,0,r,ss(e,n,s.hostVars,es),s)}function xs(e,t,n){const r=At(t,e),s=us(n),a=e[10],i=Ss(e,ns(e,s,null,n.onPush?64:16,r,t,a,a.createRenderer(r,n),null,null));e[t.index]=i}function vs(e,t,n,r,s,a){const i=a[t];if(null!==i){const e=r.setInput;for(let t=0;t<i.length;){const s=i[t++],a=i[t++],o=i[t++];null!==e?r.setInput(n,o,s,a):n[a]=o}}}function ws(e,t){let n=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;e.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,e[s],t[r+1])),r+=2}else r+=2;else r+=4}return n}function ks(e,t){const n=Rt(t,e);if(Dt(n)){const e=n[1];80&n[2]?is(e,n,e.template,n[8]):n[5]>0&&Is(n)}}function Is(e){for(let n=wr(e);null!==n;n=kr(n))for(let e=mt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];is(e,t,e.template,t[8])}else t[5]>0&&Is(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const r=Rt(t[n],e);Dt(r)&&r[5]>0&&Is(r)}}function Ns(e,t){const n=Rt(t,e),r=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(r,n),as(r,n,n[8])}function Ss(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Cs(e){for(;e;){e[2]|=64;const t=vr(e);if(0!=(512&e[2])&&!t)return e;e=t}return null}function Ts(e,t,n){const r=t[10];r.begin&&r.begin();try{is(e,t,e.template,n)}catch(s){throw Fs(t,s),s}finally{r.end&&r.end()}}function $s(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],r=hr(n),s=r[1];os(s,r,s.template,n)}}(e[8])}function Es(e,t,n){Yt(0),t(e,n)}const _s=(()=>Promise.resolve(null))();function As(e){return e[7]||(e[7]=[])}function Rs(e){return e.cleanup||(e.cleanup=[])}function Fs(e,t){const n=e[9],r=n?n.get(mr,null):null;r&&r.handleError(t)}function Ds(e,t,n){let r=n?e.styles:null,s=n?e.classes:null,a=0;if(null!==t)for(let i=0;i<t.length;i++){const e=t[i];"number"==typeof e?a=e:1==a?s=ke(s,e):2==a&&(r=ke(r,e+": "+t[++i]+";"))}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=s:e.classesWithoutHost=s}const Os=new Hn("INJECTOR",-1);class Ms{get(e,t=Yn){if(t===Yn){const t=new Error(`NullInjectorError: No provider for ${we(e)}!`);throw t.name="NullInjectorError",t}return t}}const Ls=new Hn("Set Injector scope."),zs={},Ps={};let Bs;function Vs(){return void 0===Bs&&(Bs=new Ms),Bs}function Ws(e,t=null,n=null,r){return new Us(e,n,t||Vs(),r)}class Us{constructor(e,t,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];t&&Kn(t,n=>this.processProvider(n,e,t)),Kn([e],e=>this.processInjectorType(e,[],s)),this.records.set(Os,Gs(void 0,this));const a=this.records.get(Ls);this.scope=null!=a?a.value:null,this.source=r||("object"==typeof e?null:we(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=Yn,n=ze.Default){this.assertNotDestroyed();const r=nr(this);try{if(!(n&ze.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(s=e)||"object"==typeof s&&s instanceof Hn)&&Ae(e);t=n&&this.injectableDefInScope(n)?Gs(Hs(e),zs):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&ze.Self?Vs():this.parent).get(e,t=n&ze.Optional&&t===Yn?null:t)}catch(a){if("NullInjectorError"===a.name){if((a.ngTempTokenPath=a.ngTempTokenPath||[]).unshift(we(e)),r)throw a;return function(e,t,n,r){const s=e.ngTempTokenPath;throw t[Qn]&&s.unshift(t[Qn]),e.message=function(e,t,n,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let s=we(t);if(Array.isArray(t))s=t.map(we).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let r=t[n];e.push(n+":"+("string"==typeof r?JSON.stringify(r):we(r)))}s=`{${e.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${e.replace(Jn,"\n  ")}`}("\n"+e.message,s,n,r),e.ngTokenPath=s,e.ngTempTokenPath=null,e}(a,e,"R3InjectorError",this.source)}throw a}finally{nr(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(we(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=Se(e)))return!1;let r=Fe(e);const s=null==r&&e.ngModule||void 0,a=void 0===s?e:s,i=-1!==n.indexOf(a);if(void 0!==s&&(r=Fe(s)),null==r)return!1;if(null!=r.imports&&!i){let e;n.push(a);try{Kn(r.imports,r=>{this.processInjectorType(r,t,n)&&(void 0===e&&(e=[]),e.push(r))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:r}=e[t];Kn(r,e=>this.processProvider(e,n,r||Ye))}}this.injectorDefTypes.add(a);const o=kt(a)||(()=>new a);this.records.set(a,Gs(o,zs));const l=r.providers;if(null!=l&&!i){const t=e;Kn(l,e=>this.processProvider(e,t,l))}return void 0!==s&&void 0!==e.providers}processProvider(e,t,n){let r=qs(e=Se(e))?e:Se(e&&e.provide);const s=function(e,t,n){return js(e)?Gs(void 0,e.useValue):Gs(function(e,t,n){let r;if(qs(e)){const t=Se(e);return kt(t)||Hs(t)}if(js(e))r=()=>Se(e.useValue);else if((s=e)&&s.useFactory)r=()=>e.useFactory(...ar(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))r=()=>sr(Se(e.useExisting));else{const t=Se(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return kt(t)||Hs(t);r=()=>new t(...ar(e.deps))}var s;return r}(e),zs)}(e);if(qs(e)||!0!==e.multi)this.records.get(r);else{let t=this.records.get(r);t||(t=Gs(void 0,zs,!0),t.factory=()=>ar(t.multi),this.records.set(r,t)),r=e,t.multi.push(e)}this.records.set(r,s)}hydrate(e,t){var n;return t.value===zs&&(t.value=Ps,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=Se(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function Hs(e){const t=Ae(e),n=null!==t?t.factory:kt(e);if(null!==n)return n;if(e instanceof Hn)throw new Error(`Token ${we(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let r=0;r<e;r++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${we(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[De]||e[Me]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function Gs(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function js(e){return null!==e&&"object"==typeof e&&er in e}function qs(e){return"function"==typeof e}const Ks=function(e,t,n){return function(e,t=null,n=null,r){const s=Ws(e,t,n,r);return s._resolveInjectorDefTypes(),s}({name:n},t,e,n)};class Xs{static create(e,t){return Array.isArray(e)?Ks(e,t,""):Ks(e.providers,e.parent,e.name||"")}}function Zs(e,t){ln(hr(e)[1],Wt())}Xs.THROW_IF_NOT_FOUND=Yn,Xs.NULL=new Ms,Xs.\u0275prov=Ee({token:Xs,providedIn:"any",factory:()=>sr(Os)}),Xs.__NG_ELEMENT_ID__=-1;let Ys=null;function Js(){if(!Ys){const e=Xe.Symbol;if(e&&e.iterator)Ys=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Ys=n)}}}return Ys}function Qs(e){return!!ea(e)&&(Array.isArray(e)||!(e instanceof Map)&&Js()in e)}function ea(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function ta(e,t=ze.Default){const n=Bt();return null===n?sr(e,t):Fn(Wt(),n,Se(e),t)}function na(e,t,n,r,s){const a=s?"class":"style";!function(e,t,n,r,s){for(let a=0;a<n.length;){const i=n[a++],o=n[a++],l=t[i],u=e.data[i];null!==u.setInput?u.setInput(l,s,r,o):l[o]=s}}(e,n,t.inputs[a],a,r)}function ra(e,t,n,r){const s=Bt(),a=Vt(),i=20+e,o=s[11],l=s[i]=Sr(o,t,zt.lFrame.currentNamespace),u=a.firstCreatePass?function(e,t,n,r,s,a,i){const o=t.consts,l=rs(t,e,2,s,Ot(o,a));return function(e,t,n,r){let s=!1;if(Pt()){const a=function(e,t,n){const r=e.directiveRegistry;let s=null;if(r)for(let a=0;a<r.length;a++){const i=r[a];Yr(n,i.selectors,!1)&&(s||(s=[]),_n(Cn(n,t),e,i.type),wt(i)?(ms(e,n),s.unshift(i)):s.push(i))}return s}(e,t,n),i=null===r?null:{"":-1};if(null!==a){s=!0,ys(n,e.data.length,a.length);for(let e=0;e<a.length;e++){const t=a[e];t.providersResolver&&t.providersResolver(t)}let r=!1,o=!1,l=ss(e,t,a.length,null);for(let s=0;s<a.length;s++){const u=a[s];n.mergedAttrs=bn(n.mergedAttrs,u.hostAttrs),bs(e,n,t,l,u),gs(l,u,i),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!r&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),r=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),o=!0),l++}!function(e,t){const n=t.directiveEnd,r=e.data,s=t.attrs,a=[];let i=null,o=null;for(let l=t.directiveStart;l<n;l++){const e=r[l],n=e.inputs,u=null===s||jr(t)?null:ws(n,s);a.push(u),i=ds(n,l,i),o=ds(e.outputs,l,o)}null!==i&&(i.hasOwnProperty("class")&&(t.flags|=16),i.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=a,t.inputs=i,t.outputs=o}(e,n)}i&&function(e,t,n){if(t){const r=e.localNames=[];for(let e=0;e<t.length;e+=2){const s=n[t[e+1]];if(null==s)throw new Ce("301",`Export of name '${t[e+1]}' not found!`);r.push(t[e],s)}}}(n,r,i)}n.mergedAttrs=bn(n.mergedAttrs,n.attrs)}(t,n,l,Ot(o,i)),null!==l.attrs&&Ds(l,l.attrs,!1),null!==l.mergedAttrs&&Ds(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(i,a,s,0,t,n,r):a.data[i];Ht(u,!0);const c=u.mergedAttrs;null!==c&&gn(o,l,c);const h=u.classes;null!==h&&Wr(o,l,h);const d=u.styles;null!==d&&Vr(o,l,d),64!=(64&u.flags)&&Dr(a,s,l,u),0===zt.lFrame.elementDepthCount&&cr(l,s),zt.lFrame.elementDepthCount++,vt(u)&&(function(e,t,n){Pt()&&(function(e,t,n,r){const s=n.directiveStart,a=n.directiveEnd;e.firstCreatePass||Cn(n,t),cr(r,t);const i=n.initialInputs;for(let o=s;o<a;o++){const r=e.data[o],a=wt(r);a&&xs(t,n,r);const l=zn(t,e,o,n);cr(l,t),null!==i&&vs(0,o-s,l,r,0,i),a&&(Rt(n.index,t)[8]=l)}}(e,t,n,At(n,t)),128==(128&n.flags)&&function(e,t,n){const r=n.directiveStart,s=n.directiveEnd,a=n.index,i=zt.lFrame.currentDirectiveIndex;try{on(a);for(let n=r;n<s;n++){const r=e.data[n],s=t[n];Xt(n),null===r.hostBindings&&0===r.hostVars&&null===r.hostAttrs||fs(r,s)}}finally{on(-1),Xt(i)}}(e,t,n))}(a,s,u),function(e,t,n){if(bt(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s<r;s++){const t=e.data[s];t.contentQueries&&t.contentQueries(1,n[s],s)}}}(a,u,s)),null!==r&&function(e,t,n=At){const r=t.localNames;if(null!==r){let s=t.index+1;for(let a=0;a<r.length;a+=2){const i=r[a+1],o=-1===i?n(t,e):e[i];e[s++]=o}}}(s,u)}function sa(){let e=Wt();Gt()?zt.lFrame.isParent=!1:(e=e.parent,Ht(e,!1));const t=e;zt.lFrame.elementDepthCount--;const n=Vt();n.firstCreatePass&&(ln(n,e),bt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&na(n,t,Bt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&na(n,t,Bt(),t.stylesWithoutHost,!1)}function aa(e,t,n,r){ra(e,t,n,r),sa()}function ia(e){return!!e&&"function"==typeof e.then}const oa=function(e){return!!e&&"function"==typeof e.subscribe};function la(e,t,n,r){const s=Bt(),a=Vt(),i=Wt();return function(e,t,n,r,s,a,i,o){const l=vt(r),u=e.firstCreatePass&&Rs(e),c=As(t);let h=!0;if(3&r.type||o){const d=At(r,t),p=o?o(d):d,f=c.length,m=o?e=>o(_t(e[r.index])):r.index;if($t(n)){let i=null;if(!o&&l&&(i=function(e,t,n,r){const s=e.cleanup;if(null!=s)for(let a=0;a<s.length-1;a+=2){const e=s[a];if(e===n&&s[a+1]===r){const e=t[7],n=s[a+2];return e.length>n?e[n]:null}"string"==typeof e&&(a+=2)}return null}(e,t,s,r.index)),null!==i)(i.__ngLastListenerFn__||i).__ngNextListenerFn__=a,i.__ngLastListenerFn__=a,h=!1;else{a=ca(r,t,0,a,!1);const e=n.listen(p,s,a);c.push(a,e),u&&u.push(s,m,f,f+1)}}else a=ca(r,t,0,a,!0),p.addEventListener(s,a,i),c.push(a),u&&u.push(s,m,f,i)}else a=ca(r,t,0,a,!1);const d=r.outputs;let p;if(h&&null!==d&&(p=d[s])){const e=p.length;if(e)for(let n=0;n<e;n+=2){const e=t[p[n]][p[n+1]].subscribe(a),i=c.length;c.push(a,e),u&&u.push(s,r.index,i,-(i+1))}}}(a,s,s[11],i,e,t,!!n,r),la}function ua(e,t,n,r){try{return!1!==n(r)}catch(s){return Fs(e,s),!1}}function ca(e,t,n,r,s){return function n(a){if(a===Function)return r;const i=2&e.flags?Rt(e.index,t):t;0==(32&t[2])&&Cs(i);let o=ua(t,0,r,a),l=n.__ngNextListenerFn__;for(;l;)o=ua(t,0,l,a)&&o,l=l.__ngNextListenerFn__;return s&&!1===o&&(a.preventDefault(),a.returnValue=!1),o}}const ha=void 0;var da=["en",[["a","p"],["AM","PM"],ha],[["AM","PM"],ha,ha],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],ha,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],ha,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",ha,"{1} 'at' {0}",ha],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let pa={};function fa(e){return e in pa||(pa[e]=Xe.ng&&Xe.ng.common&&Xe.ng.common.locales&&Xe.ng.common.locales[e]),pa[e]}var ma=(()=>((ma=ma||{})[ma.LocaleId=0]="LocaleId",ma[ma.DayPeriodsFormat=1]="DayPeriodsFormat",ma[ma.DayPeriodsStandalone=2]="DayPeriodsStandalone",ma[ma.DaysFormat=3]="DaysFormat",ma[ma.DaysStandalone=4]="DaysStandalone",ma[ma.MonthsFormat=5]="MonthsFormat",ma[ma.MonthsStandalone=6]="MonthsStandalone",ma[ma.Eras=7]="Eras",ma[ma.FirstDayOfWeek=8]="FirstDayOfWeek",ma[ma.WeekendRange=9]="WeekendRange",ma[ma.DateFormat=10]="DateFormat",ma[ma.TimeFormat=11]="TimeFormat",ma[ma.DateTimeFormat=12]="DateTimeFormat",ma[ma.NumberSymbols=13]="NumberSymbols",ma[ma.NumberFormats=14]="NumberFormats",ma[ma.CurrencyCode=15]="CurrencyCode",ma[ma.CurrencySymbol=16]="CurrencySymbol",ma[ma.CurrencyName=17]="CurrencyName",ma[ma.Currencies=18]="Currencies",ma[ma.Directionality=19]="Directionality",ma[ma.PluralCase=20]="PluralCase",ma[ma.ExtraData=21]="ExtraData",ma))();const ga="en-US";let ya=ga;function ba(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,r){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(ya=e.toLowerCase().replace(/_/g,"-"))}class xa{}class va{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${we(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}class wa{}function ka(...e){}function Ia(e,t){return new Sa(At(e,t))}wa.NULL=new va;const Na=function(){return Ia(Wt(),Bt())};let Sa=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=Na,e})();function Ca(e){return e instanceof Sa?e.nativeElement:e}class Ta{}let $a=(()=>{class e{}return e.\u0275prov=Ee({token:e,providedIn:"root",factory:()=>null}),e})();class Ea{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const _a=new Ea("12.1.1");class Aa{constructor(){}supports(e){return Qs(e)}create(e){return new Fa(e)}}const Ra=(e,t)=>t;class Fa{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||Ra}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,r=0,s=null;for(;t||n;){const a=!n||t&&t.currentIndex<La(n,r,s)?t:n,i=La(a,r,s),o=a.currentIndex;if(a===n)r--,n=n._nextRemoved;else if(t=t._next,null==a.previousIndex)r++;else{s||(s=[]);const e=i-r,t=o-r;if(e!=t){for(let n=0;n<e;n++){const r=n<s.length?s[n]:s[n]=0,a=r+n;t<=a&&a<e&&(s[n]=r+1)}s[a.previousIndex]=t-e}}i!==o&&e(a,i,o)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!Qs(e))throw new Error(`Error trying to diff '${we(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,r,s=this._itHead,a=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],r=this._trackByFn(t,n),null!==s&&Object.is(s.trackById,r)?(a&&(s=this._verifyReinsertion(s,n,r,t)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,t),a=!0),s=s._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[Js()]();let r;for(;!(r=n.next()).done;)t(r.value)}}(e,e=>{r=this._trackByFn(t,e),null!==s&&Object.is(s.trackById,r)?(a&&(s=this._verifyReinsertion(s,e,r,t)),Object.is(s.item,e)||this._addIdentityChange(s,e)):(s=this._mismatch(s,e,r,t),a=!0),s=s._next,t++}),this.length=t;return this._truncate(s),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,r){let s;return null===e?s=this._itTail:(s=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,s,r)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,s,r)):e=this._addAfter(new Da(t,n),s,r),e}_verifyReinsertion(e,t,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?e=this._reinsertAfter(s,e._prev,r):e.currentIndex!=r&&(e.currentIndex=r,this._addToMoves(e,r)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const r=e._prevRemoved,s=e._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const r=null===t?this._itHead:t._next;return e._next=r,e._prev=t,null===r?this._itTail=e:r._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new Ma),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Ma),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class Da{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Oa{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class Ma{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new Oa,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function La(e,t,n){const r=e.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+t+s}class za{constructor(){}supports(e){return e instanceof Map||ea(e)}create(){return new Pa}}class Pa{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||ea(e)))throw new Error(`Error trying to diff '${we(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const r=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,r)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new Ba(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class Ba{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Va(){return new Wa([new Aa])}let Wa=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Va()),deps:[[e,new ur,new lr]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=Ee({token:e,providedIn:"root",factory:Va}),e})();function Ua(){return new Ha([new za])}let Ha=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Ua()),deps:[[e,new ur,new lr]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=Ee({token:e,providedIn:"root",factory:Ua}),e})();function Ga(e,t,n,r,s=!1){for(;null!==n;){const a=t[n.index];if(null!==a&&r.push(_t(a)),yt(a))for(let e=mt;e<a.length;e++){const t=a[e],n=t[1].firstChild;null!==n&&Ga(t[1],t,n,r)}const i=n.type;if(8&i)Ga(e,t,n.child,r);else if(32&i){const e=xr(n,t);let s;for(;s=e();)r.push(s)}else if(16&i){const e=Mr(t,n);if(Array.isArray(e))r.push(...e);else{const n=vr(t[16]);Ga(n[1],n,e,r,!0)}}n=s?n.projectionNext:n.next}return r}class ja{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return Ga(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(yt(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(Tr(e,n),Zn(t,n))}this._attachedToViewContainer=!1}$r(this._lView[1],this._lView)}onDestroy(e){hs(this._lView[1],this._lView,null,e)}markForCheck(){Cs(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Ts(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){qt(!0);try{Ts(e,t,n)}finally{qt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,Pr(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class qa extends ja{constructor(e){super(e),this._view=e}detectChanges(){$s(this._view)}checkNoChanges(){!function(e){qt(!0);try{$s(e)}finally{qt(!1)}}(this._view)}get context(){return null}}const Ka=function(e){return function(e,t,n){if(xt(e)&&!n){const n=Rt(e.index,t);return new ja(n,n)}return 47&e.type?new ja(t[16],t):null}(Wt(),Bt(),16==(16&e))};let Xa=(()=>{class e{}return e.__NG_ELEMENT_ID__=Ka,e})();const Za=[new za],Ya=new Wa([new Aa]),Ja=new Ha(Za),Qa=function(){return ri(Wt(),Bt())};let ei=(()=>{class e{}return e.__NG_ELEMENT_ID__=Qa,e})();const ti=ei,ni=class extends ti{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=ns(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const r=this._declarationLView[19];return null!==r&&(n[19]=r.createEmbeddedView(t)),as(t,n,e),new ja(n)}};function ri(e,t){return 4&e.type?new ni(t,e,Ia(e,t)):null}class si{}class ai{}const ii=function(){return di(Wt(),Bt())};let oi=(()=>{class e{}return e.__NG_ELEMENT_ID__=ii,e})();const li=oi,ui=class extends li{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return Ia(this._hostTNode,this._hostLView)}get injector(){return new Vn(this._hostTNode,this._hostLView)}get parentInjector(){const e=En(this._hostTNode,this._hostLView);if(vn(e)){const t=kn(e,this._hostLView),n=wn(e);return new Vn(t[1].data[n+8],t)}return new Vn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=ci(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-mt}createEmbeddedView(e,t,n){const r=e.createEmbeddedView(t||{});return this.insert(r,n),r}createComponent(e,t,n,r,s){const a=n||this.parentInjector;if(!s&&null==e.ngModule&&a){const e=a.get(si,null);e&&(s=e)}const i=e.create(a,r,void 0,s);return this.insert(i.hostView,t),i}insert(e,t){const n=e._lView,r=n[1];if(yt(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],r=new ui(t,t[6],t[3]);r.detach(r.indexOf(e))}}const s=this._adjustIndex(t),a=this._lContainer;!function(e,t,n,r){const s=mt+r,a=n.length;r>0&&(n[s-1][4]=t),r<a-mt?(t[4]=n[s],Xn(n,mt+r,t)):(n.push(t),t[4]=null),t[3]=n;const i=t[17];null!==i&&n!==i&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(i,t);const o=t[19];null!==o&&o.insertView(e),t[2]|=128}(r,n,a,s);const i=Lr(s,a),o=n[11],l=Fr(o,a[7]);return null!==l&&function(e,t,n,r,s,a){r[0]=s,r[6]=t,Pr(e,r,n,1,s,a)}(r,a[6],o,n,l,i),e.attachToViewContainerRef(),Xn(hi(a),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=ci(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=Tr(this._lContainer,t);n&&(Zn(hi(this._lContainer),t),$r(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=Tr(this._lContainer,t);return n&&null!=Zn(hi(this._lContainer),t)?new ja(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function ci(e){return e[8]}function hi(e){return e[8]||(e[8]=[])}function di(e,t){let n;const r=t[e.index];if(yt(r))n=r;else{let s;if(8&e.type)s=_t(r);else{const n=t[11];s=n.createComment("");const r=At(e,t);_r(n,Fr(n,r),s,function(e,t){return $t(e)?e.nextSibling(t):t.nextSibling}(n,r),!1)}t[e.index]=n=new Array(r,!0,!1,t,null,0,e,s,null,null),Ss(t,n)}return new ui(n,e,t)}const pi={};class fi extends wa{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=pt(e);return new yi(t,this.ngModule)}}function mi(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const gi=new Hn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>gr});class yi extends xa{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(Qr).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return mi(this.componentDef.inputs)}get outputs(){return mi(this.componentDef.outputs)}create(e,t,n,r){const s=(r=r||this.ngModule)?function(e,t){return{get:(n,r,s)=>{const a=e.get(n,pi,s);return a!==pi||r===pi?a:t.get(n,r,s)}}}(e,r.injector):e,a=s.get(Ta,Et),i=s.get($a,null),o=a.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(e,t,n){if($t(e))return e.selectRootElement(t,n===He.ShadowDom);let r="string"==typeof t?e.querySelector(t):t;return r.textContent="",r}(o,n,this.componentDef.encapsulation):Sr(a.createRenderer(null,this.componentDef),l,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:gr,clean:_s,playerHandler:null,flags:0},d=cs(0,null,null,1,0,null,null,null,null,null),p=ns(null,d,h,c,null,null,a,o,i,s);let f,m;en(p);try{const e=function(e,t,n,r,s,a){const i=n[1];n[20]=e;const o=rs(i,20,2,"#host",null),l=o.mergedAttrs=t.hostAttrs;null!==l&&(Ds(o,l,!0),null!==e&&(gn(s,e,l),null!==o.classes&&Wr(s,e,o.classes),null!==o.styles&&Vr(s,e,o.styles)));const u=r.createRenderer(e,t),c=ns(n,us(t),null,t.onPush?64:16,n[20],o,r,u,null,null);return i.firstCreatePass&&(_n(Cn(o,n),i,t.type),ms(i,o),ys(o,n.length,1)),Ss(n,c),n[20]=c}(u,this.componentDef,p,a,o);if(u)if(n)gn(o,u,["ng-version",_a.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let r=1,s=2;for(;r<e.length;){let a=e[r];if("string"==typeof a)2===s?""!==a&&t.push(a,e[++r]):8===s&&n.push(a);else{if(!Xr(s))break;s=a}r++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&gn(o,u,e),t&&t.length>0&&Wr(o,u,t.join(" "))}if(m=d.data[20],void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=t[n];e.push(null!=r?Array.from(r):null)}}f=function(e,t,n,r,s){const a=n[1],i=function(e,t,n){const r=Wt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),bs(e,r,t,ss(e,t,1,null),n));const s=zn(t,e,r.directiveStart,r);cr(s,t);const a=At(r,t);return a&&cr(a,t),s}(a,n,t);if(r.components.push(i),e[8]=i,s&&s.forEach(e=>e(i,t)),t.contentQueries){const e=Wt();t.contentQueries(1,i,e.directiveStart)}const o=Wt();return!a.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(on(o.index),ps(n[1],o,0,o.directiveStart,o.directiveEnd,t),fs(t,i)),i}(e,this.componentDef,p,h,[Zs]),as(d,p,null)}finally{an()}return new bi(this.componentType,f,Ia(m,p),p,m)}}class bi extends class{}{constructor(e,t,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.instance=t,this.hostView=this.changeDetectorRef=new qa(r),this.componentType=e}get injector(){return new Vn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const xi=new Map;class vi extends si{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new fi(this);const n=ft(e),r=e[nt]||null;r&&ba(r),this._bootstrapComponents=yr(n.bootstrap),this._r3Injector=Ws(e,t,[{provide:si,useValue:this},{provide:wa,useValue:this.componentFactoryResolver}],we(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=Xs.THROW_IF_NOT_FOUND,n=ze.Default){return e===Xs||e===si||e===Os?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class wi extends ai{constructor(e){super(),this.moduleType=e,null!==ft(e)&&function(e){const t=new Set;!function e(n){const r=ft(n,!0),s=r.id;null!==s&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${we(t)} vs ${we(t.name)}`)}(s,xi.get(s),n),xi.set(s,n));const a=yr(r.imports);for(const i of a)t.has(i)||(t.add(i),e(i))}(e)}(e)}create(e){return new vi(this.moduleType,e)}}function ki(e){return t=>{setTimeout(e,void 0,t)}}const Ii=class extends j{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var r,s,a;let i=e,o=t||(()=>null),l=n;if(e&&"object"==typeof e){const t=e;i=null===(r=t.next)||void 0===r?void 0:r.bind(t),o=null===(s=t.error)||void 0===s?void 0:s.bind(t),l=null===(a=t.complete)||void 0===a?void 0:a.bind(t)}this.__isAsync&&(o=ki(o),i&&(i=ki(i)),l&&(l=ki(l)));const u=super.subscribe({next:i,error:o,complete:l});return e instanceof D&&e.add(u),u}};function Ni(){return this._results[Js()]()}class Si{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=Js(),n=Si.prototype;n[t]||(n[t]=Ni)}get changes(){return this._changes||(this._changes=new Ii)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const r=qn(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let s=e[r],a=t[r];if(n&&(s=n(s),a=n(a)),a!==s)return!1}return!0}(n._results,r,t))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;class Ci{constructor(e){this.queryList=e,this.matches=null}clone(){return new Ci(this.queryList)}setDirty(){this.queryList.setDirty()}}class Ti{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,r=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);r.push(this.queries[n.indexInDeclarationView].clone())}return new Ti(r)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==zi(e,t).matches&&this.queries[t].setDirty()}}class $i{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class Ei{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const r=null!==t?t.length:0,s=this.getByIndex(n).embeddedTView(e,r);s&&(s.indexInDeclarationView=n,null!==t?t.push(s):t=[s])}return null!==t?new Ei(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class _i{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new _i(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const s=n[r];this.matchTNodeWithReadOption(e,t,Ai(t,s)),this.matchTNodeWithReadOption(e,t,Ln(t,e,s,!1,!1))}else n===ei?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Ln(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===Sa||r===oi||r===ei&&4&t.type)this.addMatch(t.index,-2);else{const n=Ln(t,e,r,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function Ai(e,t){const n=e.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1];return null}function Ri(e,t,n,r){return-1===n?function(e,t){return 11&e.type?Ia(e,t):4&e.type?ri(e,t):null}(t,e):-2===n?function(e,t,n){return n===Sa?Ia(t,e):n===ei?ri(t,e):n===oi?di(t,e):void 0}(e,t,r):zn(e,e[1],n,t)}function Fi(e,t,n,r){const s=t[19].queries[r];if(null===s.matches){const r=e.data,a=n.matches,i=[];for(let e=0;e<a.length;e+=2){const s=a[e];i.push(s<0?null:Ri(t,r[s],a[e+1],n.metadata.read))}s.matches=i}return s.matches}function Di(e,t,n,r){const s=e.queries.getByIndex(n),a=s.matches;if(null!==a){const i=Fi(e,t,s,n);for(let e=0;e<a.length;e+=2){const n=a[e];if(n>0)r.push(i[e/2]);else{const s=a[e+1],i=t[-n];for(let e=mt;e<i.length;e++){const t=i[e];t[17]===t[3]&&Di(t[1],t,s,r)}if(null!==i[9]){const e=i[9];for(let t=0;t<e.length;t++){const n=e[t];Di(n[1],n,s,r)}}}}}return r}function Oi(e){const t=Bt(),n=Vt(),r=Zt();Yt(r+1);const s=zi(n,r);if(e.dirty&&Ft(t)===(2==(2&s.metadata.flags))){if(null===s.matches)e.reset([]);else{const a=s.crossesNgTemplate?Di(n,t,r,[]):Fi(n,t,s,r);e.reset(a,Ca),e.notifyOnChanges()}return!0}return!1}function Mi(e,t,n){const r=Vt();r.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new Ei),e.queries.track(new _i(t,-1))}(r,new $i(e,t,n)),2==(2&t)&&(r.staticViewQueries=!0)),function(e,t,n){const r=new Si(4==(4&n));hs(e,t,r,r.destroy),null===t[19]&&(t[19]=new Ti),t[19].queries.push(new Ci(r))}(r,Bt(),t)}function Li(){return e=Bt(),t=Zt(),e[19].queries[t].queryList;var e,t}function zi(e,t){return e.queries.getByIndex(t)}const Pi=new Hn("Application Initializer");let Bi=(()=>{class e{constructor(e){this.appInits=e,this.resolve=ka,this.reject=ka,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(ia(t))e.push(t);else if(oa(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(sr(Pi,8))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const Vi=new Hn("AppId"),Wi={provide:Vi,useFactory:function(){return`${Ui()}${Ui()}${Ui()}`},deps:[]};function Ui(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Hi=new Hn("Platform Initializer"),Gi=new Hn("Platform ID"),ji=new Hn("appBootstrapListener");let qi=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const Ki=new Hn("LocaleId"),Xi=new Hn("DefaultCurrencyCode");class Zi{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const Yi=function(e){return new wi(e)},Ji=Yi,Qi=function(e){return Promise.resolve(Yi(e))},eo=function(e){const t=Yi(e),n=yr(ft(e).declarations).reduce((e,t)=>{const n=pt(t);return n&&e.push(new yi(n)),e},[]);return new Zi(t,n)},to=eo,no=function(e){return Promise.resolve(eo(e))};let ro=(()=>{class e{constructor(){this.compileModuleSync=Ji,this.compileModuleAsync=Qi,this.compileModuleAndAllComponentsSync=to,this.compileModuleAndAllComponentsAsync=no}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const so=(()=>Promise.resolve(0))();function ao(e){"undefined"==typeof Zone?so.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class io{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ii(!1),this.onMicrotaskEmpty=new Ii(!1),this.onStable=new Ii(!1),this.onError=new Ii(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&t,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let e=Xe.requestAnimationFrame,t=Xe.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Xe,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,uo(e),e.isCheckStableRunning=!0,lo(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),uo(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,s,a,i,o)=>{try{return co(e),n.invokeTask(s,a,i,o)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===a.type||e.shouldCoalesceRunChangeDetection)&&t(),ho(e)}},onInvoke:(n,r,s,a,i,o,l)=>{try{return co(e),n.invoke(s,a,i,o,l)}finally{e.shouldCoalesceRunChangeDetection&&t(),ho(e)}},onHasTask:(t,n,r,s)=>{t.hasTask(r,s),n===r&&("microTask"==s.change?(e._hasPendingMicrotasks=s.microTask,uo(e),lo(e)):"macroTask"==s.change&&(e.hasPendingMacrotasks=s.macroTask))},onHandleError:(t,n,r,s)=>(t.handleError(r,s),e.runOutsideAngular(()=>e.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!io.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(io.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,r){const s=this._inner,a=s.scheduleEventTask("NgZoneEvent: "+r,e,oo,ka,ka);try{return s.runTask(a,t,n)}finally{s.cancelTask(a)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const oo={};function lo(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function uo(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function co(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function ho(e){e._nesting--,lo(e)}class po{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ii,this.onMicrotaskEmpty=new Ii,this.onStable=new Ii,this.onError=new Ii}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,r){return e.apply(t,n)}}let fo=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{io.assertNotInAngularZone(),ao(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())ao(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let r=-1;t&&t>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==r),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:r,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(sr(io))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),mo=(()=>{class e{constructor(){this._applications=new Map,bo.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return bo.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();class go{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let yo,bo=new go,xo=!0,vo=!1;const wo=new Hn("AllowMultipleToken");class ko{constructor(e,t){this.name=e,this.token=t}}function Io(e,t,n=[]){const r=`Platform: ${t}`,s=new Hn(r);return(t=[])=>{let a=No();if(!a||a.injector.get(wo,!1))if(e)e(n.concat(t).concat({provide:s,useValue:!0}));else{const e=n.concat(t).concat({provide:s,useValue:!0},{provide:Ls,useValue:"platform"});!function(e){if(yo&&!yo.destroyed&&!yo.injector.get(wo,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");yo=e.get(So);const t=e.get(Hi,null);t&&t.forEach(e=>e())}(Xs.create({providers:e,name:r}))}return function(e){const t=No();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(s)}}function No(){return yo&&!yo.destroyed?yo:null}let So=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new po:("zone.js"===e?void 0:e)||new io({enableLongStackTrace:(vo=!0,xo),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),r=[{provide:io,useValue:n}];return n.run(()=>{const t=Xs.create({providers:r,parent:this.injector,name:e.moduleType.name}),s=e.create(t),a=s.injector.get(mr,null);if(!a)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{a.handleError(e)}});s.onDestroy(()=>{$o(this._modules,s),e.unsubscribe()})}),function(e,t,n){try{const r=n();return ia(r)?r.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):r}catch(r){throw t.runOutsideAngular(()=>e.handleError(r)),r}}(a,n,()=>{const e=s.injector.get(Bi);return e.runInitializers(),e.donePromise.then(()=>(ba(s.injector.get(Ki,ga)||ga),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,t=[]){const n=Co({},t);return function(e,t,n){const r=new wi(n);return Promise.resolve(r)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(To);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${we(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(sr(Xs))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();function Co(e,t){return Array.isArray(t)?t.reduce(Co,e):Object.assign(Object.assign({},e),t)}let To=(()=>{class e{constructor(e,t,n,r,s){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=r,this._initStatus=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const a=new V(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),i=new V(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{io.assertNotInAngularZone(),ao(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{io.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,r=e[e.length-1];return K(r)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof r&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof V?e[0]:he(t)(de(e,n))}(a,i.pipe(e=>{return pe()((t=xe,function(e){let n;n="function"==typeof t?t:function(){return t};const r=Object.create(e,ye);return r.source=e,r.subjectFactory=n,r})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof xa?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(si),s=n.create(Xs.NULL,[],t||n.selector,r),a=s.location.nativeElement,i=s.injector.get(fo,null),o=i&&s.injector.get(mo);return i&&o&&o.registerApplication(a,i),s.onDestroy(()=>{this.detachView(s.hostView),$o(this.components,s),o&&o.unregisterApplication(a)}),this._loadComponent(s),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;$o(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(ji,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(sr(io),sr(Xs),sr(mr),sr(wa),sr(Bi))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();function $o(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class Eo{}class _o{}const Ao={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let Ro=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||Ao}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,r]=e.split("#");return void 0===r&&(r="default"),n(255)(t).then(e=>e[r]).then(e=>Fo(e,t,r)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,r]=e.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[r+s]).then(e=>Fo(e,t,r))}}return e.\u0275fac=function(t){return new(t||e)(sr(ro),sr(_o,8))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();function Fo(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const Do=Io(null,"core",[{provide:Gi,useValue:"unknown"},{provide:So,deps:[Xs]},{provide:mo,deps:[]},{provide:qi,deps:[]}]),Oo=[{provide:To,useClass:To,deps:[io,Xs,mr,wa,Bi]},{provide:gi,deps:[io],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:Bi,useClass:Bi,deps:[[new lr,Pi]]},{provide:ro,useClass:ro,deps:[]},Wi,{provide:Wa,useFactory:function(){return Ya},deps:[]},{provide:Ha,useFactory:function(){return Ja},deps:[]},{provide:Ki,useFactory:function(e){return ba(e=e||"undefined"!=typeof $localize&&$localize.locale||ga),e},deps:[[new or(Ki),new lr,new ur]]},{provide:Xi,useValue:"USD"}];let Mo=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(sr(To))},e.\u0275mod=ct({type:e}),e.\u0275inj=_e({providers:Oo}),e})(),Lo=null;function zo(){return Lo}const Po=new Hn("DocumentToken");let Bo=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({factory:Vo,token:e,providedIn:"platform"}),e})();function Vo(){return sr(Uo)}const Wo=new Hn("Location Initialized");let Uo=(()=>{class e extends Bo{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return zo().getBaseHref(this._doc)}onPopState(e){const t=zo().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=zo().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Ho()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Ho()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(sr(Po))},e.\u0275prov=Ee({factory:Go,token:e,providedIn:"platform"}),e})();function Ho(){return!!window.history.pushState}function Go(){return new Uo(sr(Po))}function jo(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function qo(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Ko(e){return e&&"?"!==e[0]?"?"+e:e}let Xo=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({factory:Zo,token:e,providedIn:"root"}),e})();function Zo(e){const t=sr(Po).location;return new Jo(sr(Bo),t&&t.origin||"")}const Yo=new Hn("appBaseHref");let Jo=(()=>{class e extends Xo{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return jo(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Ko(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,r){const s=this.prepareExternalUrl(n+Ko(r));this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){const s=this.prepareExternalUrl(n+Ko(r));this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(sr(Bo),sr(Yo,8))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),Qo=(()=>{class e extends Xo{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=jo(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,r){let s=this.prepareExternalUrl(n+Ko(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){let s=this.prepareExternalUrl(n+Ko(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(sr(Bo),sr(Yo,8))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),el=(()=>{class e{constructor(e,t){this._subject=new Ii,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=qo(nl(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Ko(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,nl(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ko(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ko(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(sr(Xo),sr(Bo))},e.normalizeQueryParams=Ko,e.joinWithSlash=jo,e.stripTrailingSlash=qo,e.\u0275prov=Ee({factory:tl,token:e,providedIn:"root"}),e})();function tl(){return new el(sr(Xo),sr(Bo))}function nl(e){return e.replace(/\/index.html$/,"")}var rl=(()=>((rl=rl||{})[rl.Zero=0]="Zero",rl[rl.One=1]="One",rl[rl.Two=2]="Two",rl[rl.Few=3]="Few",rl[rl.Many=4]="Many",rl[rl.Other=5]="Other",rl))();class sl{}let al=(()=>{class e extends sl{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=fa(t);if(n)return n;const r=t.split("-")[0];if(n=fa(r),n)return n;if("en"===r)return da;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[ma.PluralCase]}(t||this.locale)(e)){case rl.Zero:return"zero";case rl.One:return"one";case rl.Two:return"two";case rl.Few:return"few";case rl.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(sr(Ki))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),il=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=ct({type:e}),e.\u0275inj=_e({providers:[{provide:sl,useClass:al}]}),e})();function ol(e){return"browser"===e}let ll=(()=>{class e{}return e.\u0275prov=Ee({token:e,providedIn:"root",factory:()=>new ul(sr(Po),window)}),e})();class ul{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let r=n.currentNode;for(;r;){const e=r.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}r=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,r=t.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=cl(this.window.history)||cl(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function cl(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class hl extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new hl,Lo||(Lo=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(pl=pl||document.querySelector("base"),pl?pl.getAttribute("href"):null);return null==t?null:function(e){dl=dl||document.createElement("a"),dl.setAttribute("href",e);const t=dl.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){pl=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[r,s]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}(document.cookie,e)}}let dl,pl=null;const fl=new Hn("TRANSITION_ID"),ml=[{provide:Pi,useFactory:function(e,t,n){return()=>{n.get(Bi).donePromise.then(()=>{const n=zo();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[fl,Po,Xs],multi:!0}];class gl{static init(){var e;e=new gl,bo=e}addToWindow(e){Xe.getAngularTestability=(t,n=!0)=>{const r=e.findTestabilityInTree(t,n);if(null==r)throw new Error("Could not find testability for element.");return r},Xe.getAllAngularTestabilities=()=>e.getAllTestabilities(),Xe.getAllAngularRootElements=()=>e.getAllRootElements(),Xe.frameworkStabilizers||(Xe.frameworkStabilizers=[]),Xe.frameworkStabilizers.push(e=>{const t=Xe.getAllAngularTestabilities();let n=t.length,r=!1;const s=function(t){r=r||t,n--,0==n&&e(r)};t.forEach(function(e){e.whenStable(s)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const r=e.getTestability(t);return null!=r?r:n?zo().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let yl=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const bl=new Hn("EventManagerPlugins");let xl=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let r=0;r<n.length;r++){const t=n[r];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(sr(bl),sr(io))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();class vl{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const r=zo().getGlobalEventTarget(this._doc,e);if(!r)throw new Error(`Unsupported event target ${r} for event ${t}`);return this.addEventListener(r,t,n)}}let wl=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),kl=(()=>{class e extends wl{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const r=this._doc.createElement("style");r.textContent=e,n.push(t.appendChild(r))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(Il),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(Il))}}return e.\u0275fac=function(t){return new(t||e)(sr(Po))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();function Il(e){zo().remove(e)}const Nl={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Sl=/%COMP%/g;function Cl(e,t,n){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?Cl(e,s,n):(s=s.replace(Sl,e),n.push(s))}return n}function Tl(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let $l=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new El(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case He.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new _l(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case He.ShadowDom:return new Al(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=Cl(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(sr(xl),sr(kl),sr(Vi))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();class El{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(Nl[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,r){if(r){t=r+":"+t;const s=Nl[r];s?e.setAttributeNS(s,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const r=Nl[n];r?e.removeAttributeNS(r,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,r){r&(br.DashCase|br.Important)?e.style.setProperty(t,n,r&br.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&br.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,Tl(n)):this.eventManager.addEventListener(e,t,Tl(n))}}class _l extends El{constructor(e,t,n,r){super(e),this.component=n;const s=Cl(r+"-"+n.id,n.styles,[]);t.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(Sl,r+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(Sl,r+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class Al extends El{constructor(e,t,n,r){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const s=Cl(r.id,r.styles,[]);for(let a=0;a<s.length;a++){const e=document.createElement("style");e.textContent=s[a],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let Rl=(()=>{class e extends vl{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(sr(Po))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const Fl=["alt","control","meta","shift"],Dl={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Ol={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Ml={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Ll=(()=>{class e extends vl{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,r){const s=e.parseEventName(n),a=e.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>zo().onAndCancel(t,s.domEventName,a))}static parseEventName(t){const n=t.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=e._normalizeKey(n.pop());let a="";if(Fl.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),a+=e+".")}),a+=s,0!=n.length||0===s.length)return null;const i={};return i.domEventName=r,i.fullKey=a,i}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&Ol.hasOwnProperty(t)&&(t=Ol[t]))}return Dl[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),Fl.forEach(r=>{r!=n&&(0,Ml[r])(e)&&(t+=r+".")}),t+=n,t}static eventCallback(t,n,r){return s=>{e.getEventFullKey(s)===t&&r.runGuarded(()=>n(s))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(sr(Po))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const zl=Io(Do,"browser",[{provide:Gi,useValue:"browser"},{provide:Hi,useValue:function(){hl.makeCurrent(),gl.init()},multi:!0},{provide:Po,useFactory:function(){return function(e){Tt=e}(document),document},deps:[]}]),Pl=[[],{provide:Ls,useValue:"root"},{provide:mr,useFactory:function(){return new mr},deps:[]},{provide:bl,useClass:Rl,multi:!0,deps:[Po,io,Gi]},{provide:bl,useClass:Ll,multi:!0,deps:[Po]},[],{provide:$l,useClass:$l,deps:[xl,kl,Vi]},{provide:Ta,useExisting:$l},{provide:wl,useExisting:kl},{provide:kl,useClass:kl,deps:[Po]},{provide:fo,useClass:fo,deps:[io]},{provide:xl,useClass:xl,deps:[bl,io]},{provide:class{},useClass:yl,deps:[]},[]];let Bl=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:Vi,useValue:t.appId},{provide:fl,useExisting:Vi},ml]}}}return e.\u0275fac=function(t){return new(t||e)(sr(e,12))},e.\u0275mod=ct({type:e}),e.\u0275inj=_e({providers:Pl,imports:[il,Mo]}),e})();function Vl(...e){let t=e[e.length-1];return K(t)?(e.pop(),re(e,t)):de(e)}"undefined"!=typeof window&&window;class Wl extends j{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new U;return this._value}next(e){super.next(this._value=e)}}class Ul extends L{notifyNext(e,t,n,r,s){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class Hl extends L{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function Gl(e,t,n,r,s=new Hl(e,n,r)){if(!s.closed)return t instanceof V?t.subscribe(s):ne(t)(s)}const jl={};class ql{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new Kl(e,this.resultSelector))}}class Kl extends Ul{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(jl),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add(Gl(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const r=this.values,s=this.toRespond?r[n]===jl?--this.toRespond:this.toRespond:0;r[n]=t,0===s&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Xl=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function Zl(...e){return he(1)(Vl(...e))}const Yl=new V(e=>e.complete());function Jl(e){return e?function(e){return new V(t=>e.schedule(()=>t.complete()))}(e):Yl}function Ql(e){return new V(t=>{let n;try{n=e()}catch(r){return void t.error(r)}return(n?se(n):Jl()).subscribe(t)})}function eu(e,t){return"function"==typeof t?n=>n.pipe(eu((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))))):t=>t.lift(new tu(e))}class tu{constructor(e){this.project=e}call(e,t){return t.subscribe(new nu(e,this.project))}}class nu extends ie{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new ae(this),r=this.destination;r.add(n),this.innerSubscription=oe(e,n),this.innerSubscription!==n&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const ru=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function su(e){return t=>0===e?Jl():t.lift(new au(e))}class au{constructor(e){if(this.total=e,this.total<0)throw new ru}call(e,t){return t.subscribe(new iu(e,this.total))}}class iu extends L{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function ou(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new lu(e,t,n))}}class lu{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new uu(e,this.accumulator,this.seed,this.hasSeed))}}class uu extends L{constructor(e,t,n,r){super(e),this.accumulator=t,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function cu(e,t){return function(n){return n.lift(new hu(e,t))}}class hu{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new du(e,this.predicate,this.thisArg))}}class du extends L{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function pu(e){return function(t){const n=new fu(e),r=t.lift(n);return n.caught=r}}class fu{constructor(e){this.selector=e}call(e,t){return t.subscribe(new mu(e,this.selector,this.caught))}}class mu extends ie{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const r=new ae(this);this.add(r);const s=oe(n,r);s!==r&&this.add(s)}}}function gu(e,t){return le(e,t,1)}function yu(e){return function(t){return 0===e?Jl():t.lift(new bu(e))}}class bu{constructor(e){if(this.total=e,this.total<0)throw new ru}call(e,t){return t.subscribe(new xu(e,this.total))}}class xu extends L{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,r=this.count++;t.length<n?t.push(e):t[r%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=t++%n;e.next(r[s])}}e.complete()}}function vu(e=Iu){return t=>t.lift(new wu(e))}class wu{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new ku(e,this.errorFactory))}}class ku extends L{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function Iu(){return new Xl}function Nu(e=null){return t=>t.lift(new Su(e))}class Su{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new Cu(e,this.defaultValue))}}class Cu extends L{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Tu(e,t){const n=arguments.length>=2;return r=>r.pipe(e?cu((t,n)=>e(t,n,r)):B,su(1),n?Nu(t):vu(()=>new Xl))}function $u(){}function Eu(e,t,n){return function(r){return r.lift(new _u(e,t,n))}}class _u{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new Au(e,this.nextOrObserver,this.error,this.complete))}}class Au extends L{constructor(e,t,n,r){super(e),this._tapNext=$u,this._tapError=$u,this._tapComplete=$u,this._tapError=n||$u,this._tapComplete=r||$u,C(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||$u,this._tapError=t.error||$u,this._tapComplete=t.complete||$u)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class Ru{constructor(e){this.callback=e}call(e,t){return t.subscribe(new Fu(e,this.callback))}}class Fu extends L{constructor(e,t){super(e),this.add(new D(t))}}class Du{constructor(e,t){this.id=e,this.url=t}}class Ou extends Du{constructor(e,t,n="imperative",r=null){super(e,t),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Mu extends Du{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Lu extends Du{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class zu extends Du{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Pu extends Du{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Bu extends Du{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Vu extends Du{constructor(e,t,n,r,s){super(e,t),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Wu extends Du{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Uu extends Du{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Hu{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Gu{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class ju{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class qu{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Ku{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Xu{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Zu{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Yu="primary";class Ju{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Qu(e){return new Ju(e)}function ec(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function tc(e,t,n){const r=n.path.split("/");if(r.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||r.length<e.length))return null;const s={};for(let a=0;a<r.length;a++){const t=r[a],n=e[a];if(t.startsWith(":"))s[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,r.length),posParams:s}}function nc(e,t){const n=e?Object.keys(e):void 0,r=t?Object.keys(t):void 0;if(!n||!r||n.length!=r.length)return!1;let s;for(let a=0;a<n.length;a++)if(s=n[a],!rc(e[s],t[s]))return!1;return!0}function rc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),r=[...t].sort();return n.every((e,t)=>r[t]===e)}return e===t}function sc(e){return Array.prototype.concat.apply([],e)}function ac(e){return e.length>0?e[e.length-1]:null}function ic(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function oc(e){return oa(e)?e:ia(e)?se(Promise.resolve(e)):Vl(e)}const lc={exact:function e(t,n,r){if(!yc(t.segments,n.segments))return!1;if(!pc(t.segments,n.segments,r))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const s in n.children){if(!t.children[s])return!1;if(!e(t.children[s],n.children[s],r))return!1}return!0},subset:hc},uc={exact:function(e,t){return nc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>rc(e[n],t[n]))},ignored:()=>!0};function cc(e,t,n){return lc[n.paths](e.root,t.root,n.matrixParams)&&uc[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function hc(e,t,n){return dc(e,t,t.segments,n)}function dc(e,t,n,r){if(e.segments.length>n.length){const s=e.segments.slice(0,n.length);return!!yc(s,n)&&!t.hasChildren()&&!!pc(s,n,r)}if(e.segments.length===n.length){if(!yc(e.segments,n))return!1;if(!pc(e.segments,n,r))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!hc(e.children[n],t.children[n],r))return!1}return!0}{const s=n.slice(0,e.segments.length),a=n.slice(e.segments.length);return!!yc(e.segments,s)&&!!pc(e.segments,s,r)&&!!e.children.primary&&dc(e.children.primary,t,a,r)}}function pc(e,t,n){return t.every((t,r)=>uc[n](e[r].parameters,t.parameters))}class fc{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Qu(this.queryParams)),this._queryParamMap}toString(){return vc.serialize(this)}}class mc{constructor(e,t){this.segments=e,this.children=t,this.parent=null,ic(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return wc(this)}}class gc{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=Qu(this.parameters)),this._parameterMap}toString(){return $c(this)}}function yc(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class bc{}class xc{parse(e){const t=new Fc(e);return new fc(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${kc(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${Nc(t)}=${Nc(e)}`).join("&"):`${Nc(t)}=${Nc(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const vc=new xc;function wc(e){return e.segments.map(e=>$c(e)).join("/")}function kc(e,t){if(!e.hasChildren())return wc(e);if(t){const t=e.children.primary?kc(e.children.primary,!1):"",n=[];return ic(e.children,(e,t)=>{t!==Yu&&n.push(`${t}:${kc(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return ic(e.children,(e,r)=>{r===Yu&&(n=n.concat(t(e,r)))}),ic(e.children,(e,r)=>{r!==Yu&&(n=n.concat(t(e,r)))}),n}(e,(t,n)=>n===Yu?[kc(e.children.primary,!1)]:[`${n}:${kc(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${wc(e)}/${t[0]}`:`${wc(e)}/(${t.join("//")})`}}function Ic(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Nc(e){return Ic(e).replace(/%3B/gi,";")}function Sc(e){return Ic(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Cc(e){return decodeURIComponent(e)}function Tc(e){return Cc(e.replace(/\+/g,"%20"))}function $c(e){return`${Sc(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${Sc(e)}=${Sc(t[e])}`).join("")}`;var t}const Ec=/^[^\/()?;=#]+/;function _c(e){const t=e.match(Ec);return t?t[0]:""}const Ac=/^[^=?&#]+/,Rc=/^[^?&#]+/;class Fc{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new mc([],{}):new mc([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new mc(e,t)),n}parseSegment(){const e=_c(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new gc(Cc(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=_c(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=_c(this.remaining);e&&(n=e,this.capture(n))}e[Cc(t)]=Cc(n)}parseQueryParam(e){const t=function(e){const t=e.match(Ac);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(Rc);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const r=Tc(t),s=Tc(n);if(e.hasOwnProperty(r)){let t=e[r];Array.isArray(t)||(t=[t],e[r]=t),t.push(s)}else e[r]=s}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=_c(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):e&&(s=Yu);const a=this.parseChildren();t[s]=1===Object.keys(a).length?a.primary:new mc([],a),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class Dc{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=Oc(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=Oc(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Mc(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Mc(e,this._root).map(e=>e.value)}}function Oc(e,t){if(e===t.value)return t;for(const n of t.children){const t=Oc(e,n);if(t)return t}return null}function Mc(e,t){if(e===t.value)return[t];for(const n of t.children){const r=Mc(e,n);if(r.length)return r.unshift(t),r}return[]}class Lc{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function zc(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Pc extends Dc{constructor(e,t){super(e),this.snapshot=t,Gc(this,e)}toString(){return this.snapshot.toString()}}function Bc(e,t){const n=function(e,t){const n=new Uc([],{},{},"",{},Yu,t,null,e.root,-1,{});return new Hc("",new Lc(n,[]))}(e,t),r=new Wl([new gc("",{})]),s=new Wl({}),a=new Wl({}),i=new Wl({}),o=new Wl(""),l=new Vc(r,s,i,o,a,Yu,t,n.root);return l.snapshot=n.root,new Pc(new Lc(l,[]),n)}class Vc{constructor(e,t,n,r,s,a,i,o){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=a,this.component=i,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(X(e=>Qu(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(X(e=>Qu(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Wc(e,t="emptyOnly"){const n=e.pathFromRoot;let r=0;if("always"!==t)for(r=n.length-1;r>=1;){const e=n[r],t=n[r-1];if(e.routeConfig&&""===e.routeConfig.path)r--;else{if(t.component)break;r--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class Uc{constructor(e,t,n,r,s,a,i,o,l,u,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=a,this.component=i,this.routeConfig=o,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Qu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Qu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Hc extends Dc{constructor(e,t){super(t),this.url=e,Gc(this,t)}toString(){return jc(this._root)}}function Gc(e,t){t.value._routerState=e,t.children.forEach(t=>Gc(e,t))}function jc(e){const t=e.children.length>0?` { ${e.children.map(jc).join(", ")} } `:"";return`${e.value}${t}`}function qc(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,nc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),nc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!nc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),nc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function Kc(e,t){var n,r;return nc(e.params,t.params)&&yc(n=e.url,r=t.url)&&n.every((e,t)=>nc(e.parameters,r[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||Kc(e.parent,t.parent))}function Xc(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const r=n.value;r._futureSnapshot=t.value;const s=function(e,t,n){return t.children.map(t=>{for(const r of n.children)if(e.shouldReuseRoute(t.value,r.value.snapshot))return Xc(e,t,r);return Xc(e,t)})}(e,t,n);return new Lc(r,s)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return Zc(t,e),e}}const n=new Vc(new Wl((r=t.value).url),new Wl(r.params),new Wl(r.queryParams),new Wl(r.fragment),new Wl(r.data),r.outlet,r.component,r),s=t.children.map(t=>Xc(e,t));return new Lc(n,s)}var r}function Zc(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)Zc(e.children[n],t.children[n])}function Yc(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function Jc(e){return"object"==typeof e&&null!=e&&e.outlets}function Qc(e,t,n,r,s){let a={};return r&&ic(r,(e,t)=>{a[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new fc(n.root===e?t:eh(n.root,e,t),a,s)}function eh(e,t,n){const r={};return ic(e.children,(e,s)=>{r[s]=e===t?n:eh(e,t,n)}),new mc(e.segments,r)}class th{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&Yc(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(Jc);if(r&&r!==ac(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class nh{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function rh(e,t,n){if(e||(e=new mc([],{})),0===e.segments.length&&e.hasChildren())return sh(e,t,n);const r=function(e,t,n){let r=0,s=t;const a={match:!1,pathIndex:0,commandIndex:0};for(;s<e.segments.length;){if(r>=n.length)return a;const t=e.segments[s],i=n[r];if(Jc(i))break;const o=`${i}`,l=r<n.length-1?n[r+1]:null;if(s>0&&void 0===o)break;if(o&&l&&"object"==typeof l&&void 0===l.outlets){if(!lh(o,l,t))return a;r+=2}else{if(!lh(o,{},t))return a;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(e,t,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const t=new mc(e.segments.slice(0,r.pathIndex),{});return t.children.primary=new mc(e.segments.slice(r.pathIndex),e.children),sh(t,0,s)}return r.match&&0===s.length?new mc(e.segments,{}):r.match&&!e.hasChildren()?ah(e,t,n):r.match?sh(e,0,s):ah(e,t,n)}function sh(e,t,n){if(0===n.length)return new mc(e.segments,{});{const r=function(e){return Jc(e[0])?e[0].outlets:{[Yu]:e}}(n),s={};return ic(r,(n,r)=>{"string"==typeof n&&(n=[n]),null!==n&&(s[r]=rh(e.children[r],t,n))}),ic(e.children,(e,t)=>{void 0===r[t]&&(s[t]=e)}),new mc(e.segments,s)}}function ah(e,t,n){const r=e.segments.slice(0,t);let s=0;for(;s<n.length;){const a=n[s];if(Jc(a)){const e=ih(a.outlets);return new mc(r,e)}if(0===s&&Yc(n[0])){r.push(new gc(e.segments[t].path,oh(n[0]))),s++;continue}const i=Jc(a)?a.outlets.primary:`${a}`,o=s<n.length-1?n[s+1]:null;i&&o&&Yc(o)?(r.push(new gc(i,oh(o))),s+=2):(r.push(new gc(i,{})),s++)}return new mc(r,{})}function ih(e){const t={};return ic(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=ah(new mc([],{}),0,e))}),t}function oh(e){const t={};return ic(e,(e,n)=>t[n]=`${e}`),t}function lh(e,t,n){return e==n.path&&nc(t,n.parameters)}class uh{constructor(e,t,n,r){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=r}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),qc(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const r=zc(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,r[t],n),delete r[t]}),ic(r,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(e,t,s.children)}else this.deactivateChildRoutes(e,t,n);else s&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:r})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),r=n&&e.value.component?n.children:t,s=zc(e);for(const a of Object.keys(s))this.deactivateRouteAndItsChildren(s[a],r);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const r=zc(t);e.children.forEach(e=>{this.activateRoutes(e,r[e.value.outlet],n),this.forwardEvent(new Xu(e.value.snapshot))}),e.children.length&&this.forwardEvent(new qu(e.value.snapshot))}activateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(qc(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(e,t,s.children)}else this.activateChildRoutes(e,t,n);else if(r.component){const t=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const e=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),ch(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=r,t.resolver=s,t.outlet&&t.outlet.activateWith(r,s),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function ch(e){qc(e.value),e.children.forEach(ch)}class hh{constructor(e,t){this.routes=e,this.module=t}}function dh(e){return"function"==typeof e}function ph(e){return e instanceof fc}const fh=Symbol("INITIAL_VALUE");function mh(){return eu(e=>function(...e){let t,n;return K(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&A(e[0])&&(e=e[0]),de(e,n).lift(new ql(t))}(e.map(e=>e.pipe(su(1),function(...e){const t=e[e.length-1];return K(t)?(e.pop(),n=>Zl(e,n,t)):t=>Zl(e,t)}(fh)))).pipe(ou((e,t)=>{let n=!1;return t.reduce((e,r,s)=>{if(e!==fh)return e;if(r===fh&&(n=!0),!n){if(!1===r)return r;if(s===t.length-1||ph(r))return r}return e},e)},fh),cu(e=>e!==fh),X(e=>ph(e)?e:!0===e),su(1)))}let gh=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=it({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&aa(0,"router-outlet")},directives:function(){return[cd]},encapsulation:2}),e})();function yh(e,t=""){for(let n=0;n<e.length;n++){const r=e[n];bh(r,xh(t,r))}}function bh(e,t){e.children&&yh(e.children,t)}function xh(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function vh(e){const t=e.children&&e.children.map(vh),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==Yu&&(n.component=gh),n}function wh(e){return e.outlet||Yu}function kh(e,t){const n=e.filter(e=>wh(e)===t);return n.push(...e.filter(e=>wh(e)!==t)),n}const Ih={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Nh(e,t,n){var r;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},Ih):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const s=(t.matcher||tc)(n,e,t);if(!s)return Object.assign({},Ih);const a={};ic(s.posParams,(e,t)=>{a[t]=e.path});const i=s.consumed.length>0?Object.assign(Object.assign({},a),s.consumed[s.consumed.length-1].parameters):a;return{matched:!0,consumedSegments:s.consumed,lastChild:s.consumed.length,parameters:i,positionalParamSegments:null!==(r=s.posParams)&&void 0!==r?r:{}}}function Sh(e,t,n,r,s="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>Ch(e,t,n)&&wh(n)!==Yu)}(e,n,r)){const s=new mc(t,function(e,t,n,r){const s={};s.primary=r,r._sourceSegment=e,r._segmentIndexShift=t.length;for(const a of n)if(""===a.path&&wh(a)!==Yu){const n=new mc([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,s[wh(a)]=n}return s}(e,t,r,new mc(n,e.children)));return s._sourceSegment=e,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>Ch(e,t,n))}(e,n,r)){const a=new mc(e.segments,function(e,t,n,r,s,a){const i={};for(const o of r)if(Ch(e,n,o)&&!s[wh(o)]){const n=new mc([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===a?e.segments.length:t.length,i[wh(o)]=n}return Object.assign(Object.assign({},s),i)}(e,t,n,r,e.children,s));return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}const a=new mc(e.segments,e.children);return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}function Ch(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function Th(e,t,n,r){return!!(wh(e)===r||r!==Yu&&Ch(t,n,e))&&("**"===e.path||Nh(t,e,n).matched)}function $h(e,t,n){return 0===t.length&&!e.children[n]}class Eh{constructor(e){this.segmentGroup=e||null}}class _h{constructor(e){this.urlTree=e}}function Ah(e){return new V(t=>t.error(new Eh(e)))}function Rh(e){return new V(t=>t.error(new _h(e)))}function Fh(e){return new V(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class Dh{constructor(e,t,n,r,s){this.configLoader=t,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=e.get(si)}apply(){const e=Sh(this.urlTree.root,[],[],this.config).segmentGroup,t=new mc(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,Yu).pipe(X(e=>this.createUrlTree(Oh(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(pu(e=>{if(e instanceof _h)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof Eh)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,Yu).pipe(X(t=>this.createUrlTree(Oh(t),e.queryParams,e.fragment))).pipe(pu(e=>{if(e instanceof Eh)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const r=e.segments.length>0?new mc([],{[Yu]:e}):e;return new fc(r,t,n)}expandSegmentGroup(e,t,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(X(e=>new mc([],e))):this.expandSegment(e,n,t,n.segments,r,!0)}expandChildren(e,t,n){const r=[];for(const s of Object.keys(n.children))"primary"===s?r.unshift(s):r.push(s);return se(r).pipe(gu(r=>{const s=n.children[r],a=kh(t,r);return this.expandSegmentGroup(e,a,s,r).pipe(X(e=>({segment:e,outlet:r})))}),ou((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return r=>r.pipe(e?cu((t,n)=>e(t,n,r)):B,yu(1),n?Nu(t):vu(()=>new Xl))}())}expandSegment(e,t,n,r,s,a){return se(n).pipe(gu(i=>this.expandSegmentAgainstRoute(e,t,n,i,r,s,a).pipe(pu(e=>{if(e instanceof Eh)return Vl(null);throw e}))),Tu(e=>!!e),pu((e,n)=>{if(e instanceof Xl||"EmptyError"===e.name){if($h(t,r,s))return Vl(new mc([],{}));throw new Eh(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,r,s,a,i){return Th(r,t,s,a)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(e,t,r,s,a):i&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,a):Ah(t):Ah(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,a){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,r,a):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,a)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Rh(s):this.lineralizeSegments(n,s).pipe(le(n=>{const s=new mc(n,{});return this.expandSegment(e,s,t,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,a){const{matched:i,consumedSegments:o,lastChild:l,positionalParamSegments:u}=Nh(t,r,s);if(!i)return Ah(t);const c=this.applyRedirectCommands(o,r.redirectTo,u);return r.redirectTo.startsWith("/")?Rh(c):this.lineralizeSegments(r,c).pipe(le(r=>this.expandSegment(e,t,n,r.concat(s.slice(l)),a,!1)))}matchSegmentAgainstRoute(e,t,n,r,s){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Vl(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(X(e=>(n._loadedConfig=e,new mc(r,{})))):Vl(new mc(r,{}));const{matched:a,consumedSegments:i,lastChild:o}=Nh(t,n,r);if(!a)return Ah(t);const l=r.slice(o);return this.getChildConfig(e,n,r).pipe(le(e=>{const r=e.module,a=e.routes,{segmentGroup:o,slicedSegments:u}=Sh(t,i,l,a),c=new mc(o.segments,o.children);if(0===u.length&&c.hasChildren())return this.expandChildren(r,a,c).pipe(X(e=>new mc(i,e)));if(0===a.length&&0===u.length)return Vl(new mc(i,{}));const h=wh(n)===s;return this.expandSegment(r,c,a,u,h?Yu:s,!0).pipe(X(e=>new mc(i.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?Vl(new hh(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?Vl(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(le(n=>n?this.configLoader.load(e.injector,t).pipe(X(e=>(t._loadedConfig=e,e))):function(e){return new V(t=>t.error(ec(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):Vl(new hh([],e))}runCanLoadGuards(e,t,n){const r=t.canLoad;return r&&0!==r.length?Vl(r.map(r=>{const s=e.get(r);let a;if(function(e){return e&&dh(e.canLoad)}(s))a=s.canLoad(t,n);else{if(!dh(s))throw new Error("Invalid CanLoad guard");a=s(t,n)}return oc(a)})).pipe(mh(),Eu(e=>{if(!ph(e))return;const t=ec(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),X(e=>!0===e)):Vl(!0)}lineralizeSegments(e,t){let n=[],r=t.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return Vl(n);if(r.numberOfChildren>1||!r.children.primary)return Fh(e.redirectTo);r=r.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,r){const s=this.createSegmentGroup(e,t.root,n,r);return new fc(s,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return ic(e,(e,r)=>{if("string"==typeof e&&e.startsWith(":")){const s=e.substring(1);n[r]=t[s]}else n[r]=e}),n}createSegmentGroup(e,t,n,r){const s=this.createSegments(e,t.segments,n,r);let a={};return ic(t.children,(t,s)=>{a[s]=this.createSegmentGroup(e,t,n,r)}),new mc(s,a)}createSegments(e,t,n,r){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,r):this.findOrReturn(t,n))}findPosParam(e,t,n){const r=n[t.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return r}findOrReturn(e,t){let n=0;for(const r of t){if(r.path===e.path)return t.splice(n),r;n++}return e}}function Oh(e){const t={};for(const n of Object.keys(e.children)){const r=Oh(e.children[n]);(r.segments.length>0||r.hasChildren())&&(t[n]=r)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new mc(e.segments.concat(t.segments),t.children)}return e}(new mc(e.segments,t))}class Mh{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Lh{constructor(e,t){this.component=e,this.route=t}}function zh(e,t,n){const r=e._root;return Bh(r,t?t._root:null,n,[r.value])}function Ph(e,t,n){const r=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:n).get(e)}function Bh(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const a=zc(t);return e.children.forEach(e=>{!function(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const a=e.value,i=t?t.value:null,o=n?n.getContext(e.value.outlet):null;if(i&&a.routeConfig===i.routeConfig){const l=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!yc(e.url,t.url);case"pathParamsOrQueryParamsChange":return!yc(e.url,t.url)||!nc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Kc(e,t)||!nc(e.queryParams,t.queryParams);case"paramsChange":default:return!Kc(e,t)}}(i,a,a.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new Mh(r)):(a.data=i.data,a._resolvedData=i._resolvedData),Bh(e,t,a.component?o?o.children:null:n,r,s),l&&o&&o.outlet&&o.outlet.isActivated&&s.canDeactivateChecks.push(new Lh(o.outlet.component,i))}else i&&Vh(t,o,s),s.canActivateChecks.push(new Mh(r)),Bh(e,null,a.component?o?o.children:null:n,r,s)}(e,a[e.value.outlet],n,r.concat([e.value]),s),delete a[e.value.outlet]}),ic(a,(e,t)=>Vh(e,n.getContext(t),s)),s}function Vh(e,t,n){const r=zc(e),s=e.value;ic(r,(e,r)=>{Vh(e,s.component?t?t.children.getContext(r):null:t,n)}),n.canDeactivateChecks.push(new Lh(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class Wh{}function Uh(e){return new V(t=>t.error(e))}class Hh{constructor(e,t,n,r,s,a){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=a}recognize(){const e=Sh(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,Yu);if(null===t)return null;const n=new Uc([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Yu,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new Lc(n,t),s=new Hc(this.url,r);return this.inheritParamsAndData(s._root),s}inheritParamsAndData(e){const t=e.value,n=Wc(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const s of Object.keys(t.children)){const r=t.children[s],a=kh(e,s),i=this.processSegmentGroup(a,r,s);if(null===i)return null;n.push(...i)}const r=jh(n);return r.sort((e,t)=>e.value.outlet===Yu?-1:t.value.outlet===Yu?1:e.value.outlet.localeCompare(t.value.outlet)),r}processSegment(e,t,n,r){for(const s of e){const e=this.processSegmentAgainstRoute(s,t,n,r);if(null!==e)return e}return $h(t,n,r)?[]:null}processSegmentAgainstRoute(e,t,n,r){if(e.redirectTo||!Th(e,t,n,r))return null;let s,a=[],i=[];if("**"===e.path){const r=n.length>0?ac(n).parameters:{};s=new Uc(n,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Xh(e),wh(e),e.component,e,qh(t),Kh(t)+n.length,Zh(e))}else{const r=Nh(t,e,n);if(!r.matched)return null;a=r.consumedSegments,i=n.slice(r.lastChild),s=new Uc(a,r.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Xh(e),wh(e),e.component,e,qh(t),Kh(t)+a.length,Zh(e))}const o=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:l,slicedSegments:u}=Sh(t,a,i,o.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const e=this.processChildren(o,l);return null===e?null:[new Lc(s,e)]}if(0===o.length&&0===u.length)return[new Lc(s,[])];const c=wh(e)===r,h=this.processSegment(o,l,u,c?Yu:r);return null===h?null:[new Lc(s,h)]}}function Gh(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function jh(e){const t=[],n=new Set;for(const r of e){if(!Gh(r)){t.push(r);continue}const e=t.find(e=>r.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...r.children),n.add(e)):t.push(r)}for(const r of n){const e=jh(r.children);t.push(new Lc(r.value,e))}return t.filter(e=>!n.has(e))}function qh(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Kh(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function Xh(e){return e.data||{}}function Zh(e){return e.resolve||{}}function Yh(e){return eu(t=>{const n=e(t);return n?se(n).pipe(X(()=>t)):Vl(t)})}class Jh extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const Qh=new Hn("ROUTES");class ed{constructor(e,t,n,r){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=r}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(X(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const r=n.create(e);return new hh(sc(r.injector.get(Qh,void 0,ze.Self|ze.Optional)).map(vh),r)}),pu(e=>{throw t._loader$=void 0,e}));return t._loader$=new ge(n,()=>new j).pipe(pe()),t._loader$}loadModuleFactory(e){return"string"==typeof e?se(this.loader.load(e)):oc(e()).pipe(le(e=>e instanceof ai?Vl(e):se(this.compiler.compileModuleAsync(e))))}}class td{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new nd,this.attachRef=null}}class nd{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new td,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class rd{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function sd(e){throw e}function ad(e,t,n){return t.parse("/")}function id(e,t){return Vl(null)}const od={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},ld={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let ud=(()=>{class e{constructor(e,t,n,r,s,a,i,o){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=r,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new j,this.errorHandler=sd,this.malformedUriErrorHandler=ad,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:id,afterPreactivation:id},this.urlHandlingStrategy=new rd,this.routeReuseStrategy=new Jh,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=s.get(si),this.console=s.get(qi);const l=s.get(io);this.isNgZoneEnabled=l instanceof io&&io.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new fc(new mc([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new ed(a,i,e=>this.triggerEvent(new Hu(e)),e=>this.triggerEvent(new Gu(e))),this.routerState=Bc(this.currentUrlTree,this.rootComponentType),this.transitions=new Wl({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(cu(e=>0!==e.id),X(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),eu(e=>{let n=!1,r=!1;return Vl(e).pipe(Eu(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),eu(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return Vl(e).pipe(eu(e=>{const n=this.transitions.getValue();return t.next(new Ou(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?Yl:Promise.resolve(e)}),function(e,t,n,r){return eu(s=>function(e,t,n,r,s){return new Dh(e,t,n,r,s).apply()}(e,t,n,s.extractedUrl,r).pipe(X(e=>Object.assign(Object.assign({},s),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Eu(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,r,s){return le(a=>function(e,t,n,r,s="emptyOnly",a="legacy"){try{const i=new Hh(e,t,n,r,s,a).recognize();return null===i?Uh(new Wh):Vl(i)}catch(i){return Uh(i)}}(e,t,a.urlAfterRedirects,n(a.urlAfterRedirects),r,s).pipe(X(e=>Object.assign(Object.assign({},a),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),Eu(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new Pu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:a,extras:i}=e,o=new Ou(n,this.serializeUrl(r),s,a);t.next(o);const l=Bc(r,this.rootComponentType).snapshot;return Vl(Object.assign(Object.assign({},e),{targetSnapshot:l,urlAfterRedirects:r,extras:Object.assign(Object.assign({},i),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),Yl}),Yh(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:a,replaceUrl:i}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!a,replaceUrl:!!i})}),Eu(e=>{const t=new Bu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),X(e=>Object.assign(Object.assign({},e),{guards:zh(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return le(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:a,canDeactivateChecks:i}}=n;return 0===i.length&&0===a.length?Vl(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,r){return se(e).pipe(le(e=>function(e,t,n,r,s){const a=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return a&&0!==a.length?Vl(a.map(a=>{const i=Ph(a,t,s);let o;if(function(e){return e&&dh(e.canDeactivate)}(i))o=oc(i.canDeactivate(e,t,n,r));else{if(!dh(i))throw new Error("Invalid CanDeactivate guard");o=oc(i(e,t,n,r))}return o.pipe(Tu())})).pipe(mh()):Vl(!0)}(e.component,e.route,n,t,r)),Tu(e=>!0!==e,!0))}(i,r,s,e).pipe(le(n=>n&&"boolean"==typeof n?function(e,t,n,r){return se(t).pipe(gu(t=>Zl(function(e,t){return null!==e&&t&&t(new ju(e)),Vl(!0)}(t.route.parent,r),function(e,t){return null!==e&&t&&t(new Ku(e)),Vl(!0)}(t.route,r),function(e,t,n){const r=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>Ql(()=>Vl(t.guards.map(s=>{const a=Ph(s,t.node,n);let i;if(function(e){return e&&dh(e.canActivateChild)}(a))i=oc(a.canActivateChild(r,e));else{if(!dh(a))throw new Error("Invalid CanActivateChild guard");i=oc(a(r,e))}return i.pipe(Tu())})).pipe(mh())));return Vl(s).pipe(mh())}(e,t.path,n),function(e,t,n){const r=t.routeConfig?t.routeConfig.canActivate:null;return r&&0!==r.length?Vl(r.map(r=>Ql(()=>{const s=Ph(r,t,n);let a;if(function(e){return e&&dh(e.canActivate)}(s))a=oc(s.canActivate(t,e));else{if(!dh(s))throw new Error("Invalid CanActivate guard");a=oc(s(t,e))}return a.pipe(Tu())}))).pipe(mh()):Vl(!0)}(e,t.route,n))),Tu(e=>!0!==e,!0))}(r,a,e,t):Vl(n)),X(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),Eu(e=>{if(ph(e.guardsResult)){const t=ec(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new Vu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),cu(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),Yh(e=>{if(e.guards.canActivateChecks.length)return Vl(e).pipe(Eu(e=>{const t=new Wu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),eu(e=>{let t=!1;return Vl(e).pipe((n=this.paramsInheritanceStrategy,r=this.ngModule.injector,le(e=>{const{targetSnapshot:t,guards:{canActivateChecks:s}}=e;if(!s.length)return Vl(e);let a=0;return se(s).pipe(gu(e=>function(e,t,n,r){return function(e,t,n,r){const s=Object.keys(e);if(0===s.length)return Vl({});const a={};return se(s).pipe(le(s=>function(e,t,n,r){const s=Ph(e,t,r);return oc(s.resolve?s.resolve(t,n):s(t,n))}(e[s],t,n,r).pipe(Eu(e=>{a[s]=e}))),yu(1),le(()=>Object.keys(a).length===s.length?Vl(a):Yl))}(e._resolve,e,t,r).pipe(X(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),Wc(e,n).resolve),null)))}(e.route,t,n,r)),Eu(()=>a++),yu(1),le(t=>a===s.length?Vl(e):Yl))})),Eu({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,r}),Eu(e=>{const t=new Uu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),Yh(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:a,replaceUrl:i}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!a,replaceUrl:!!i})}),X(e=>{const t=function(e,t,n){const r=Xc(e,t._root,n?n._root:void 0);return new Pc(r,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),Eu(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(a=this.rootContexts,i=this.routeReuseStrategy,o=e=>this.triggerEvent(e),X(e=>(new uh(i,e.targetRouterState,e.currentRouterState,o).activate(a),e))),Eu({next(){n=!0},complete(){n=!0}}),(s=()=>{n||r||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new Ru(s))),pu(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=ph(n.url);r||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const s=new Lu(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(s),r?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const r=new zu(e.id,this.serializeUrl(e.extractedUrl),n);t.next(r);try{e.resolve(this.errorHandler(n))}catch(a){e.reject(a)}}var s;return Yl}));var s,a,i,o}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:r}=t,s={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(s.state=e)}this.scheduleNavigation(r,e,n,s)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){yh(e),this.config=e.map(vh),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:r,fragment:s,queryParamsHandling:a,preserveFragment:i}=t,o=n||this.routerState.root,l=i?this.currentUrlTree.fragment:s;let u=null;switch(a){case"merge":u=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=r||null}return null!==u&&(u=this.removeEmptyProps(u)),function(e,t,n,r,s){if(0===n.length)return Qc(t.root,t.root,t,r,s);const a=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new th(!0,0,e);let t=0,n=!1;const r=e.reduce((e,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const t={};return ic(r.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(r.segmentPath)return[...e,r.segmentPath]}return"string"!=typeof r?[...e,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?t++:""!=r&&e.push(r))}),e):[...e,r]},[]);return new th(n,t,r)}(n);if(a.toRoot())return Qc(t.root,new mc([],{}),t,r,s);const i=function(e,t,n){if(e.isAbsolute)return new nh(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new nh(e,e===t.root,0)}const r=Yc(e.commands[0])?0:1;return function(e,t,n){let r=e,s=t,a=n;for(;a>s;){if(a-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new nh(r,!1,s-a)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,e.numberOfDoubleDots)}(a,t,e),o=i.processChildren?sh(i.segmentGroup,i.index,a.commands):rh(i.segmentGroup,i.index,a.commands);return Qc(i.segmentGroup,o,t,r,s)}(o,this.currentUrlTree,e,u,null!=l?l:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=ph(e)?e:this.parseUrl(e),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let s=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(s=this.location.getState()),this.scheduleNavigation(r,"imperative",s,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},od):!1===t?Object.assign({},ld):t,ph(e))return cc(this.currentUrlTree,e,n);const r=this.parseUrl(e);return cc(this.currentUrlTree,r,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const r=e[n];return null!=r&&(t[n]=r),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Mu(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,r,s){if(this.disposed)return Promise.resolve(!1);const a=this.getTransition(),i="imperative"!==t&&"imperative"===(null==a?void 0:a.source),o=(this.lastSuccessfulId===a.id||this.currentNavigation?a.rawUrl:a.urlAfterRedirects).toString()===e.toString();if(i&&o)return Promise.resolve(!0);let l,u,c;s?(l=s.resolve,u=s.reject,c=s.promise):c=new Promise((e,t)=>{l=e,u=t});const h=++this.navigationId;let d;return d="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:h,targetPageId:d,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:r,resolve:l,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),r=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",r):this.location.go(n,"",r)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Lu(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(sr(jn),sr(bc),sr(nd),sr(el),sr(Xs),sr(Eo),sr(ro),sr(void 0))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),cd=(()=>{class e{constructor(e,t,n,r,s){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new Ii,this.deactivateEvents=new Ii,this.name=r||Yu,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new hd(e,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(ta(nd),ta(oi),ta(wa),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let r=0;for(;r<e;){const s=n[r];if(yn(s))break;if(0===s)r+=2;else if("number"==typeof s)for(r++;r<e&&"string"==typeof n[r];)r++;else{if(s===t)return n[r+1];r+=2}}}return null}(Wt(),"name")),ta(Xa))},e.\u0275dir=dt({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class hd{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===Vc?this.route:e===nd?this.childContexts:this.parent.get(e,t)}}class dd{}class pd{preload(e,t){return Vl(null)}}let fd=(()=>{class e{constructor(e,t,n,r,s){this.router=e,this.injector=r,this.preloadingStrategy=s,this.loader=new ed(t,n,t=>e.triggerEvent(new Hu(t)),t=>e.triggerEvent(new Gu(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(cu(e=>e instanceof Mu),gu(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(si);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const r of t)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const e=r._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(e,r)):r.children&&n.push(this.processRoutes(e,r.children));return se(n).pipe(he(),X(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?Vl(t._loadedConfig):this.loader.load(e.injector,t)).pipe(le(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(sr(ud),sr(Eo),sr(ro),sr(Xs),sr(dd))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})(),md=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Ou?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Mu&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Zu&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new Zu(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(sr(ud),sr(ll),sr(void 0))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();const gd=new Hn("ROUTER_CONFIGURATION"),yd=new Hn("ROUTER_FORROOT_GUARD"),bd=[el,{provide:bc,useClass:xc},{provide:ud,useFactory:function(e,t,n,r,s,a,i,o={},l,u){const c=new ud(null,e,t,n,r,s,a,sc(i));return l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(o,c),o.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[bc,nd,el,Xs,Eo,ro,Qh,gd,[class{},new lr],[class{},new lr]]},nd,{provide:Vc,useFactory:function(e){return e.routerState.root},deps:[ud]},{provide:Eo,useClass:Ro},fd,pd,class{preload(e,t){return t().pipe(pu(()=>Vl(null)))}},{provide:gd,useValue:{enableTracing:!1}}];function xd(){return new ko("Router",ud)}let vd=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[bd,Nd(t),{provide:yd,useFactory:Id,deps:[[ud,new lr,new ur]]},{provide:gd,useValue:n||{}},{provide:Xo,useFactory:kd,deps:[Bo,[new or(Yo),new lr],gd]},{provide:md,useFactory:wd,deps:[ud,ll,gd]},{provide:dd,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:pd},{provide:ko,multi:!0,useFactory:xd},[Sd,{provide:Pi,multi:!0,useFactory:Cd,deps:[Sd]},{provide:$d,useFactory:Td,deps:[Sd]},{provide:ji,multi:!0,useExisting:$d}]]}}static forChild(t){return{ngModule:e,providers:[Nd(t)]}}}return e.\u0275fac=function(t){return new(t||e)(sr(yd,8),sr(ud,8))},e.\u0275mod=ct({type:e}),e.\u0275inj=_e({}),e})();function wd(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new md(e,t,n)}function kd(e,t,n={}){return n.useHash?new Qo(e,t):new Jo(e,t)}function Id(e){return"guarded"}function Nd(e){return[{provide:Gn,multi:!0,useValue:e},{provide:Qh,multi:!0,useValue:e}]}let Sd=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new j}appInitializer(){return this.injector.get(Wo,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let e=null;const t=new Promise(t=>e=t),n=this.injector.get(ud),r=this.injector.get(gd);return"disabled"===r.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===r.initialNavigation||"enabledBlocking"===r.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Vl(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(gd),n=this.injector.get(fd),r=this.injector.get(md),s=this.injector.get(ud),a=this.injector.get(To);e===a.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||s.initialNavigation(),n.setUpPreloading(),r.init(),s.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return e.\u0275fac=function(t){return new(t||e)(sr(Xs))},e.\u0275prov=Ee({token:e,factory:e.\u0275fac}),e})();function Cd(e){return e.appInitializer.bind(e)}function Td(e){return e.bootstrapListener.bind(e)}const $d=new Hn("Router Initializer");function Ed(e,t,n,r,s,a,i){try{var o=e[a](i),l=o.value}catch(u){return void n(u)}o.done?t(l):Promise.resolve(l).then(r,s)}function _d(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var a=e.apply(t,n);function i(e){Ed(a,r,s,i,o,"next",e)}function o(e){Ed(a,r,s,i,o,"throw",e)}i(void 0)})}}class Ad{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Rd{refCount(e){return Fd("refCount")}incRef(e){return Fd("incRef")}timerAvailable(){return!0}time(e){return Fd("time")}read(e){return Fd("read")}readSync(e){return Fd("readSync")}numDataIds(){return Fd("numDataIds")}disposeData(e,t){return Fd("disposeData")}write(e,t,n){return Fd("write")}move(e,t,n,r,s){return Fd("move")}memory(){return Fd("memory")}floatPrecision(){return Fd("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Fd("dispose")}}function Fd(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Dd(e){let t=e.length,n=0,r=0;for(;t>0;)r=Math.random()*t|0,t--,n=e[t],e[t]=e[r],e[r]=n}function Od(e,t,n){return Math.max(e,Math.min(t,n))}function Md(e){return e%2==0?e:e+1}function Ld(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function zd(e,t,n=""){Ld(Wd(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Pd(e){Ld(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Bd(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Qd(e)&&!n)for(let r=0;r<e.length;++r)Bd(e[r],t,n);else t.push(e);return t}function Vd(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Wd(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ud(e){return e%1==0}function Hd(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Gd(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function jd(e,t=(e=>0),n){return new Promise((r,s)=>{let a=0;const i=()=>{if(e())return void r();a++;const o=t(a);null!=n&&a>=n?s():setTimeout(i,o)};i()})}function qd(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Kd(e,t){const n=t.length;return Ld((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Ld(e.every(e=>Ud(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function Xd(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Kd(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Zd(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Yd(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Jd(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Qd(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function ep(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function tp(e){return"string"==typeof e||e instanceof String}function np(e){return"number"==typeof e}function rp(e){return Array.isArray(e)?rp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":np(e)?"float32":tp(e)?"string":"boolean"==typeof e?"bool":"float32"}function sp(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ap(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function ip(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function op(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<a;t++)s[t]=op(e+t*o,i,n,r)}return s}function lp(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return op(0,e,t,n)}function up(e,t){const n=cp(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function cp(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function hp(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return lp(e,new Float32Array(n));if("int32"===t)return lp(e,new Int32Array(n));if("bool"===t)return lp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function dp(e){e.forEach(t=>{Ld(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function pp(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function fp(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function mp(e){return e&&e.then&&"function"==typeof e.then}class gp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=yp,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return _d(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(mp(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function yp(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function bp(){return vp}let xp,vp=null;function wp(){if(null==xp){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}xp=e}return xp}function kp(e,t){const n=function(){const e=wp();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Ip="Abs",Np="Acos",Sp="Acosh",Cp="Add",Tp="AddN",$p="All",Ep="Any",_p="ArgMax",Ap="ArgMin",Rp="Asin",Fp="Asinh",Dp="Atan",Op="Atanh",Mp="Atan2",Lp="AvgPool",zp="AvgPoolGrad",Pp="AvgPool3D",Bp="AvgPool3DGrad",Vp="BatchMatMul",Wp="BatchToSpaceND",Up="Bincount",Hp="Cast",Gp="Ceil",jp="ClipByValue",qp="Complex",Kp="ComplexAbs",Xp="Concat",Zp="Conv2D",Yp="Conv2DBackpropFilter",Jp="Conv2DBackpropInput",Qp="Conv3D",ef="Conv3DBackpropFilterV2",tf="Conv3DBackpropInputV2",nf="Cos",rf="Cosh",sf="Cumsum",af="CropAndResize",of="DenseBincount",lf="DepthToSpace",uf="DepthwiseConv2dNative",cf="DepthwiseConv2dNativeBackpropFilter",hf="DepthwiseConv2dNativeBackpropInput",df="Diag",pf="Dilation2D",ff="Dilation2DBackpropInput",mf="Dilation2DBackpropFilter",gf="RealDiv",yf="Einsum",bf="Elu",xf="EluGrad",vf="Erf",wf="Equal",kf="Exp",If="ExpandDims",Nf="Expm1",Sf="FFT",Cf="Fill",Tf="FlipLeftRight",$f="Floor",Ef="FloorDiv",_f="FusedBatchNorm",Af="GatherV2",Rf="GatherNd",Ff="Greater",Df="GreaterEqual",Of="Identity",Mf="IFFT",Lf="Imag",zf="IsFinite",Pf="IsInf",Bf="IsNan",Vf="LeakyRelu",Wf="Less",Uf="LessEqual",Hf="LinSpace",Gf="Log",jf="Log1p",qf="LogicalAnd",Kf="LogicalNot",Xf="LogicalOr",Zf="LRN",Yf="LRNGrad",Jf="Max",Qf="Maximum",em="MaxPool",tm="MaxPoolGrad",nm="MaxPool3D",rm="MaxPool3DGrad",sm="MaxPoolWithArgmax",am="Mean",im="Min",om="Minimum",lm="MirrorPad",um="Mod",cm="Multinomial",hm="Multiply",dm="Neg",pm="NotEqual",fm="NonMaxSuppressionV3",mm="NonMaxSuppressionV4",gm="NonMaxSuppressionV5",ym="OnesLike",bm="OneHot",xm="Pack",vm="PadV2",wm="Pow",km="Prelu",Im="Prod",Nm="Range",Sm="Real",Cm="Reciprocal",Tm="Relu",$m="Reshape",Em="ResizeNearestNeighbor",_m="ResizeNearestNeighborGrad",Am="ResizeBilinear",Rm="ResizeBilinearGrad",Fm="Relu6",Dm="Reverse",Om="Round",Mm="Rsqrt",Lm="ScatterNd",zm="Select",Pm="Selu",Bm="Slice",Vm="Sin",Wm="Sinh",Um="Sign",Hm="Sigmoid",Gm="Softplus",jm="Sqrt",qm="Sum",Km="SpaceToBatchND",Xm="SplitV",Zm="Softmax",Ym="SparseFillEmptyRows",Jm="SparseReshape",Qm="SparseSegmentMean",eg="SparseSegmentSum",tg="SparseToDense",ng="SquaredDifference",rg="Square",sg="StridedSlice",ag="StringNGrams",ig="StringSplit",og="StringToHashBucketFast",lg="Sub",ug="Tan",cg="Tanh",hg="Tile",dg="TopK",pg="Transform",fg="Transpose",mg="Unique",gg="Unpack",yg="UnsortedSegmentSum",bg="ZerosLike",xg="Step",vg="FromPixels",wg="RotateWithOffset",kg="_FusedMatMul",Ig="FusedConv2D",Ng="FusedDepthwiseConv2D",Sg=kp("kernelRegistry",()=>new Map),Cg=kp("gradRegistry",()=>new Map);function Tg(e,t){const n=Rg(e,t);return Sg.get(n)}function $g(e){return Cg.get(e)}function Eg(e){const t=Sg.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function _g(e){const{kernelName:t,backendName:n}=e,r=Rg(t,n);Sg.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),Sg.set(r,e)}function Ag(e){const{kernelName:t}=e;Cg.has(t)&&bp().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),Cg.set(t,e)}function Rg(e,t){return`${t}_${e}`}var Fg=n(80);const Dg=n.n(Fg)()||Fg;function Og(e){return Dg.fromString(e,!0,16)}const Mg=Og("c3a5c85c97cb3127"),Lg=Og("b492b66fbe98f273"),zg=Og("9ae16a3b2f90404f");function Pg(e){return e.xor(e.shru(47))}function Bg(e,t,n){const r=e.slice(t,t+n);return Dg.fromBytes(Array.from(r),!0,!0)}function Vg(e,t){return Bg(e,t,8)}function Wg(e,t){return Bg(e,t,4)}function Ug(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Hg(e,t,n=Og("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Gg(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Ug(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Ug(s,44)),[s.add(r),a.add(i)]}(Vg(e,t),Vg(e,t+8),Vg(e,t+16),Vg(e,t+24),n,r)}function jg(e,t=e.length){const n=Dg.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=zg.add(2*t),r=Vg(e,0).add(zg),s=Vg(e,t-8);return Hg(Ug(s,37).mul(n).add(r),Ug(r,25).add(s).mul(n),n)}if(t>=4){const n=zg.add(2*t);return Hg(Wg(e,0).shl(3).add(t),Wg(e,t-4),n)}if(t>0){const n=t+(e[t-1]<<2);return Pg(zg.mul(e[0]+(e[t>>1]<<8)).xor(Mg.mul(n))).mul(zg)}return zg}(e,t):function(e,t=e.length){const n=zg.add(2*t),r=Vg(e,0).mul(Lg),s=Vg(e,8),a=Vg(e,t-8).mul(n),i=Vg(e,t-16).mul(zg);return Hg(Ug(r.add(s),43).add(Ug(a,30)).add(i),r.add(Ug(s.add(zg),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=zg.add(2*t),r=Vg(e,0).mul(zg),s=Vg(e,8),a=Vg(e,t-8).mul(n),i=Vg(e,t-16).mul(zg),o=Ug(r.add(s),43).add(Ug(a,30)).add(i),l=Hg(o,r.add(Ug(s.add(zg),18)).add(a),n),u=Vg(e,16).mul(n),c=Vg(e,24),h=o.add(Vg(e,t-32)).mul(n),d=l.add(Vg(e,t-24)).mul(n);return Hg(Ug(u.add(c),43).add(Ug(h,30)).add(d),u.add(Ug(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Lg).add(113),a=Pg(s.mul(zg).add(113)).mul(zg),i=[Dg.UZERO,Dg.UZERO],o=[Dg.UZERO,Dg.UZERO];r=r.mul(zg).add(Vg(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Ug(r.add(s).add(i[0]).add(Vg(e,l+8)),37).mul(Lg),s=Ug(s.add(i[1]).add(Vg(e,l+48)),42).mul(Lg),r=r.xor(o[1]),s=s.add(i[0]).add(Vg(e,l+40)),a=Ug(a.add(o[0]),33).mul(Lg),i=Gg(e,l,i[1].mul(Lg),r.add(o[0])),o=Gg(e,l+32,a.add(o[1]),s.add(Vg(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const h=Lg.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Ug(r.add(s).add(i[0]).add(Vg(e,l+8)),37).mul(h),s=Ug(s.add(i[1]).add(Vg(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Vg(e,l+40))),a=Ug(a.add(o[0]),33).mul(h),i=Gg(e,l,i[1].mul(h),r.add(o[0])),o=Gg(e,l+32,a.add(o[1]),s.add(Vg(e,l+16))),[a,r]=[r,a],Hg(Hg(i[0],o[0],h).add(Pg(s).mul(Mg)).add(a),Hg(i[1],o[1],h).add(r),h)}function qg(e,t){return"string"===t?Zg(e):Kg([e],t)}function Kg(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Bd(e)),bp().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Xg(){return bp().platform.now()}function Zg(e,t="utf-8"){return t=t||"utf-8",bp().platform.encode(e,t)}function Yg(e,t="utf-8"){return t=t||"utf-8",bp().platform.decode(e,t)}class Jg{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ey)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=Xg();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:Xg()-i})}if(bp().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then(n=>{Qg(n,t.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),r,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function Qg(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class ey{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?Gd(`${r}ms`,9):r.error,o=Gd(e,25),l=t.rank,u=t.size,c=Gd(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ty(e,t,n,r){const s=ip(t),a=function(e,t,n,r){const s=Vd(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?ay(e):e;if(o>1)for(let u=0;u<s/a;u++){const e=u*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],ny(l[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=sy(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(e=>"    "+e).join("\n")),l.join("\n")}function ny(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:tp(e)?`'${e}'`:"bool"===n?ry(e):parseFloat(e.toFixed(7)).toString(),Gd(r,t)}function ry(e){return 0===e?"false":"true"}function sy(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===n?[ny(ay(e)[0],0,n)]:"bool"===n?[ry(e[0])]:[e[0].toString()];if(1===l){if(o>20){let t=Array.from(e.slice(0,3*i)),r=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(t=ay(t),r=ay(r)),["["+t.map((e,t)=>ny(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>ny(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?ay(e):Array.from(e)).map((e,t)=>ny(e,s[t],n)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h;d.push(...sy(e.slice(r,r+h),u,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h;d.push(...sy(e.slice(r,r+h),u,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h;d.push(...sy(e.slice(t,t+h),u,n,c,s,m===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function ay(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class iy{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Vd(e),null!=n){const e=n.length;Ld(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Yd(t,this.size),this.strides=ip(e)}set(e,...t){0===t.length&&(t=[0]),Ld(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return oy().makeTensor(this.values,this.shape,this.dtype)}}let oy=null,ly=null,uy=null;class cy{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Vd(e),this.strides=ip(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return _d(function*(){const t=yield e.data();return ly.buffer(e.shape,e.dtype,t)})()}bufferSync(){return ly.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return _d(function*(){const t=yield e.data();return lp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return lp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return _d(function*(){e.throwIfDisposed();const t=oy().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>Yg(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=oy().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Yg(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return _d(function*(){e.throwIfDisposed();const t=yield oy().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(oy().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ly.print(this,e)}clone(){return this.throwIfDisposed(),ly.clone(this)}toString(e=!1){return ty(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ly.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),oy().makeVariable(this,e,t,n)}}function hy(){return kp("Tensor",()=>cy)}Object.defineProperty(cy,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),hy();class dy extends cy{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Wd(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);oy().disposeTensor(this),this.dataId=e.dataId,oy().incRef(this,null)}dispose(){oy().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(dy,Symbol.hasInstance,{value:e=>e instanceof cy&&null!=e.assign&&e.assign instanceof Function});var py=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(py||(py={})),py))(),fy=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(fy||(fy={})),fy))(),my=(()=>(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(my||(my={})),my))(),gy=(()=>(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(gy||(gy={})),gy))();const yy={float32:my,int32:py,bool:fy,complex64:gy};function by(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return yy[e][t]}function xy(e){return by(e,"int32")}function vy(e,t){if(e.dtype===t.dtype)return[e,t];const n=by(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function wy(e){const t=[];return ky(e,t,new Set),t}function ky(e,t,n){if(null==e)return;if(e instanceof cy)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),ky(e,t,n))}}function Iy(e){return null!=e.kernelName}class Ny{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}let Sy=(()=>{class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ny}ready(){var e=this;return _d(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(yield e.initializeBackend(r).success)return void(yield e.setBackend(r))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return _d(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:r}=t.initializeBackend(e);if(!(r?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new Jg(t.backendInstance),!0})()}setupRegisteredKernels(){Eg(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Eg(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Rd||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){const t=Ty.runKernel(Of,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>Ty.runKernel(Hp,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==Tg(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const a=r-t-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const l=Iy(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Iy(e)){const{kernelName:t,inputs:s,attrs:a}=e,l=Tg(t,this.backendName);Ld(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)});if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,h=Iy(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),r&&this.addTapeNode(l,u,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(e=>null!=u[e]?u[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const r=$g(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Ld(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=e;"string"===(n=n||"float32")&&tp(e[0])&&(s=e.map(e=>Zg(e)));const a=r.write(s,t,n),i=new cy(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s=new cy(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new dy(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ep(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof dy||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*ep(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return _d(function*(){t.state.profiling=!0;const n=t.state.numBytes,r=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-r;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=$g(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=cp(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=wy(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(Ld(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Ld(s instanceof cy,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach(e=>r[e.id]=!0),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=up(Vd(e),"float32");return Ty.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(t=>{const n=e[t.id];i.push(null!=n?n:null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!Wd(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,e=>this.tidy(e),$y);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return Ld(sp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Ld(t.every(e=>e instanceof cy),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Ld(n.value instanceof cy,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Ld(sp(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Ld(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Ld(a.every(e=>e instanceof cy),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return a.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return _d(function*(){const n=Xg(),r=yield t.backend.time(e);return r.wallMs=Xg()-n,r})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ny;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return e.nextTensorId=0,e.nextVariableId=0,e})();function Cy(){const e=wp();if(null==e._tfengine){const t=new gp(e);e._tfengine=new Sy(t)}return vp=e._tfengine.ENV,oy=()=>e._tfengine,e._tfengine}const Ty=Cy();function $y(e,t){return Ty.runKernel(Cp,{a:e,b:t})}function Ey(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _y(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Ay=bp();function Ry(e,t){let n=e;if(Qd(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Qd(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&bp().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Fy(e,r,[]),r}function Fy(e,t,n){if(n=n||[],!Array.isArray(e)&&!Qd(e))return void Ld(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Ld(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Ld(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)Fy(e[s],r,n.concat(s))}function Dy(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Oy(e,t,n,r="numeric"){if(e instanceof cy)return Dy(r,e.dtype,t,n),e;let s=rp(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Dy(r,s,t,n),null==e||!Qd(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const a=Ry(e,s);Qd(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Kg(e,s):Bd(e,[],!0);return Ty.makeTensor(i,a,s)}function My(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>Oy(e,`${t}[${s}]`,n,r))}function Ly(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{Ty.startScope(n);try{const t=r(...e);return mp(t)&&console.error("Cannot return a Promise inside of tidy."),Ty.endScope(t),t}catch(t){throw Ty.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}Ay.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ay.registerFlag("IS_BROWSER",()=>_y()),Ay.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Ay.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ay.registerFlag("PROD",()=>!1),Ay.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ay.getBool("DEBUG")),Ay.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ay.registerFlag("IS_TEST",()=>!1),Ay.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Ay.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const zy=Ly({complex_:function(e,t){const n=Oy(e,"real","complex"),r=Oy(t,"imag","complex");return zd(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),Ty.runKernel(qp,{real:n,imag:r})}});function Py(e,t,n,r){if(null==r&&(r=rp(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Qd(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){dp(t);const e=Vd(t),r=Vd(n);Ld(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Vd(t.slice(s));Ld(n[s]===t[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return Qd(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Kg(e,r):Bd(e,[],!0),Ty.makeTensor(e,t,r)}function By(e,t,n){return Py(e,t,Ry(e,n),n)}const Vy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function Wy(e,t){return Uy.apply(this,arguments)}function Uy(){return(Uy=_d(function*(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(function(){var e=_d(function*(e){const t=yield o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=4,r.set(e,s),s+=e.length}e(r)});return function(t){return e.apply(this,arguments)}}());r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:Hy(yield Promise.all(r)),specs:n}})).apply(this,arguments)}function Hy(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),r.buffer}const Gy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function jy(e){return Gy?Buffer.byteLength(e):new Blob([e]).size}function qy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function Ky(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:jy(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:jy(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function Xy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i];a[i]=e[n[s>>10]+(1023&s)]+t[s>>10]}return new Float32Array(s)}}class Zy{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Zy.instance&&(Zy.instance=new Zy),Zy.instance}static registerSaveRouter(e){Zy.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Zy.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Zy.getHandlers(e,"save")}static getLoadHandlers(e,t){return Zy.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Zy.getInstance().loadRouters:Zy.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const Yy=e=>Zy.getSaveHandlers(e),Jy="tensorflowjs",Qy="models_store",eb="model_info_store";function tb(){if(!bp().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function nb(e){const t=e.result;t.createObjectStore(Qy,{keyPath:"modelPath"}),t.createObjectStore(eb,{keyPath:"modelPath"})}let rb=(()=>{class e{constructor(e){if(this.indexedDB=tb(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return _d(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return _d(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(Jy,1);r.onupgradeneeded=()=>nb(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(Qy,"readonly"),r=t.objectStore(Qy).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{const r=Ky(t),a=s.transaction(eb,"readwrite");let i=a.objectStore(eb);const o=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;o.onsuccess=()=>{l=s.transaction(Qy,"readwrite");const o=l.objectStore(Qy).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});o.onsuccess=()=>e({modelArtifactsInfo:r}),o.onerror=e=>{i=a.objectStore(eb);const t=i.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(o.error)),t.onerror=e=>(s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}return e.URL_SCHEME="indexeddb://",e})();const sb=e=>{return bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rb.URL_SCHEME)?(t=e.slice(rb.URL_SCHEME.length),new rb(t)):null;var t};Zy.registerSaveRouter(sb),Zy.registerLoadRouter(sb);class ab{constructor(){this.indexedDB=tb()}listModels(){var e=this;return _d(function*(){return new Promise((t,n)=>{const r=e.indexedDB.open(Jy,1);r.onupgradeneeded=()=>nb(r),r.onsuccess=()=>{const e=r.result,s=e.transaction(eb,"readonly"),a=s.objectStore(eb).getAll();a.onsuccess=()=>{const e={};for(const t of a.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},a.onerror=t=>(e.close(),n(a.error)),s.oncomplete=()=>e.close()},r.onerror=e=>n(r.error)})})()}removeModel(e){var t=this;return _d(function*(){var n;return e=(n=e).startsWith(rb.URL_SCHEME)?n.slice(rb.URL_SCHEME.length):n,new Promise((n,r)=>{const s=t.indexedDB.open(Jy,1);s.onupgradeneeded=()=>nb(s),s.onsuccess=()=>{const t=s.result,a=t.transaction(eb,"readwrite"),i=a.objectStore(eb),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return t.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const s=i.delete(e),a=()=>{l=t.transaction(Qy,"readwrite");const s=l.objectStore(Qy).delete(e);s.onsuccess=()=>n(o.result.modelArtifactsInfo),s.onerror=e=>r(o.error)};s.onsuccess=a,s.onerror=e=>(a(),t.close(),r(o.error))}},o.onerror=e=>(t.close(),r(o.error)),a.oncomplete=()=>{null==l?t.close():l.oncomplete=()=>t.close()}},s.onerror=e=>r(s.error)})})()}}const ib="/",ob="tensorflowjs_models",lb="info",ub="model_topology",cb="weight_specs",hb="weight_data",db="model_metadata";function pb(e){return{info:[ob,e,lb].join(ib),topology:[ob,e,ub].join(ib),weightSpecs:[ob,e,cb].join(ib),weightData:[ob,e,hb].join(ib),modelMetadata:[ob,e,db].join(ib)}}function fb(e){const t=e.split(ib);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ib)}let mb=(()=>{class e{constructor(e){if(!bp().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=pb(this.modelPath)}save(e){var t=this;return _d(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),a=Ky(e);try{t.LS.setItem(t.keys.info,JSON.stringify(a)),t.LS.setItem(t.keys.topology,r),t.LS.setItem(t.keys.weightSpecs,s),t.LS.setItem(t.keys.weightData,function(e){if(Gy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:a}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}})()}load(){var e=this;return _d(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(e.LS.getItem(e.keys.topology));if(null==r)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=s;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const i=e.LS.getItem(e.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(Gy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(i),n})()}}return e.URL_SCHEME="localstorage://",e})();const gb=e=>{return bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(mb.URL_SCHEME)?(t=e.slice(mb.URL_SCHEME.length),new mb(t)):null;var t};Zy.registerSaveRouter(gb),Zy.registerLoadRouter(gb);class yb{constructor(){Ld(bp().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Ld("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return _d(function*(){const t={},n=ob+ib,r=ib+lb;for(let s=0;s<e.LS.length;++s){const a=e.LS.key(s);a.startsWith(n)&&a.endsWith(r)&&(t[fb(a)]=JSON.parse(e.LS.getItem(a)))}return t})()}removeModel(e){var t=this;return _d(function*(){var n;const r=pb(e=(n=e).startsWith(mb.URL_SCHEME)?n.slice(mb.URL_SCHEME.length):n);if(null==t.LS.getItem(r.info))throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(t.LS.getItem(r.info));return t.LS.removeItem(r.info),t.LS.removeItem(r.topology),t.LS.removeItem(r.weightSpecs),t.LS.removeItem(r.weightData),s})()}}class bb{constructor(){this.managers={}}static getInstance(){return null==bb.instance&&(bb.instance=new bb),bb.instance}static registerManager(e,t){Ld(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Ld(e.length>0,()=>"scheme must not be an empty string.");const n=bb.getInstance();Ld(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class xb{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(bp().get("IS_BROWSER")){bp().setPlatform("browser",new xb);try{bb.registerManager(mb.URL_SCHEME,new yb)}catch(_j){}try{bb.registerManager(rb.URL_SCHEME,new ab)}catch(_j){}}let vb;function wb(e,t="float32",n){return t=t||"float32",dp(e),new iy(e,t,n)}bp().get("IS_NODE")&&bp().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=bp().global.fetch?bp().global.fetch(e,t):(null==vb&&(vb=n(410)),vb(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const kb=Ly({cast_:function(e,t){const n=Oy(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Ty.runKernel(Hp,{x:n},{dtype:t})}}),Ib=Ly({clone_:function(e){const t=Oy(e,"x","clone","string_or_numeric");return Ty.runKernel(Of,{x:t})}});function Nb(e){return new Promise(e=>setTimeout(e)).then(e)}Cy(),ly={buffer:wb,cast:kb,clone:Ib,print:function(e,t=!1){console.log(e.toString(t))}};let Sb=(()=>{class e{constructor(t){if(!bp().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(e){var t=this;return _d(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),a=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(a.download=t.modelTopologyFileName,a.href=s,yield Nb(()=>a.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield Nb(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ky(e)}}})()}}return e.URL_SCHEME="downloads://",e})();function Cb(e,t,n,r){!function(e){Ld(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Ld(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Ld(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Ld(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(a=>(a.then(a=>{const i=n+ ++s/e.length*(r-n);return t(i),a}),a)))}function Tb(e,t){return $b.apply(this,arguments)}function $b(){return($b=_d(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?bp().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?yield Promise.all(r):yield Cb(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(s):yield Cb(s,t.onProgress,.5,1)})).apply(this,arguments)}Zy.registerSaveRouter(e=>bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Sb.URL_SCHEME)?function(e="model"){return new Sb(e)}(e.slice(Sb.URL_SCHEME.length)):null);let Eb=(()=>{class e{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Ld("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=bp().platform.fetch,Ld(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Ld(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return _d(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=yield t.fetch(t.path,n);if(s.ok)return{modelArtifactsInfo:Ky(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})()}load(){var e=this;return _d(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const r=n.modelTopology,s=n.weightsManifest,a=n.generatedBy,i=n.convertedBy,o=n.format,l=n.signature,u=n.userDefinedMetadata;if(null==r&&null==s)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=s){const t=yield e.loadWeights(s);[c,h]=t}const d={modelTopology:r,weightSpecs:c,weightData:h,generatedBy:a,convertedBy:i,format:o};null!=l&&(d.signature=l),null!=u&&(d.userDefinedMetadata=u);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(e){var t=this;return _d(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[r,s]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),a=t.weightPathPrefix||r,i=[];for(const t of e)i.push(...t.weights);const o=[],l=[];for(const u of e)for(const e of u.paths)null!=t.weightUrlConverter?l.push(t.weightUrlConverter(e)):o.push(a+e+s);return t.weightUrlConverter&&o.push(...yield Promise.all(l)),[i,qy(yield Tb(o,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}return e.URL_SCHEME_REGEX=/^https?:\/\//,e})();function _b(e){return null!=e.match(Eb.URL_SCHEME_REGEX)}const Ab=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>_b(e)):_b(e),n)return Rb(e,t)}return null};function Rb(e,t){return new Eb(e,t)}function Fb(e,t){return Rb(e,t)}let Db;Zy.registerSaveRouter(Ab),Zy.registerLoadRouter(Ab);const Ob=Ly({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(s){const t=2;if(s&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Tg(vg,Ty.backendName))return Ty.runKernel(vg,{pixels:e},{numChannels:t});const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,h;if(i?c=e.getContext("2d").getImageData(0,0,l,u).data:r||n?c=e.data:(a||s||o)&&(null==Db&&(Db=document.createElement("canvas").getContext("2d")),Db.canvas.width=l,Db.canvas.height=u,Db.drawImage(e,0,0,l,u),c=Db.getImageData(0,0,l,u).data),4===t)h=new Int32Array(c);else{const e=l*u;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=c[4*n+e]}return function(e,t,n){if(Pd(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ry(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Py(e,t,r,n)}(h,[u,l,t],"int32")}});function Mb(e,t,n){const r=e.shape.length;Ld(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Ld(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Ld(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function Lb(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function zb(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Pb(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Bb(e,t,n){return n<=e?n:n-(t-1)}function Vb(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Wb(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Ub(i,l,u,r,e),h=Hb(o,l,u,s,e),d=Pb(a,l,u,e)}else for(let p=0;p<u;p++)c[p]=jb(i,r,a,e,p,l),h[p]=qb(o,s,a,e,p,l),d[p]=Gb(a,p,l);return{begin:c,end:h,strides:d}}function Ub(e,t,n,r,s){const a=[...s],i=Vb(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=Bb(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function Hb(e,t,n,r,s){const a=[...s],i=Vb(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=Bb(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=Od(0,a[o],s[o])}return a}function Gb(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function jb(e,t,n,r,s,a){let i=t[s];(e&1<<s||a&1<<s||null==i)&&(i=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=r[s];return i<0&&(i+=o),i=Od(0,i,o-1),i}function qb(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?Od(0,i,l):Od(-1,i,l-1),i}function Kb(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Xb(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Zb(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{Ld(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(Ld(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,a]}function Yb(e,t,n,r,s,a,i,o,l){let u=t.slice(),c=n.slice(),h=r;null==r&&(h=new Array(u.length));const d=Lb(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=e.length-u.length,f=Lb(o),m=e.slice();f.forEach(e=>{u[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:y,strides:b}=Wb(m,d,p,u,c,h,s,a,i);u=g,c=y,h=b;const x=Lb(l);x.forEach(e=>{c[e]=u[e]+1,h[e]=1});const v=zb(u,c,h),w=v.filter((e,t)=>-1===x.indexOf(t));return{nonStrided:h.every(e=>1===e),$begin:u,$end:c,$strides:h,size:v,newShape:m,outShape:w}}class Jb{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Qb{constructor(){this.classNameMap={}}static getMap(){return null==Qb.instance&&(Qb.instance=new Qb),Qb.instance}static register(e){Qb.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ex(e){Ld(null!=e.className,()=>"Class being registered does not have the static className property defined."),Ld("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Ld(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Qb.register(e)}function tx(){return Ty}function nx(){return Ty.memory()}function rx(e,t){return Ty.tidy(e,t)}function sx(e){wy(e).forEach(e=>e.dispose())}function ax(e){return Ty.keep(e)}function ix(e,t,n=1){return Ty.registerBackend(e,t,n)}function ox(e){return Ty.customGrad(e)}function lx(e,t){if((Qd(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Qd(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Py(e,[],[],t)}uy=function(e){bp().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class ux extends Jb{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return sx(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Ld(sp(e),()=>"The f passed in variableGrads(f) must be a function"),Ld(null==t||Array.isArray(t)&&t.every(e=>e instanceof dy),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Ty.registeredVariables)t.push(Ty.registeredVariables[e])}const r=n?t.filter(e=>!e.trainable):null,s=t.length;Ld((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:a,grads:i}=Ty.gradients(e,t,null,!0);Ld(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Ld(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=r&&r.forEach(e=>o[e.name]=null),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&sx(this.iterations_)}saveIterations(){var e=this;return _d(function*(){return null==e.iterations_&&(e.iterations_=0),{name:"iter",tensor:lx(e.iterations_,"int32")}})()}getWeights(){return _d(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(e){var t=this;return _d(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(e){var t=this;return _d(function*(){return t.iterations_=(yield e[0].tensor.data())[0],e.slice(1)})()}}Object.defineProperty(ux,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const cx=Ly({abs_:function(e){const t=Oy(e,"x","abs");return Ty.runKernel("complex64"===t.dtype?Kp:Ip,{x:t})}}),hx=Ly({add_:function(e,t){let n=Oy(e,"a","add"),r=Oy(t,"b","add");return[n,r]=vy(n,r),Ty.runKernel(Cp,{a:n,b:r})}}),dx=Ly({all_:function(e,t=null,n=!1){const r=Oy(e,"x","all","bool");return Ty.runKernel($p,{x:r},{axis:t,keepDims:n})}}),px=Ly({any_:function(e,t=null,n=!1){const r=Oy(e,"x","any","bool");return Ty.runKernel(Ep,{x:r},{axis:t,keepDims:n})}}),fx=Ly({argMax_:function(e,t=0){const n=Oy(e,"x","argMax");return Ty.runKernel(_p,{x:n},{axis:t})}});function mx(e,t,n,r,s="NHWC",a){return bx(e,[...t,e[3]],n,a,r,null,null,Tx(s))}function gx(e,t,n,r,s,a,i="channelsLast"){const[o,l]=wx(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return bx(e,u,n,r,s,a,!1,i)}function yx(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=kx(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return xx(e,c,n,r,s,!1,h,a)}function bx(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}const[d,p,,f]=t,[m,g]=wx(n),[y,b]=wx(r),x=Ix(d,y),v=Ix(p,b),{padInfo:w,outHeight:k,outWidth:I}=function(e,t,n,r,s,a,i,o,l){let u,c,h;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=vx(e,t,n));const a=e[1];return[Nx((e[0]-t+2*r)/n+1,s),Nx((a-t+2*r)/n+1,s)]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(e/2),d=e-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Nx((t-a+d+p)/r+1,o),h=Nx((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,x,v,a,o),N=i?f*h:f;let S;return"channelsFirst"===o?S=[l,N,k,I]:"channelsLast"===o&&(S=[l,k,I,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:I,outChannels:N,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function xx(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c,h]=e}const[p,f,m,,g]=t,[y,b,x]=kx(n),[v,w,k]=kx(r),I=Ix(p,v),N=Ix(f,w),S=Ix(m,k),{padInfo:C,outDepth:T,outHeight:$,outWidth:E}=function(e,t,n,r,s,a,i,o,l,u,c){let h,d,p,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,s,a){null==s&&(s=vx(e,t,r));const i=e[1],o=e[2];return[Nx((e[0]-t+2*s)/r+1,a),Nx((i-t+2*s)/r+1,a),Nx((o-t+2*s)/r+1,a),1]}([t,n,r,1],o,0,s,e,c);d=a[0],p=a[1],f=a[2]}else if("same"===e){d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),x=c-b,v=Math.floor(m/2);h={top:b,bottom:x,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-o+1)/s),p=Math.ceil((n-l+1)/a),f=Math.ceil((r-u+1)/i)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,y,b,x,I,N,S,o),_=a?g*d:g;let A;return"channelsFirst"===i?A=[l,_,T,$,E]:"channelsLast"===i&&(A=[l,T,$,E,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:$,outWidth:E,outChannels:_,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:S,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function vx(e,t,n,r=1){const s=Ix(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function wx(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function kx(e){return"number"==typeof e?[e,e,e]:e}function Ix(e,t){return t<=1?e:e+(e-1)*(t-1)}function Nx(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Sx(e){const[t,n,r]=wx(e);return 1===t&&1===n&&1===r}function Cx(e,t){return Sx(e)||Sx(t)}function Tx(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const $x=Ly({reshape_:function(e,t){const n=Oy(e,"x","reshape","string_or_numeric");return Ty.runKernel($m,{x:n},{shape:t})}}),Ex=Ly({avgPool_:function(e,t,n,r,s){const a=Oy(e,"x","avgPool","float32");Ld(Cx(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=a,o=!1;3===a.rank&&(o=!0,i=$x(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ld(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),null!=s&&Ld(Ud(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=Ty.runKernel(Lp,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return l=kb(l,a.dtype),o?$x(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),_x=Ly({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=Oy(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=$x(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ld(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Ld("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=s&&Ld(Ud(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u=Ty.runKernel(Pp,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a});return u=kb(u,o.dtype),l?$x(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),Ax=Ly({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=Oy(e,"x","batchNorm"),o=Oy(t,"mean","batchNorm"),l=Oy(n,"variance","batchNorm");let u,c;null!=s&&(u=Oy(s,"scale","batchNorm")),null!=r&&(c=Oy(r,"offset","batchNorm")),Ld(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ld(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ld(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(e){let t;return t=0===e.rank||1===e.rank?$x(e,[1,1,1,e.size]):2===e.rank?$x(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?$x(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d=Ty.runKernel(_f,{x:h,scale:u,offset:c,mean:o,variance:l},{varianceEpsilon:a});return $x(d,i.shape)}}),Rx=Ly({batchNorm2d_:function(e,t,n,r,s,a){const i=Oy(e,"x","batchNorm"),o=Oy(t,"mean","batchNorm"),l=Oy(n,"variance","batchNorm");let u,c;return null!=s&&(u=Oy(s,"scale","batchNorm")),null!=r&&(c=Oy(r,"offset","batchNorm")),Ld(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Ld(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Ld(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&Ld(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&Ld(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Ax(i,o,l,c,u,a)}}),Fx=Ly({batchNorm3d_:function(e,t,n,r,s,a){const i=Oy(e,"x","batchNorm"),o=Oy(t,"mean","batchNorm"),l=Oy(n,"variance","batchNorm");let u,c;return null!=s&&(u=Oy(s,"scale","batchNorm")),null!=r&&(c=Oy(r,"offset","batchNorm")),Ld(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Ld(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Ld(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&Ld(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&Ld(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Ax(i,o,l,c,u,a)}}),Dx=Ly({batchNorm4d_:function(e,t,n,r,s,a){const i=Oy(e,"x","batchNorm"),o=Oy(t,"mean","batchNorm"),l=Oy(n,"variance","batchNorm");let u,c;return null!=s&&(u=Oy(s,"scale","batchNorm")),null!=r&&(c=Oy(r,"offset","batchNorm")),Ld(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Ld(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Ld(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&Ld(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&Ld(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Ax(i,o,l,c,u,a)}}),Ox=Ly({clipByValue_:function(e,t,n){const r=Oy(e,"x","clipByValue");return Ld(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Ty.runKernel(jp,{x:r},{clipValueMin:t,clipValueMax:n})}}),Mx=Ly({concat_:function(e,t=0){Ld(e.length>=1,()=>"Pass at least one tensor to concat");const n=My(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?Ib(n[0]):Ty.runKernel(Xp,n,{axis:t})}}),Lx=Ly({concat1d_:function(e){return Mx(e,0)}}),zx=Ly({concat2d_:function(e,t){return Mx(e,t)}}),Px=Ly({concat3d_:function(e,t){return Mx(e,t)}}),Bx=Ly({concat4d_:function(e,t){return Mx(e,t)}}),Vx=Ly({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Oy(e,"x","conv2d"),l=Oy(t,"filter","conv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=$x(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ld(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Ld(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),null!=i&&Ld(Ud(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h="NHWC"===s?u.shape[3]:u.shape[1];Ld(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),Ld(Cx(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const d=Ty.runKernel(Zp,{x:u,filter:l},{strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i});return c?$x(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Wx=Ly({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=Oy(e,"x","conv1d"),l=Oy(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=$x(o,[1,o.shape[0],o.shape[1]])),Ld(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Ld(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),null!=i&&Ld(Ud(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Ld(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Ld(Cx(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Ld("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=$x(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=$x(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Vx(d,h,[1,n],r,"NHWC",[1,a],i);return $x(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Ux=Ly({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Ld(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=$x(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Ld(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Ld(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Ld(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?l.shape[3]:l.shape[1];Ld(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Ld(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=i&&Ld(Ud(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const d=Ty.runKernel(Jp,{dy:l,filter:n},{strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o});return u?$x(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Hx=Ly({conv2dTranspose_:function(e,t,n,r,s,a){const i=Oy(e,"x","conv2dTranspose"),o=Oy(t,"filter","conv2dTranspose");return Ux(n,i,o,r,s,"NHWC",a)}}),Gx=Ly({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=Oy(e,"x","conv3d"),o=Oy(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=$x(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ld(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Ld(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Ld(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Ld(Cx(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ld("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=Ty.runKernel(Qp,{x:l,filter:o},{strides:n,pad:r,dataFormat:s,dilations:a});return u?$x(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),jx=Ly({conv3DBackpropInput_:function(e,t,n,r,s){Ld(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=$x(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Ld(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Ld(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Ld(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Ld(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Ld(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=Ty.runKernel(tf,{dy:i,filter:n},{pad:s,strides:r,inputShape:a});return o?$x(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),qx=Ly({conv3dTranspose_:function(e,t,n,r,s){const a=Oy(e,"x","conv3dTranspose"),i=Oy(t,"filter","conv3dTranspose");return jx(n,a,i,r,s)}}),Kx=Ly({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Oy(e,"x","depthwiseConv2d"),l=Oy(t,"filter","depthwiseConv2d");let u=o,c=!1;3===o.rank&&(c=!0,u=$x(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ld(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Ld(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),Ld(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=i&&Ld(Ud(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=Ty.runKernel(uf,{x:u,filter:l},{strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i});return c?$x(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Xx=Ly({floorDiv_:function(e,t){let n=Oy(e,"a","floorDiv"),r=Oy(t,"b","floorDiv");return[n,r]=vy(n,r),Ty.runKernel(Ef,{a:n,b:r})}}),Zx=Ly({div_:function(e,t){let n=Oy(e,"a","div"),r=Oy(t,"b","div");return[n,r]=vy(n,r),"int32"===n.dtype&&"int32"===r.dtype?Xx(n,r):Ty.runKernel(gf,{a:n,b:r},{})}}),Yx=Ly({elu_:function(e){const t=Oy(e,"x","elu");return Ty.runKernel(bf,{x:t})}});function Jx(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function Qx(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function ev(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let a=t[t.length-s-1];if(null==a&&(a=1),1===r)n.unshift(a);else if(1===a)n.unshift(r);else{if(r!==a)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}const tv=Ly({equal_:function(e,t){let n=Oy(e,"a","equal","string_or_numeric"),r=Oy(t,"b","equal","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(wf,{a:n,b:r})}}),nv=Ly({expandDims_:function(e,t=0){const n=Oy(e,"x","expandDims","string_or_numeric");return Ld(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Ty.runKernel(If,{input:n},{dim:t})}}),rv=Ly({tile_:function(e,t){const n=Oy(e,"x","tile","string_or_numeric");return Ld(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Ty.runKernel(hg,{x:n},{reps:t})}}),sv=Ly({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=wb([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=$x(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return rv(nv(i,0),[n[0],1,1]);if(2===n.length)return rv(nv(nv(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return rv(nv(nv(nv(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function av(e,t,n){return Ty.runKernel(Cf,{},{shape:e,value:t,dtype:n})}const iv=Ly({floor_:function(e){const t=Oy(e,"x","floor");return Ty.runKernel($f,{x:t})}}),ov=Ly({gather_:function(e,t,n=0,r=0){const s=Oy(e,"x","gather"),a=Oy(t,"indices","gather","int32");return Ty.runKernel(Af,{x:s,indices:a},{axis:n,batchDims:r})}}),lv=Ly({greater_:function(e,t){let n=Oy(e,"a","greater","string_or_numeric"),r=Oy(t,"b","greater","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(Ff,{a:n,b:r})}}),uv=Ly({greaterEqual_:function(e,t){let n=Oy(e,"a","greaterEqual","string_or_numeric"),r=Oy(t,"b","greaterEqual","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(Df,{a:n,b:r})}}),cv=Ly({leakyRelu_:function(e,t=.2){const n=Oy(e,"x","leakyRelu");return Ty.runKernel(Vf,{x:n},{alpha:t})}}),hv=Ly({log_:function(e){const t=Oy(e,"x","log");return Ty.runKernel(Gf,{x:t})}}),dv=Ly({exp_:function(e){const t=Oy(e,"x","exp");return Ty.runKernel(kf,{x:t})}}),pv=Ly({max_:function(e,t=null,n=!1){const r=Oy(e,"x","max");return Ty.runKernel(Jf,{x:r},{reductionIndices:t,keepDims:n})}}),fv=Ly({mul_:function(e,t){let n=Oy(e,"a","mul"),r=Oy(t,"b","mul");return[n,r]=vy(n,r),Ty.runKernel(hm,{a:n,b:r})}}),mv=Ly({sub_:function(e,t){let n=Oy(e,"a","sub"),r=Oy(t,"b","sub");return[n,r]=vy(n,r),Ty.runKernel(lg,{a:n,b:r})}}),gv=Ly({sum_:function(e,t=null,n=!1){let r=Oy(e,"x","sum");return"bool"===r.dtype&&(r=kb(r,"int32")),Ty.runKernel(qm,{x:r},{axis:t,keepDims:n})}}),yv=Ly({logSoftmax_:function(e,t=-1){const n=Oy(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return ox((e,n)=>{const r=pv(e,t,!0),s=mv(e,r),a=mv(kb(s,"float32"),hv(gv(dv(s),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[r]=n,s=dv(r);return mv(e,fv(gv(e,t,!0),s))}}})(n)}}),bv=Ly({logicalAnd_:function(e,t){const n=Oy(e,"a","logicalAnd","bool"),r=Oy(t,"b","logicalAnd","bool");return ev(n.shape,r.shape),Ty.runKernel(qf,{a:n,b:r})}}),xv=Ly({maxPool_:function(e,t,n,r,s){const a=Oy(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=$x(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ld(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),Ld(Cx(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&Ld(Ud(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=Ty.runKernel(em,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return o?$x(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),vv=Ly({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=Oy(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=$x(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ld(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Ld("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=s&&Ld(Ud(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const u=Ty.runKernel(nm,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a});return l?$x(u,[u.shape[1],u.shape[2],u.shape[3],u.shape[4]]):u}}),wv=Ly({maximum_:function(e,t){let n=Oy(e,"a","maximum"),r=Oy(t,"b","maximum");return[n,r]=vy(n,r),"bool"===n.dtype&&(n=kb(n,"int32"),r=kb(r,"int32")),ev(n.shape,r.shape),Ty.runKernel(Qf,{a:n,b:r})}}),kv=Ly({mean_:function(e,t=null,n=!1){const r=Oy(e,"x","mean");return Ty.runKernel(am,{x:r},{axis:t,keepDims:n})}}),Iv=Ly({minimum_:function(e,t){let n=Oy(e,"a","minimum"),r=Oy(t,"b","minimum");return[n,r]=vy(n,r),"bool"===n.dtype&&(n=kb(n,"int32"),r=kb(r,"int32")),ev(n.shape,r.shape),Ty.runKernel(om,{a:n,b:r})}});function Nv(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Sv(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Cv(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function Tv(e,t){return Sv(e,t.map(e=>1),t)}function $v(e,t,n){Ld(Nv(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Ev(e,t){if(Nv(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function _v(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Av(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Rv=Ly({square_:function(e){const t=Oy(e,"x","square");return Ty.runKernel("Square",{x:t},{})}}),Fv=Ly({moments_:function(e,t=null,n=!1){const r=Kd(t,(e=Oy(e,"x","moments")).shape),s=kv(e,r,n);let a=s.shape;n||(a=Tv(s.shape,r));const i=Rv(mv(kb(e,"float32"),$x(s,a)));return{mean:s,variance:kv(i,r,n)}}}),Dv=Ly({neg_:function(e){const t=Oy(e,"x","neg");return Ty.runKernel(dm,{x:t})}}),Ov=Ly({notEqual_:function(e,t){let n=Oy(e,"a","notEqual","string_or_numeric"),r=Oy(t,"b","notEqual","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(pm,{a:n,b:r})}}),Mv=Ly({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s=Oy(e,"indices","oneHot","int32");return Ty.runKernel(bm,{indices:s},{depth:t,onValue:n,offValue:r})}});function Lv(e,t="float32"){if("complex64"===t){const t=Lv(e,"float32"),n=Lv(e,"float32");return zy(t,n)}const n=cp(Vd(e),t);return Ty.makeTensor(n,e,t)}function zv(e,t="float32"){if("complex64"===t){const t=zv(e,"float32"),n=Lv(e,"float32");return zy(t,n)}const n=up(Vd(e),t);return Ty.makeTensor(n,e,t)}const Pv=Ly({onesLike_:function(e){const t=Oy(e,"x","onesLike");return Ty.runKernel(ym,{x:t})}}),Bv=Ly({pad_:function(e,t,n=0){const r=Oy(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Ty.runKernel(vm,{x:r},{paddings:t,constantValue:n})}}),Vv=Ly({prelu_:function(e,t){const n=Oy(e,"x","prelu"),r=Oy(t,"alpha","prelu");return Ty.runKernel(km,{x:n,alpha:r})}});var Wv=n(901);class Uv{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=Wv.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Hv{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Wv.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Gv=Ly({randomNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Uv(t,n,r,!1,s),i=wb(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),jv=Ly({randomUniform_:function(e,t=0,n=1,r="float32",s){const a=wb(e,r),i=new Hv(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),qv=Ly({relu_:function(e){const t=Oy(e,"x","relu");return Ty.runKernel(Tm,{x:t})}}),Kv=Ly({reverse_:function(e,t){const n=Oy(e,"x","reverse");return Ty.runKernel(Dm,{x:n},{dims:t})}}),Xv=Ly({selu_:function(e){const t=Oy(e,"x","selu");return Ty.runKernel(Pm,{x:t})}}),Zv=Ly({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=Oy(e,"x","separableConv2d"),l=Oy(t,"depthwiseFilter","separableConv2d"),u=Oy(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=$x(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Ld(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Ld(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Ld(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Ld(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Ld(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];Ld(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=Kx(c,l,r,s,i,a),m=Vx(f,u,1,"valid",i);return h?$x(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Yv=Ly({sigmoid_:function(e){const t=Oy(e,"x","sigmoid");return Ty.runKernel(Hm,{x:t})}}),Jv=Ly({slice_:function(e,t,n){const r=Oy(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return Ty.runKernel(Bm,{x:r},{begin:t,size:n})}}),Qv=Ly({slice1d_:function(e,t,n){const r=Oy(e,"x","slice1d");return Ld(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Jv(r,[t],[n])}}),ew=Ly({slice2d_:function(e,t,n){const r=Oy(e,"x","slice2d");return Ld(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Jv(r,t,n)}}),tw=Ly({slice3d_:function(e,t,n){const r=Oy(e,"x","slice3d");return Ld(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Jv(r,t,n)}}),nw=Ly({slice4d_:function(e,t,n){const r=Oy(e,"x","slice4d");return Ld(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Jv(r,t,n)}}),rw=Ly({softmax_:function(e,t=-1){const n=Oy(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Ty.runKernel(Zm,{logits:n},{dim:t})}}),sw=Ly({softplus_:function(e){const t=Oy(e,"x","softplus");return Ty.runKernel(Gm,{x:t})}}),aw=Ly({split_:function(e,t,n=0){const r=Oy(e,"x","split");return Ty.runKernel(Xm,{x:r},{numOrSizeSplits:t,axis:n})}}),iw=Ly({sqrt_:function(e){const t=Oy(e,"x","sqrt");return Ty.runKernel(jm,{x:t})}}),ow=Ly({squeeze_:function(e,t){const n=Oy(e,"x","squeeze");return $x(n,Xd(n.shape,t).newShape)}}),lw=Ly({stack_:function(e,t=0){const n=My(e,"tensors","stack","string_or_numeric");return Ld(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Ld(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Ty.runKernel(xm,n,{axis:t})}}),uw=Ly({tanh_:function(e){const t=Oy(e,"x","tanh");return Ty.runKernel(cg,{x:t})}});function cw(e,t){Pd(e);const n=Ry(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Py(e,null,n,t)}const hw=Ly({truncatedNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Uv(t,n,r,!0,s),i=wb(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),dw=Ly({unstack_:function(e,t=0){const n=Oy(e,"x","unstack","string_or_numeric");return Ld(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Ty.runKernel(gg,{value:n},{axis:t})}}),pw=Ly({broadcastTo_:function(e,t){let n=Oy(e,"broadcastTo","x");const r=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=$x(n,e)}const s=n.shape,a=Array.from(t);for(let i=t.length-1;i>=0;i--)if(s[i]===t[i])a[i]=1;else if(1!==n.shape[i])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?Ib(n):Ty.runKernel(hg,{x:n},{reps:a})}}),fw=Ly({where_:function(e,t,n){const r=Oy(t,"a","where"),s=Oy(n,"b","where"),a=Oy(e,"condition","where","bool"),i=ev(ev(a.shape,r.shape),s.shape),o=pw(a,i),l=pw(r,i),u=pw(s,i);return Ty.runKernel(zm,{condition:o,t:l,e:u})}}),mw=Ly({zerosLike_:function(e){const t=Oy(e,"x","zerosLike");return Ty.runKernel(bg,{x:t})}}),gw=Ly({transpose_:function(e,t){const n=Oy(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Ld(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Ld(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Ty.runKernel(fg,{x:n},{perm:t})}}),yw=Ly({dropout_:function(e,t,n,r){const s=Oy(e,"x","dropout");if(Ld("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Ld(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof cy?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(Wd(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)n.push(null==t[r]&&null!=e.shape[r]?e.shape[r]:t[r]);return n}return t}(s,n),i=1-t,o=Zx(iv(hx(jv(a,0,1,"float32",r),i)),i);return fv(s,o)}}),bw=Ly({imag_:function(e){const t=Oy(e,"input","imag");return Ty.runKernel(Lf,{input:t})}}),xw=Ly({real_:function(e){const t=Oy(e,"input","real");return Ty.runKernel(Sm,{input:t})}}),vw=Ly({fft_:function(e){return Ld("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),Ty.runKernel(Sf,{input:e})}}),ww=Ly({rfft_:function(e,t){Ld("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,s=Jv(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=Mx([e,Lv(r)],e.shape.length-1),n=t}else s=e;const a=mw(s),i=$x(zy(s,a),[r,n]),o=vw(i),l=Math.floor(n/2)+1,u=xw(o),c=bw(o),h=aw(u,[l,n-l],u.shape.length-1),d=aw(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,$x(zy(h[0],d[0]),p)}}),kw=Ly({ifft_:function(e){return Ld("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),Ty.runKernel(Mf,{input:e})}}),Iw=Ly({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=$x(e,[n,t]);r=kw(s)}else{const s=[n,2*(t-1)],a=$x(xw(e),[n,t]),i=$x(bw(e),[n,t]),o=Kv(Jv(a,[0,1],[n,t-2]),1),l=fv(Kv(Jv(i,[0,1],[n,t-2]),1),lx(-1)),u=Mx([a,o],1),c=Mx([i,l],1),h=$x(zy(u,c),[s[0],s[1]]);r=kw(h)}if(r=xw(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=$x(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),Nw=Ly({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=$x(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=$x(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ld(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Ld(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Ld(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];return Ld(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Ld(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=i&&Ld(Ud(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),Ty.runKernel(Yp,{x:o,dy:l},{strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n})}}),Sw=Ly({relu6_:function(e){const t=Oy(e,"x","relu6");return Ty.runKernel(Fm,{x:t})}}),Cw=Ly({step_:function(e,t=0){const n=Oy(e,"x","step");return Ty.runKernel(xg,{x:n},{alpha:t})}});function Tw(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return fv(e,Cw(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function $w(e,t){let n=t;const r=Qx(e.shape,t.shape);return r.length>0&&(n=gv(n,r)),$x(n,e.shape)}function Ew(e,t,n,r){if("linear"===t)return e;if("relu"===t)return qv(e);if("elu"===t)return Yx(e);if("relu6"===t)return Sw(e);if("prelu"===t)return Vv(e,n);if("leakyrelu"===t)return cv(e,r);if("sigmoid"===t)return Yv(e);throw new Error(`Unknown fused activation ${t}.`)}const _w=(e,t)=>!(e>0)||"linear"===t,Aw=Ly({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===_w(Ty.state.gradientDepth,l=l||"linear")){let h=Vx(e,t,n,r,s,a,i);return null!=o&&(h=hx(h,o)),Ew(h,l,u,c)}const h=Oy(e,"x","conv2d"),d=Oy(t,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=$x(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ld(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Ld(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=i&&Ld(Ud(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Ld(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),Ld(Cx(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ld("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=bx(p.shape,d.shape,n,a,r,i);let g,y;null!=o&&(g=Oy(o,"bias","fused conv2d"),[g]=vy(g,h),ev(m.outShape,g.shape)),null!=u&&(y=Oy(u,"prelu weights","fused conv2d"));const b=(e,t)=>{const[s,i,o,u]=t,c=Tw(e,o,l);Ld(Sx(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const h=[Ux(i.shape,c,s,n,r),Nw(i,c,s.shape,n,r)];if(null!=u){const e=$w(u,c);h.push(e)}return h},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==o?ox((e,t,n)=>{let r=Ty.runKernel(Ig,x,v);return n([t,e,r]),f&&(r=$x(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d):ox((e,t,n,r)=>{let s=Ty.runKernel(Ig,x,v);return r([t,e,s,n]),f&&(s=$x(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d,g)}}),Rw=Ly({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=$x(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;return 3===l.rank&&(l=$x(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ty.runKernel(cf,{x:o,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n})}}),Fw=Ly({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=$x(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u=Ty.runKernel(hf,{dy:o,filter:n},{strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e});return l?$x(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Dw=Ly({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===_w(Ty.state.gradientDepth,l)){let h=Kx(e,t,n,r,s,a,i);return null!=o&&(h=hx(h,o)),Ew(h,l,u,c)}const h=Oy(e,"x","depthwiseConv2d"),d=Oy(t,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=$x(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ld(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Ld(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Ld(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==a&&(a=[1,1]),Ld(Cx(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),null!=i&&Ld(Ud(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);const m=bx(p.shape,d.shape,n,a,r,i,!0);let g,y;null!=o&&(g=Oy(o,"bias","fused conv2d"),[g]=vy(g,h),ev(m.outShape,g.shape)),null!=u&&(y=Oy(u,"prelu weights","fused depthwiseConv2d"));const b=(e,t)=>{Ld(Sx(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[s,o,u,c]=t,h=Tw(e,u,l),d=Fw(o.shape,h,s,n,r,a,i),p=Rw(o,h,s.shape,n,r,a,i);return null!=c?[d,p,$w(g,h)]:[d,p]},x={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==o?ox((e,t,n)=>{let r=Ty.runKernel(Ng,x,v);return n([t,e,r]),f&&(r=$x(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}})(p,d):ox((e,t,n,r)=>{let s=Ty.runKernel(Ng,x,v);return r([t,e,s,n]),f&&(s=$x(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}})(p,d,g)}}),Ow=Ly({matMul_:function(e,t,n=!1,r=!1){let s=Oy(e,"a","matMul"),a=Oy(t,"b","matMul");return[s,a]=vy(s,a),Ty.runKernel(Vp,{a:s,b:a},{transposeA:n,transposeB:r})}}),Mw=Ly({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o}){if(!1===_w(Ty.state.gradientDepth,a)){let l=Ow(e,t,n,r);return null!=s&&(l=hx(l,s)),Ew(l,a,i,o)}let l=Oy(e,"a","fused matMul"),u=Oy(t,"b","fused matMul");[l,u]=vy(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Vd(f),y=Vd(m);Ld(l.rank>=2&&u.rank>=2&&l.rank===u.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${l.rank} and ${u.rank}.`),Ld(Wd(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${l.shape} and ${u.shape} must match.`),Ld(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const b=l.shape.slice(0,-2).concat([d,p]),x=$x(l,n?[g,c,d]:[g,d,c]),v=$x(u,r?[y,p,h]:[y,h,p]);let w,k;null!=s&&(w=Oy(s,"bias","fused matMul"),[w]=vy(w,l),ev(b,w.shape)),null!=i&&(k=Oy(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[i,o,l,u]=t,c=Tw($x(e,l.shape),l,a);let h,d;return n||r?!n&&r?(h=Ow(c,o,!1,!1),d=Ow(c,i,!0,!1)):n&&!r?(h=Ow(o,c,!1,!0),d=Ow(i,c,!1,!1)):(h=Ow(o,c,!0,!0),d=Ow(c,i,!0,!0)):(h=Ow(c,o,!1,!0),d=Ow(i,c,!0,!1)),null!=s?[h,d,$w(u,c)]:[h,d]},N={a:x,b:v,bias:w,preluActivationWeights:k},S={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return null==s?ox((e,t,n)=>{const r=Ty.runKernel(kg,N,S);return n([e,t,r]),{value:$x(r,b),gradFunc:I}})(x,v):ox((e,t,n,r)=>{const s=Ty.runKernel(kg,N,S);return r([e,t,s,n]),{value:$x(s,b),gradFunc:I}})(x,v,w)}});function Lw(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return cw(s,"float32")}Ly({hammingWindow_:function(e){return Lw(e,.54,.46)}});const zw=Ly({hannWindow_:function(e){return Lw(e,.5,.5)}});function Pw(e,t,n){if(Pd(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ry(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Py(e,t,r,n)}const Bw=Ly({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(Jv(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Mx([Jv(e,a,t-r),av([r],s)]);i.push(o),a+=n}return 0===i.length?Pw([],[0,t]):$x(Mx(i),[i.length,t])}});Ly({stft_:function(e,t,n,r,s=zw){null==r&&(r=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const a=Bw(e,t,n),i=fv(a,s(t));return ww(i,r)}});const Vw=Ly({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=Oy(e,"image","cropAndResize"),o=Oy(t,"boxes","cropAndResize","float32"),l=Oy(n,"boxInd","cropAndResize","int32"),u=o.shape[0];return Ld(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Ld(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Ld(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Ld(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Ld(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Ld("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),Ty.runKernel(af,{image:i,boxes:o,boxInd:l},{method:s,extrapolationValue:a,cropSize:r})}}),Ww=Ly({flipLeftRight_:function(e){const t=Oy(e,"image","flipLeftRight","float32");return Ld(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Ty.runKernel(Tf,{image:t},{})}}),Uw=Ly({rotateWithOffset_:function(e,t,n=0,r=.5){const s=Oy(e,"image","rotateWithOffset","float32");return Ld(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),Ty.runKernel(wg,{image:s},{radians:t,fillValue:n,center:r})}});function Hw(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Ld(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Ld(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Ld(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Ld(1===t.rank,()=>"scores must be a 1D tensor"),Ld(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Ld(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Gw=Ly({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Oy(e,"boxes","nonMaxSuppression"),i=Oy(t,"scores","nonMaxSuppression"),o=Hw(a,i,n,r,s);return Ty.runKernel(fm,{boxes:a,scores:i},{maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold})}});function jw(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||qw)}(e,t,n);e.splice(r<0?-(r+1):r,0,t)}function qw(e,t){return e>t?1:e<t?-1:0}function Kw(e,t,n,r,s){return Yw(e,t,n,r,s,0)}function Xw(e,t,n,r,s,a){return Yw(e,t,n,r,s,0,!1,a,!0)}function Zw(e,t,n,r,s,a){return Yw(e,t,n,r,s,a,!0)}function Yw(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(ek);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let l=h.length-1;l>=i;--l){const n=Jw(e,a,h[l]);if(n>=r){o=!0;break}if(t.score=t.score*Qw(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&jw(u,t,ek))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function Jw(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,h),b=Math.min(l,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function Qw(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function ek(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function tk(){return(tk=_d(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Oy(e,"boxes","nonMaxSuppressionAsync"),i=Oy(t,"scores","nonMaxSuppressionAsync"),o=Hw(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=yield Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=Kw(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),cw(h,"int32")})).apply(this,arguments)}const nk=Ly({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Oy(e,"boxes","nonMaxSuppression"),o=Oy(t,"scores","nonMaxSuppression"),l=Hw(i,o,n,r,s,a),u=Ty.runKernel(gm,{boxes:i,scores:o},{maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}});function rk(){return(rk=_d(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Oy(e,"boxes","nonMaxSuppressionAsync"),o=Oy(t,"scores","nonMaxSuppressionAsync"),l=Hw(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=yield Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Zw(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:cw(d,"int32"),selectedScores:cw(p)}})).apply(this,arguments)}const sk=Ly({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Oy(e,"boxes","nonMaxSuppression"),o=Oy(t,"scores","nonMaxSuppression"),l=Hw(i,o,n,r,s,null),u=Ty.runKernel(mm,{boxes:i,scores:o},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a});return{selectedIndices:u[0],validOutputs:u[1]}}});function ak(){return(ak=_d(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Oy(e,"boxes","nonMaxSuppressionAsync"),o=Oy(t,"scores","nonMaxSuppressionAsync"),l=Hw(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=yield Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Xw(d,p,u,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:cw(f,"int32"),validOutputs:lx(m,"int32")}})).apply(this,arguments)}const ik=Ly({resizeBilinear_:function(e,t,n=!1,r=!1){const s=Oy(e,"images","resizeBilinear");Ld(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Ld(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Ld(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=$x(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o=Ty.runKernel(Am,{images:a},{alignCorners:n,halfPixelCenters:r,size:t});return i?$x(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),ok=Ly({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=Oy(e,"images","resizeNearestNeighbor");Ld(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Ld(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Ld("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Ld(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=$x(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o=Ty.runKernel(Em,{images:a},{alignCorners:n,halfPixelCenters:r,size:t});return i?$x(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),lk=Ly({bincount_:function(e,t,n){const r=Oy(e,"x","bincount"),s=Oy(t,"weights","bincount");return Ld("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Ld(n>=0,()=>`size must be non-negative, but got ${n}.`),Ld(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),Ty.runKernel(Up,{x:r,weights:s},{size:n})}}),uk=Ly({lessEqual_:function(e,t){let n=Oy(e,"a","lessEqual","string_or_numeric"),r=Oy(t,"b","lessEqual","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(Uf,{a:n,b:r})}}),ck=Ly({round_:function(e){const t=Oy(e,"x","round");return Ty.runKernel(Om,{x:t})}});function hk(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Ty.runKernel(Nm,{},{start:e,stop:t,step:n,dtype:r})}const dk=Ly({threshold_:function(e,t="binary",n=!1,r=.5){const s=Oy(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=fv(cw([r]),255);if(Ld(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Ld(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Ld("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Ld("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[i,o,l]=aw(s,[1,1,1],-1);const e=fv(i,.2989),t=fv(o,.587),n=fv(l,.114);u=hx(hx(e,t),n)}else u=e;"otsu"===t&&(c=function(e,t){let n,r,s,a,i,o,l=cw([-1]),u=cw([0]),c=cw([0]);for(let h=0;h<e.size-1;h++){n=Jv(e,0,h+1),r=Jv(e,h+1),i=Zx(gv(n),t),o=Zx(gv(r),t);const d=gv(fv(n,hk(0,n.size)));s=Zx(d,gv(n));const p=av(r.shape,n.size),f=hx(hk(0,r.size),p),m=fv(r,f);a=Zx(gv(m),gv(r));const g=mv(s,a),y=mv(s,a),b=fv(i,o);c=fv(fv(b,g),y);const x=lv(c,u);u=fw(x,c,u),l=fw(x,cw([h]),l)}return l}(lk(kb(ck(u),"int32"),By([]),256),a));const h=n?uk(u,c):lv(u,c);return kb(fv(h,255),"int32")}}),pk=Ly({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=Oy(e,"image","transform","float32"),o=Oy(t,"transforms","transform","float32");return Ld(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Ld(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Ld(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`),Ty.runKernel(pg,{image:i,transforms:o},{interpolation:n,fillMode:r,fillValue:s,outputShape:a})}}),fk=Ly({bandPart_:function(e,t,n){Ld(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Ld(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=Oy(e,"a","bandPart");Ld(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);if(!(t<=a))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=a),n<0&&(n=i);const o=$x(hk(0,a,1,"int32"),[-1,1]),l=hk(0,i,1,"int32"),u=mv(o,l),c=bv(uk(u,lx(+t,"int32")),uv(u,lx(-n,"int32"))),h=Lv([a,i],r.dtype);return $x(lw(dw($x(r,[-1,a,i])).map(e=>fw(c,e,h))),s)}}),mk=Ly({min_:function(e,t=null,n=!1){const r=Oy(e,"x","min");return Ty.runKernel(im,{x:r},{axis:t,keepDims:n})}}),gk=Ly({pow_:function(e,t){let n=Oy(e,"base","pow"),r=Oy(t,"exp","pow");return[n,r]=vy(n,r),Ty.runKernel(wm,{a:n,b:r})}});function yk(e,t,n=null){if(0===e.rank)return cx(e);if(1!==e.rank&&null===n)return yk($x(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return gv(cx(e),n);if(t===1/0)return pv(cx(e),n);if(t===-1/0)return mk(cx(e),n);if("euclidean"===t||2===t)return iw(gv(gk(cx(e),lx(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return pv(gv(cx(e),n[0]),n[1]-1);if(t===1/0)return pv(gv(cx(e),n[1]),n[0]);if(t===-1/0)return mk(gv(cx(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return iw(gv(Rv(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const bk=Ly({norm_:function(e,t="euclidean",n=null,r=!1){const s=yk(e=Oy(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Kd(n,e.shape);a=Tv(s.shape,t)}return $x(s,a)}}),xk=Ly({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Ld(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Ld(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=aw(e,e.shape[0],0).map(e=>ow(e,[0]));Ld(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Ty.tidy(()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=fv(gv(fv(n[t],e)),n[t]);e=mv(e,r)}return Zx(e,bk(e,"euclidean"))}));return t?lw(n,0):n}});function vk(e,t=!1){return Ty.tidy(()=>{Ld(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=sv(n),a=Ib(e);const i=Pw([[1]],[1,1]);let o=Ib(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=Ty.tidy(()=>{const t=Jv(a,[e,e],[n-e,1]),l=bk(t),u=Jv(a,[e,e],[1,1]),c=fw(lv(u,0),Pw([[-1]]),Pw([[1]])),h=mv(u,fv(c,l)),d=Zx(t,h);o=1===d.shape[0]?Ib(i):Mx([i,Jv(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Dv(Zx(Ow(c,h),l)),f=Jv(a,[e,0],[n-e,r]),m=fv(p,o),g=gw(o);if(0===e)a=mv(f,Ow(m,Ow(g,f)));else{const t=mv(f,Ow(m,Ow(g,f)));a=Mx([Jv(a,[0,0],[e,r]),t],0)}const y=gw(m),b=Jv(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=mv(b,Ow(Ow(b,o),y));else{const t=mv(b,Ow(Ow(b,o),y));s=Mx([Jv(s,[0,0],[n,e]),t],1)}return[o,a,s]}),sx([t,l,u])}return!t&&n>r&&(s=Jv(s,[0,0],[n,r]),a=Jv(a,[0,0],[r,r])),[s,a]})}const wk=Ly({qr_:function(e,t=!1){if(Ld(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return vk(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=dw($x(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];return r.forEach(e=>{const[n,r]=vk(e,t);s.push(n),a.push(r)}),[$x(lw(s,0),e.shape),$x(lw(a,0),e.shape)]}}});var kk=(()=>(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(kk||(kk={})),kk))();const Ik=Ly({computeWeightedLoss_:function(e,t,n=kk.SUM_BY_NONZERO_WEIGHTS){const r=Oy(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Oy(t,"weights","computeWeightedLoss"));const a=null==s?r:fv(r,s);if(n===kk.NONE)return a;if(n===kk.SUM)return gv(a);if(n===kk.MEAN){if(null==s)return kv(a);{const e=r.size/s.size,t=Zx(gv(a),gv(s));return e>1?Zx(t,lx(e)):t}}if(n===kk.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Zx(gv(a),lx(r.size));{const e=fv(s,zv(r.shape)),t=kb(gv(Ov(e,lx(0))),"float32");return Zx(gv(a),t)}}throw Error(`Unknown reduction: ${n}`)}});Ly({absoluteDifference_:function(e,t,n,r=kk.SUM_BY_NONZERO_WEIGHTS){const s=Oy(e,"labels","absoluteDifference"),a=Oy(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Oy(n,"weights","absoluteDifference")),zd(s.shape,a.shape,"Error in absoluteDifference: ");const o=cx(mv(s,a));return Ik(o,i,r)}}),Ly({cosineDistance_:function(e,t,n,r,s=kk.SUM_BY_NONZERO_WEIGHTS){const a=Oy(e,"labels","cosineDistance"),i=Oy(t,"predictions","cosineDistance");let o=null;null!=r&&(o=Oy(r,"weights","cosineDistance")),zd(a.shape,i.shape,"Error in cosineDistance: ");const l=lx(1),u=mv(l,gv(fv(a,i),n,!0));return Ik(u,o,s)}}),Ly({hingeLoss_:function(e,t,n,r=kk.SUM_BY_NONZERO_WEIGHTS){let s=Oy(e,"labels","hingeLoss");const a=Oy(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Oy(n,"weights","hingeLoss")),zd(s.shape,a.shape,"Error in hingeLoss: ");const o=lx(1);s=mv(fv(lx(2),s),o);const l=qv(mv(o,fv(s,a)));return Ik(l,i,r)}}),Ly({huberLoss_:function(e,t,n,r=1,s=kk.SUM_BY_NONZERO_WEIGHTS){const a=Oy(e,"labels","huberLoss"),i=Oy(t,"predictions","huberLoss");let o=null;null!=n&&(o=Oy(n,"weights","huberLoss")),zd(a.shape,i.shape,"Error in huberLoss: ");const l=lx(r),u=cx(mv(i,a)),c=Iv(u,l),h=mv(u,c),d=hx(fv(lx(.5),Rv(c)),fv(l,h));return Ik(d,o,s)}}),Ly({logLoss_:function(e,t,n,r=1e-7,s=kk.SUM_BY_NONZERO_WEIGHTS){const a=Oy(e,"labels","logLoss"),i=Oy(t,"predictions","logLoss");let o=null;null!=n&&(o=Oy(n,"weights","logLoss")),zd(a.shape,i.shape,"Error in logLoss: ");const l=lx(1),u=lx(r),c=Dv(fv(a,hv(hx(i,u)))),h=fv(mv(l,a),hv(hx(mv(l,i),u))),d=mv(c,h);return Ik(d,o,s)}});const Nk=Ly({squaredDifference_:function(e,t){let n=Oy(e,"a","squaredDifference"),r=Oy(t,"b","squaredDifference");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(ng,{a:n,b:r},{})}});Ly({meanSquaredError_:function(e,t,n,r=kk.SUM_BY_NONZERO_WEIGHTS){const s=Oy(e,"labels","meanSquaredError"),a=Oy(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Oy(n,"weights","meanSquaredError")),zd(s.shape,a.shape,"Error in meanSquaredError: ");const o=Nk(s,a);return Ik(o,i,r)}});const Sk=Ly({log1p_:function(e){const t=Oy(e,"x","log1p");return Ty.runKernel(jf,{x:t})}});Ly({sigmoidCrossEntropy_:function(e,t,n,r=0,s=kk.SUM_BY_NONZERO_WEIGHTS){let a=Oy(e,"multiClassLabels","sigmoidCrossEntropy");const i=Oy(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Oy(n,"weights","sigmoidCrossEntropy")),zd(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=lx(r),t=lx(1),n=lx(.5);a=hx(fv(a,mv(t,e)),fv(n,e))}const l=function(e,t){const n=Oy(e,"labels","sigmoidCrossEntropyWithLogits"),r=Oy(t,"logits","sigmoidCrossEntropyWithLogits");zd(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=qv(r),a=fv(r,n),i=Sk(dv(Dv(cx(r))));return hx(mv(s,a),i)}(a,i);return Ik(l,o,s)}});const Ck=Ly({logSumExp_:function(e,t=null,n=!1){const r=Oy(e,"x","logSumExp"),s=Kd(t,r.shape),a=pv(r,s,!0),i=mv(r,a),o=dv(i),l=gv(o,s),u=hv(l),c=hx($x(a,u.shape),u);if(n){const e=Tv(c.shape,s);return $x(c,e)}return c}});Ly({softmaxCrossEntropy_:function(e,t,n,r=0,s=kk.SUM_BY_NONZERO_WEIGHTS){let a=Oy(e,"onehotLabels","softmaxCrossEntropy");const i=Oy(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Oy(n,"weights","softmaxCrossEntropy")),zd(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=lx(r),t=lx(1),n=lx(a.shape[1]);a=hx(fv(a,mv(t,e)),Zx(e,n))}const l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return ox((e,t,r)=>{const s=Ck(t,[n],!0),a=mv(kb(t,"float32"),s);r([e,a]);const i=Dv(fv(a,e));return{value:gv(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=Tv(e.shape,[n]);return[fv($x(e,a),mv(kb(r,"float32"),dv(s))),fv($x(e,a),mv(dv(s),kb(r,"float32")))]}}})(e,t)}(a,i);return Ik(l,o,s)}});const Tk=Ly({sparseFillEmptyRows_:function(e,t,n,r){const s=Oy(e,"indices","sparseFillEmptyRows"),a=Oy(t,"values","sparseFillEmptyRows"),i=Oy(n,"denseShape","sparseFillEmptyRows"),o=Oy(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l=Ty.runKernel(Ym,{indices:s,values:a,denseShape:i,defaultValue:o});return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),$k=Ly({sparseReshape_:function(e,t,n){const r=Oy(e,"inputIndices","sparseReshape"),s=Oy(t,"inputShape","sparseReshape"),a=Oy(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i=Ty.runKernel(Jm,{inputIndices:r,inputShape:s,newShape:a});return{outputIndices:i[0],outputShape:i[1]}}}),Ek=Ly({sparseSegmentMean_:function(e,t,n){const r=Oy(e,"data","sparseSegmentMean"),s=Oy(t,"indices","sparseSegmentMean"),a=Oy(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);return Ty.runKernel(Qm,{data:r,indices:s,segmentIds:a})}}),_k=Ly({sparseSegmentSum_:function(e,t,n){const r=Oy(e,"data","sparseSegmentSum"),s=Oy(t,"indices","sparseSegmentSum"),a=Oy(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);return Ty.runKernel(eg,{data:r,indices:s,segmentIds:a})}}),Ak=Ly({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=Oy(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Oy(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c=Ty.runKernel(ag,{data:l,dataSplits:u},{separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o});return{nGrams:c[0],nGramsSplits:c[1]}}}),Rk=Ly({stringSplit_:function(e,t,n=!0){const r=Oy(e,"input","stringSplit","string"),s=Oy(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=Ty.runKernel(ig,{input:r,delimiter:s},{skipEmpty:n});return{indices:a[0],values:a[1],shape:a[2]}}}),Fk=Ly({stringToHashBucketFast_:function(e,t){const n=Oy(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return Ty.runKernel(og,{input:n},r)}}),Dk={flipLeftRight:Ww,resizeNearestNeighbor:ok,resizeBilinear:ik,rotateWithOffset:Uw,cropAndResize:Vw,nonMaxSuppression:Gw,nonMaxSuppressionAsync:function(e,t,n){return tk.apply(this,arguments)},nonMaxSuppressionWithScore:nk,nonMaxSuppressionWithScoreAsync:function(e,t,n){return rk.apply(this,arguments)},nonMaxSuppressionPadded:sk,nonMaxSuppressionPaddedAsync:function(e,t,n){return ak.apply(this,arguments)},threshold:dk,transform:pk},Ok={bandPart:fk,gramSchmidt:xk,qr:wk},Mk={sparseFillEmptyRows:Tk,sparseReshape:$k,sparseSegmentMean:Ek,sparseSegmentSum:_k},Lk={stringNGrams:Ak,stringSplit:Rk,stringToHashBucketFast:Fk};let zk=(()=>{class e extends ux{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Ty.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Ty.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:rx(()=>mw(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:rx(()=>mw(r).variable(!1))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;rx(()=>{const e=hx(fv(a,this.rho),fv(Rv(s),1-this.rho)),t=fv(Zx(iw(hx(i,this.epsilon)),iw(hx(a,this.epsilon))),s),n=hx(fv(i,this.rho),fv(Rv(t),1-this.rho));a.assign(e),i.assign(n);const o=hx(fv(t,-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(sx(this.accumulatedGrads.map(e=>e.variable)),sx(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return _d(function*(){const t=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return _d(function*(){const n=(e=yield t.extractIterations(e)).length/2;t.accumulatedGrads=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedUpdates=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}return e.className="Adadelta",e})();ex(zk);let Pk=(()=>{class e extends ux{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Ty.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:rx(()=>av(r.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;rx(()=>{const e=hx(a,Rv(s));a.assign(e);const t=hx(fv(Zx(s,iw(hx(e,Ty.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&sx(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return _d(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return _d(function*(){e=yield t.extractIterations(e),t.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}return e.className="Adagrad",e})();ex(Pk);let Bk=(()=>{class e extends ux{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],rx(()=>{this.accBeta1=lx(t).variable(),this.accBeta2=lx(n).variable()}),null==r&&(this.epsilon=Ty.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);rx(()=>{const n=mv(1,this.accBeta1),r=mv(1,this.accBeta2);t.forEach((t,s)=>{const a=Ty.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:rx(()=>mw(a).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:rx(()=>mw(a).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=hx(fv(o,this.beta1),fv(i,1-this.beta1)),c=hx(fv(l,this.beta2),fv(Rv(i),1-this.beta2)),h=Zx(u,n),d=Zx(c,r);o.assign(u),l.assign(c);const p=hx(fv(Zx(h,hx(iw(d),this.epsilon)),-this.learningRate),a);a.assign(p)}),this.accBeta1.assign(fv(this.accBeta1,this.beta1)),this.accBeta2.assign(fv(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&sx(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&sx(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return _d(function*(){const t=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return _d(function*(){e=yield t.extractIterations(e),rx(()=>{t.accBeta1.assign(gk(t.beta1,t.iterations_+1)),t.accBeta2.assign(gk(t.beta2,t.iterations_+1))});const n=e.length/2;t.accumulatedFirstMoment=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedSecondMoment=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}return e.className="Adam",e})();ex(Bk);let Vk=(()=>{class e extends ux{constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],rx(()=>{this.iteration=lx(0).variable(),this.accBeta1=lx(t).variable()}),null==r&&(this.epsilon=Ty.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);rx(()=>{const n=mv(1,this.accBeta1),r=Zx(-this.learningRate,hx(fv(this.iteration,this.decay),1));t.forEach((t,s)=>{const a=Ty.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:mw(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:mw(a).variable(!1)});const i=Array.isArray(e)?e[s].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=hx(fv(o,this.beta1),fv(i,1-this.beta1)),c=fv(l,this.beta2),h=cx(i),d=wv(c,h);o.assign(u),l.assign(d);const p=hx(fv(Zx(r,n),Zx(u,hx(d,this.epsilon))),a);a.assign(p)}),this.iteration.assign(hx(this.iteration,1)),this.accBeta1.assign(fv(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&sx(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&sx(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return _d(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return _d(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}return e.className="Adamax",e})();ex(Vk);let Wk=(()=>{class e extends ux{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Ty.registeredVariables[t];rx(()=>{const e=hx(fv(this.c,r),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ax(lx(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return _d(function*(){return[yield e.saveIterations()]})()}setWeights(e){var t=this;return _d(function*(){if(0!==(e=yield t.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}return e.className="SGD",e})();ex(Wk);let Uk=(()=>{class e extends Wk{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=lx(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Ty.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:rx(()=>mw(r).variable(e))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&rx(()=>{let e;const t=hx(fv(this.m,s),a);e=hx(fv(this.c,this.useNesterov?hx(a,fv(t,this.m)):t),r),s.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&sx(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return _d(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return _d(function*(){e=yield t.extractIterations(e),t.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}return e.className="Momentum",e})();ex(Uk);let Hk=(()=>{class e extends ux{constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Ty.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Ty.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:rx(()=>mw(r).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:rx(()=>mw(r).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:rx(()=>mw(r).variable(s))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;rx(()=>{const e=hx(fv(i,this.decay),fv(Rv(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=hx(fv(t,this.decay),fv(a,1-this.decay)),l=Zx(fv(a,this.learningRate),iw(mv(e,hx(Rv(s),this.epsilon)))),u=hx(fv(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=mv(r,u);r.assign(c)}else{const e=hx(fv(i,this.decay),fv(Rv(a),1-this.decay)),t=hx(fv(o,this.momentum),Zx(fv(a,this.learningRate),iw(hx(e,this.epsilon))));i.assign(e),o.assign(t);const n=mv(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&sx(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&sx(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&sx(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return _d(function*(){const t=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&t.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return _d(function*(){e=yield t.extractIterations(e);const n=t.centered?e.length/3:e.length/2,r=!1;t.accumulatedMeanSquares=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})),t.accumulatedMoments=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})),t.centered&&(t.accumulatedMeanGrads=e.slice(2*n,3*n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}return e.className="RMSProp",e})();ex(Hk);class Gk{static sgd(e){return new Wk(e)}static momentum(e,t,n=!1){return new Uk(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Hk(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Bk(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new zk(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Vk(e,t,n,r,s)}static adagrad(e,t=.1){return new Pk(e,t)}}const jk={sgd:Gk.sgd,momentum:Gk.momentum,adadelta:Gk.adadelta,adagrad:Gk.adagrad,rmsprop:Gk.rmsprop,adamax:Gk.adamax,adam:Gk.adam},qk="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Kk(){return new Promise(e=>qk(()=>e()))}function Xk(e,t){const n=e[0].length;e.forEach((e,t)=>{Ld(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Ld(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let a=0;a<n;a++)Ld(a===t||e[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Zk(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}const Yk=30;function Jk(e){return e<=Yk?e:ap(e,Math.floor(Math.sqrt(e)))}function Qk(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function eI(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function tI(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function nI(e,t,n,r=!0){const s=[];s.push(r?e[0]/n:e[0]*n);for(let a=1;a<e.length;++a)s.push(a<=t.length?r?t[a-1]*e[a]:e[a]/t[a-1]:e[a]);return s}function rI(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function sI(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function aI(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Vd(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,l=s.slice();l.pop();let u=1;for(let h=a;h<n;++h)u*=o[h],l.push(o[h]);const c=[...ip(e.shape).map(e=>e/u),1].slice(0,a);return[l,i,u,c]}function iI(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function oI(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}iI(n,t,e)}function lI(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let l=s;l<a;++l)i*=n[l];const o=s<1?1:s;return{sliceRank:s,numUpdates:Vd(t.shape)/o,sliceSize:i,strides:[...ip(n.slice(0,s)),1],outputSize:Vd(n)}}const uI=1.7580993408473768,cI=1.0507009873554805,hI=.3275911,dI=.254829592,pI=-.284496736,fI=1.421413741,mI=-1.453152027,gI=1.061405429;function yI(...e){bp().getBool("IS_TEST")||console.warn(...e)}function bI(...e){bp().getBool("IS_TEST")||console.log(...e)}function xI(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function vI(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function wI(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function kI(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function II(e,t){return{real:e[2*t],imag:e[2*t+1]}}function NI(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function SI(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function CI(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const TI=/->/g;function $I(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(TI,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=e.split("->");Ld(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const a=r.split(","),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!a.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===o.indexOf(e)&&","!==e&&o.push(e)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let e=0;e<a[h].length;++e)l[h].push(o.indexOf(a[h][e]))}const u=o.length,c=[];for(let h=s.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function EI(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function _I(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Ld(r[t[s][n]]===e[n],()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function AI(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=FI(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function RI(e){return e.every((e,t)=>e===t)}function FI(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function DI(e,t,n=0){let r=[];if("number"==typeof t)Ld(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{Ld(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const r=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-r}Ld(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function OI(e,t){let n,r=!1;for(e<=Yk?(n=e,r=!0):n=ap(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=ap(e,n+1);return n}function MI(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)r.push(a!==t?e[a]:n);return r}function LI(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function zI(e){try{return e.map(e=>Yg(e))}catch(_j){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${_j}`)}}function PI(e){return e.map(e=>Zg(e))}function BI(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=wb(e,"int32"),s=wb([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]);s.values.set(t,a*e.length)}return s.toTensor()}const VI={kernelName:Ip,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,Cw(kb(n,"float32"),-1))}}},WI={kernelName:Np,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Rv(kb(n,"float32")),r=iw(mv(lx(1),t));return Dv(Zx(e,r))}}}},UI={kernelName:Sp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=iw(mv(Rv(kb(n,"float32")),1));return Zx(e,t)}}}},HI={kernelName:Cp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{let t=e;const r=Qx(n.shape,s);return r.length>0&&(t=gv(t,r)),$x(t,n.shape)},b:()=>{let t=e;const n=Qx(r.shape,s);return n.length>0&&(t=gv(t,n)),$x(t,r.shape)}}}},GI={kernelName:Tp,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}},jI={kernelName:_p,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mw(n)}}},qI={kernelName:Ap,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>mw(n)}}},KI={kernelName:Rp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,iw(mv(lx(1),Rv(kb(n,"float32")))))}}},XI={kernelName:Fp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=iw(hx(lx(1),Rv(kb(n,"float32"))));return Zx(e,t)}}}},ZI={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{const t=hx(Rv(n),Rv(r));let a=fv(e,Zx(r,t));const i=Qx(n.shape,s);return i.length>0&&(a=gv(a,i)),$x(a,n.shape)},b:()=>{const t=hx(Rv(n),Rv(r));let a=Dv(fv(e,Zx(n,t)));const i=Qx(r.shape,s);return i.length>0&&(a=gv(a,i)),$x(a,r.shape)}}}},YI={kernelName:Dp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,hx(Rv(kb(n,"float32")),1))}}},JI={kernelName:Op,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,mv(lx(1),Rv(kb(n,"float32"))))}}},QI=Ly({avgPool3dGrad_:function(e,t,n,r,s,a){const i=Oy(e,"dy","avgPool3dGrad"),o=Oy(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=$x(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=$x(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ld(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Ld(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),null!=a&&Ld(Ud(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const h=Ty.runKernel(Bp,{dy:l,input:u},{filterSize:n,strides:r,pad:s,dimRoundingMode:a});return c?$x(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),eN={kernelName:Pp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>QI(e,r,s,a,i,o)}}},tN=Ly({avgPoolGrad_:function(e,t,n,r,s){const a=Oy(e,"dy","avgPoolGrad"),i=Oy(t,"input","avgPoolGrad");Ld(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=$x(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=$x(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ld(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Ld(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=Ty.runKernel(zp,{dy:l,input:o},{filterSize:n,strides:r,pad:s});return u?$x(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),nN={kernelName:Lp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>tN(e,r,s,a,i)}}},rN={kernelName:Vp,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>Ow(e,s,!1,!1),b:()=>Ow(e,r,!0,!1)}:a&&!i?{a:()=>Ow(s,e,!1,!0),b:()=>Ow(r,e,!1,!1)}:{a:()=>Ow(s,e,!0,!0),b:()=>Ow(e,r,!0,!0)}:{a:()=>Ow(e,s,!1,!0),b:()=>Ow(r,e,!0,!1)}}},sN=Ly({spaceToBatchND_:function(e,t,n){const r=Oy(e,"x","spaceToBatchND");return Ld(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Ld(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Ld(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Ty.runKernel(Km,{x:r},{blockShape:t,paddings:n})}}),aN={kernelName:Wp,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>sN(e,r,s)}}},iN={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n.inputShape,s=n.shape,a=Array.from(s);for(let o=r.length-1;o>=0;o--)if(r[o]===s[o])a[o]=1;else if(1!==r[o])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const i=[];for(let o=0;o<a.length;o++)a[o]>1&&i.push(o);return{x:()=>gv(e,i,!0)}}},oN={kernelName:Hp,gradFunc:e=>({x:()=>e.clone()})},lN={kernelName:Gp,gradFunc:e=>({x:()=>mw(e)})},uN={kernelName:jp,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>fw(bv(uv(r,s),uk(r,a)),e,mw(e))}}},cN={kernelName:Kp,inputsToSave:["x"],gradFunc:VI.gradFunc},hN={kernelName:Xp,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(e=>e.shape),{axis:s}=n,a=Kd(s,t[0].shape)[0],i=r.map(e=>e[a]);return aw(e,i,a).map(e=>()=>e)}},dN={kernelName:Zp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Ld(Sx(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>Ux(r.shape,e,s,i,o,l),filter:()=>Nw(r,e,s.shape,i,o,l)}}},pN={kernelName:Jp,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Vx(e,s,a,i,o,1,l),filter:()=>Nw(e,r,s.shape,a,i,o,l)}}},fN=Ly({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=$x(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;return 4===i.rank&&(i=$x(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Ld(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Ld(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Ld(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Ld(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Ld(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`),Ty.runKernel(ef,{x:a,dy:i},{strides:r,pad:s,filterShape:n})}}),mN={kernelName:Qp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Ld(Sx(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>jx(i.shape,e,o,s,a),filter:()=>fN(i,e,o.shape,s,a)}}},gN=Ly({sin_:function(e){const t=Oy(e,"x","sin");return Ty.runKernel(Vm,{x:t})}}),yN={kernelName:nf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(Dv(gN(kb(n,"float32"))),e)}}},bN=Ly({sinh_:function(e){const t=Oy(e,"x","sinh");return Ty.runKernel(Wm,{x:t})}}),xN={kernelName:rf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(bN(kb(n,"float32")),e)}}},vN=Ly({cumsum_:function(e,t=0,n=!1,r=!1){const s=Oy(e,"x","cumsum");return Ty.runKernel(sf,{x:s},{axis:t,exclusive:n,reverse:r})}}),wN={kernelName:sf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Ev([s],r.rank);let n=vN(e,s,a,!i);return null!=t&&(n=gw(n,t)),n}}}},kN={kernelName:uf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Ld(Sx(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return Ld(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Ld(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Ld(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Ld(Cx(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),null!=i&&Ld(Ud(a),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`),{x:()=>Fw(l.shape,e,u,s,a,r,i),filter:()=>Rw(l,e,u.shape,s,a,r,i)}}},IN={kernelName:pf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>Ty.runKernel(ff,a,n),filter:()=>Ty.runKernel(mf,i,n)}}},NN={kernelName:bf,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Ty.runKernel(xf,r)}}},SN={kernelName:vf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=fv(dv(Dv(Rv(n))),2/Math.sqrt(Math.PI));return{x:()=>fv(e,r)}}},CN={kernelName:kf,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,n)}}},TN={kernelName:If,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>$x(e,n.shape)}}},$N={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,dv(n))}}},EN={kernelName:$f,gradFunc:e=>({x:()=>mw(e)})},_N={kernelName:Ef,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{const t=Zx(e,kb(r,"float32")),a=Qx(n.shape,s);return a.length>0?$x(gv(t,a),n.shape):t},b:()=>{let t=fv(e,kb(n,"float32"));const a=Qx(r.shape,s);a.length>0&&(t=$x(gv(t,a),r.shape));const i=Rv(r);return Dv(Zx(t,kb(i,"float32")))}}}},AN=Ly({rsqrt_:function(e){const t=Oy(e,"x","rsqrt");return Ty.runKernel(Mm,{x:t})}}),RN={kernelName:_f,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?lx(1):o,u=Qx(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=mv(s,a),d=fv(e,l),p=AN(hx(i,lx(r))),f=fv(fv(fv(p,p),p),lx(-.5));return{x:()=>$x(fv(fv(e,1===a.rank?rv($x(p,[1,1,1,a.shape[0]]),c):p),l),s.shape),mean:()=>{let e=fv(fv(p,lx(-1)),d);return 1===a.rank&&(e=gv(e,u)),$x(e,a.shape)},variance:()=>{let e=fv(fv(f,h),d);return 1===a.rank&&(e=gv(e,u)),$x(e,a.shape)},scale:()=>{const t=fv(h,p);let n=fv(e,t);return 1===a.rank&&(n=gv(n,u)),$x(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=gv(t,u)),$x(t,a.shape)}}}},FN=Ly({unsortedSegmentSum_:function(e,t,n){const r=Oy(e,"x","unsortedSegmentSum"),s=Oy(t,"segmentIds","unsortedSegmentSum","int32");return Ld(Ud(n),()=>"numSegments must be of dtype int"),Ty.runKernel(yg,{x:r,segmentIds:s},{numSegments:n})}}),DN={kernelName:Af,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a}=n,i=Kd(a,r.shape)[0];return{x:()=>{const t=r.shape,n=s.size,o=t.slice(0,i),l=o.length,u=t.slice(a,t.length).slice(1),c=u.length,h=ON(0,l),d=ON(l+1,l+1+c),p=MN([o,[n],u]),f=$x(e,p),m=$x(s,[n]),g=MN([[l],h,d]),y=gw(f,g);let b=FN(y,m,r.shape[i]);const x=_v(g);return b=gw(b,x),b},indices:()=>s}}};function ON(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function MN(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const LN={kernelName:Df,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>mw(n),b:()=>mw(r)}}},zN={kernelName:Of,gradFunc:e=>({x:()=>kb(e,"float32")})},PN={kernelName:zf,gradFunc:e=>({x:()=>mw(e)})},BN={kernelName:Pf,gradFunc:e=>({x:()=>mw(e)})},VN={kernelName:Bf,gradFunc:e=>({x:()=>mw(e)})},WN={kernelName:Vf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=lv(r,0);return{x:()=>fw(a,e,fv(e,s))}}},UN={kernelName:jf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,hx(n,1))}}},HN={kernelName:Gf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,kb(n,"float32"))}}},GN={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=dv(r);return mv(e,fv(gv(e,s,!0),t))}}}},jN=Ly({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){return Ty.runKernel(Yf,{x:e,y:t,dy:n},{depthRadius:r,bias:s,alpha:a,beta:i})}}),qN={kernelName:Zf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>jN(r,s,e,a,i,o,l)}}};function KN(e,t,n,r){return t.rank<n.rank&&(t=$x(t,Tv(t.shape,r))),e.rank<n.rank&&(e=$x(e,Tv(e.shape,r))),{x:()=>fv(e,kb(tv(n,t),e.dtype))}}const XN={kernelName:Jf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=KN(e,t[1],a,Kd(s,a.shape));return{x:()=>i.x()}}},ZN=Ly({less_:function(e,t){let n=Oy(e,"a","less","string_or_numeric"),r=Oy(t,"b","less","string_or_numeric");return[n,r]=vy(n,r),ev(n.shape,r.shape),Ty.runKernel(Wf,{a:n,b:r})}}),YN={kernelName:Qf,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>fv(e,kb(uv(n,r),"float32")),b:()=>fv(e,kb(ZN(n,r),"float32"))}}},JN=Ly({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=Oy(e,"dy","maxPool3dGrad"),l=Oy(t,"input","maxPool3dGrad"),u=Oy(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=$x(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=$x(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=$x(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Ld(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Ld(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Ld(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=i&&Ld(Ud(a),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`);const f=Ty.runKernel(rm,{dy:c,input:h,output:d},{filterSize:r,strides:s,pad:a,dimRoundingMode:i});return p?$x(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),QN={kernelName:nm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>JN(e,r,s,a,i,o,l)}}},eS=Ly({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=Oy(e,"dy","maxPoolGrad"),l=Oy(t,"input","maxPoolGrad"),u=Oy(n,"output","maxPoolGrad");return Ld(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Ld(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Ld(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),null!=i&&Ld(Ud(a),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`),Ty.runKernel(tm,{dy:o,input:l,output:u},{filterSize:r,strides:s,pad:a,dimRoundingMode:i})}}),tS={kernelName:em,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>eS(e,r,s,a,i,o)}}},nS={kernelName:am,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Kd(s,r.shape),i=Vd(Cv(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach(e=>{t[e]=1});const n=$x(e,t);return Zx(fv(n,zv(r.shape,"float32")),i)}}}},rS={kernelName:im,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=KN(e,i,a,Kd(s,a.shape));return{x:()=>o.x()}}},sS={kernelName:om,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>fv(e,kb(uk(n,r),"float32")),b:()=>fv(e,kb(lv(n,r),"float32"))}}},aS={kernelName:lm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>Jv(e,a,r.shape)}}},iS={kernelName:um,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{const t=Qx(n.shape,s);return t.length>0?$x(gv(e,t),n.shape):e},b:()=>{const t=fv(e,Dv(iv(Zx(n,r)))),a=Qx(r.shape,s);return a.length>0?$x(gv(t,a),r.shape):t}}}},oS={kernelName:hm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{const t=fv(e,kb(r,"float32")),a=Qx(n.shape,s);return a.length>0?$x(gv(t,a),n.shape):t},b:()=>{const t=fv(e,kb(n,"float32")),a=Qx(r.shape,s);return a.length>0?$x(gv(t,a),r.shape):t}}}},lS={kernelName:dm,gradFunc:e=>({x:()=>Dv(e)})},uS={kernelName:bm,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Lv(n.shape,"float32")}}},cS={kernelName:ym,gradFunc:e=>({x:()=>mw(e)})},hS={kernelName:xm,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return dw(e,r).map(e=>()=>e)}},dS={kernelName:vm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>Jv(e,a,r.shape)}}},pS={kernelName:wm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=ev(a.shape,i.shape);return{a:()=>{const t=kb(i,"float32");let n=fv(e,fv(t,gk(a,mv(t,lx(1)))));const r=Qx(a.shape,o);return r.length>0&&(n=gv(n,r)),$x(n,a.shape)},b:()=>{const t=lv(a,0),n=fw(t,hv(a),mw(a));let r=fv(e,fv(s,n));const l=Qx(i.shape,o);return l.length>0&&(r=gv(r,l)),$x(r,i.shape)}}}},fS={kernelName:km,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=lv(n,0);return{x:()=>fw(s,e,fv(e,r)),alpha:()=>{let t=fw(s,mw(e),fv(e,n));const a=Qx(r.shape,e.shape);return a.length>0&&(t=gv(t,a)),$x(t,r.shape)}}}},mS={kernelName:gf,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{const t=Zx(e,kb(r,"float32")),a=Qx(n.shape,s);return a.length>0?$x(gv(t,a),n.shape):t},b:()=>{let t=fv(e,kb(n,"float32"));const a=Qx(r.shape,s);a.length>0&&(t=$x(gv(t,a),r.shape));const i=Rv(r);return Dv(Zx(t,kb(i,"float32")))}}}},gS={kernelName:Cm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,Dv(Rv(n)))}}},yS={kernelName:Fm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=fv(uk(n,6),Cw(n));return{x:()=>fv(e,kb(r,"float32"))}}},bS={kernelName:Tm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,kb(Cw(n),"float32"))}}},xS={kernelName:$m,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>$x(e,n.shape)}}},vS={kernelName:Am,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Ty.runKernel(Rm,s,n)}}},wS={kernelName:Em,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Ty.runKernel(_m,s,n)}}},kS={kernelName:Dm,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Kd(r,e.shape);return{x:()=>Kv(e,s)}}},IS={kernelName:Om,gradFunc:e=>({x:()=>mw(e)})},NS={kernelName:Mm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dv(Zx(e,fv(gk(n,1.5),2)))}}},SS=Ly({logicalNot_:function(e){const t=Oy(e,"x","logicalNot","bool");return Ty.runKernel(Kf,{x:t})}}),CS={kernelName:zm,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>kb(mw(n),"float32"),t:()=>fv(e,kb(n,e.dtype)),e:()=>fv(e,kb(SS(n),e.dtype))}}},TS={kernelName:Pm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=lv(n,lx(0)),r=lx(uI),s=lx(cI),a=fv(e,s),i=fv(fv(e,r),dv(kb(n,"float32")));return fw(t,a,i)}}}},$S={kernelName:Hm,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,fv(n,mv(lx(1),n)))}}},ES={kernelName:Um,gradFunc:e=>({x:()=>mw(e)})},_S=Ly({cos_:function(e){const t=Oy(e,"x","cos");return Ty.runKernel(nf,{x:t})}}),AS={kernelName:Vm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(_S(kb(n,"float32")),e)}}},RS=Ly({cosh_:function(e){const t=Oy(e,"x","cosh");return Ty.runKernel(rf,{x:t})}}),FS={kernelName:Wm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(RS(kb(n,"float32")),e)}}},DS={kernelName:Bm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=Zb(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Bv(e,u)}}},OS={kernelName:Zm,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=fv(e,r);return{logits:()=>mv(a,fv(gv(a,[s],!0),r))}}},MS={kernelName:Gm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,Yv(n))}}},LS=Ly({batchToSpaceND_:function(e,t,n){const r=Oy(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);return Ld(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Ld(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Ld(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),Ty.runKernel(Wp,{x:r},{blockShape:t,crops:n})}}),zS={kernelName:Km,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>LS(e,r,s)}}},PS={kernelName:Xm,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Mx(e,r)}}},BS=[VI,WI,UI,HI,GI,jI,qI,KI,XI,ZI,YI,JI,eN,nN,rN,aN,iN,oN,lN,uN,cN,hN,pN,dN,mN,yN,xN,wN,kN,IN,mS,NN,SN,CN,TN,$N,_N,EN,RN,DN,LN,zN,PN,BN,VN,WN,UN,HN,GN,qN,XN,XN,YN,QN,tS,nS,rS,sS,aS,iS,oS,lS,uS,cS,hS,dS,dS,pS,fS,gS,yS,bS,xS,vS,wS,kS,IS,NS,CS,TS,$S,ES,AS,FS,DS,OS,MS,zS,zS,PS,PS,{kernelName:jm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,fv(iw(kb(n,"float32")),2))}}},{kernelName:ng,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=lx(2);return{a:()=>fv(e,fv(s,mv(n,r))),b:()=>fv(e,fv(s,mv(r,n)))}}},{kernelName:rg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(e,fv(kb(n,"float32"),2))}}},{kernelName:xg,gradFunc:e=>({x:()=>mw(e)})},{kernelName:lg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ev(n.shape,r.shape);return{a:()=>{let t=e;const r=Qx(n.shape,s);return r.length>0&&(t=gv(t,r)),$x(t,n.shape)},b:()=>{let t=e;const n=Qx(r.shape,s);return n.length>0&&(t=gv(t,n)),$x(Dv(t),r.shape)}}}},{kernelName:qm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Kd(a,r.shape).forEach(e=>{s[e]=1});const i=$x(e,s),o=fv(i,zv(r.shape,"float32"));return{x:()=>o}}},{kernelName:ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Zx(e,Rv(_S(n)))}}},{kernelName:cg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>fv(mv(lx(1),Rv(n)),e)}}},{kernelName:hg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=mw(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=hx(t,Jv(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=hx(t,Jv(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=hx(t,Jv(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=hx(t,Jv(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:fg,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=_v(s);return{x:()=>gw(e,a)}}},{kernelName:gg,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>lw(e,s)}}},{kernelName:yg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=wv(t,mw(t)),r=ov(e,n);let s=uv(t,lx(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=nv(s,o+1);s=bv(s,zv(r.shape,"bool"));const i=mw(r);return fw(s,r,i)}(e,n)}}},{kernelName:bg,gradFunc:e=>({x:()=>mw(e)})}];for(const Aj of BS)Ag(Aj);hy().prototype.abs=function(){return this.throwIfDisposed(),cx(this)};const VS=Ly({acos_:function(e){const t=Oy(e,"x","acos");return Ty.runKernel(Np,{x:t})}});hy().prototype.acos=function(){return this.throwIfDisposed(),VS(this)};const WS=Ly({acosh_:function(e){const t=Oy(e,"x","acosh");return Ty.runKernel(Sp,{x:t})}});hy().prototype.acosh=function(){return this.throwIfDisposed(),WS(this)},hy().prototype.add=function(e){return this.throwIfDisposed(),hx(this,e)},hy().prototype.all=function(e,t){return this.throwIfDisposed(),dx(this,e,t)},hy().prototype.any=function(e,t){return this.throwIfDisposed(),px(this,e,t)},hy().prototype.argMax=function(e){return this.throwIfDisposed(),fx(this,e)};const US=Ly({argMin_:function(e,t=0){const n=Oy(e,"x","argMin");return Ty.runKernel(Ap,{x:n},{axis:t})}});hy().prototype.argMin=function(e){return this.throwIfDisposed(),US(this,e)},hy().prototype.asScalar=function(){return this.throwIfDisposed(),Ld(1===this.size,()=>"The array must have only 1 element."),$x(this,[])},hy().prototype.asType=function(e){return this.throwIfDisposed(),kb(this,e)},hy().prototype.as1D=function(){return this.throwIfDisposed(),$x(this,[this.size])},hy().prototype.as2D=function(e,t){return this.throwIfDisposed(),$x(this,[e,t])},hy().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),$x(this,[e,t,n])},hy().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),$x(this,[e,t,n,r])},hy().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),$x(this,[e,t,n,r,s])};const HS=Ly({asin_:function(e){const t=Oy(e,"x","asin");return Ty.runKernel(Rp,{x:t})}});hy().prototype.asin=function(){return this.throwIfDisposed(),HS(this)};const GS=Ly({asinh_:function(e){const t=Oy(e,"x","asinh");return Ty.runKernel(Fp,{x:t})}});hy().prototype.asinh=function(){return this.throwIfDisposed(),GS(this)};const jS=Ly({atan_:function(e){const t=Oy(e,"x","atan");return Ty.runKernel(Dp,{x:t})}});hy().prototype.atan=function(){return this.throwIfDisposed(),jS(this)};const qS=Ly({atan2_:function(e,t){let n=Oy(e,"a","atan2"),r=Oy(t,"b","atan2");return[n,r]=vy(n,r),Ty.runKernel(Mp,{a:n,b:r})}});hy().prototype.atan2=function(e){return this.throwIfDisposed(),qS(this,e)};const KS=Ly({atanh_:function(e){const t=Oy(e,"x","atanh");return Ty.runKernel(Op,{x:t})}});hy().prototype.atanh=function(){return this.throwIfDisposed(),KS(this)},hy().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Ex(this,e,t,n,r)},hy().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),LS(this,e,t)},hy().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Ax(this,e,t,n,r,s)},hy().prototype.broadcastTo=function(e){return this.throwIfDisposed(),pw(this,e)},hy().prototype.cast=function(e){return this.throwIfDisposed(),kb(this,e)};const XS=Ly({ceil_:function(e){const t=Oy(e,"x","ceil");return Ty.runKernel(Gp,{x:t})}});hy().prototype.ceil=function(){return this.throwIfDisposed(),XS(this)},hy().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Ox(this,e,t)},hy().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof cy&&(e=[e]),Mx([this,...e],t)},hy().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Wx(this,e,t,n,r,s,a)},hy().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Hx(this,e,t,n,r,s)},hy().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Vx(this,e,t,n,r,s,a)},hy().prototype.cos=function(){return this.throwIfDisposed(),_S(this)},hy().prototype.cosh=function(){return this.throwIfDisposed(),RS(this)},hy().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),vN(this,e,t,n)};const ZS=Ly({depthToSpace_:function(e,t,n="NHWC"){const r=Oy(e,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return Ld(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Ld(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Ld(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),Ty.runKernel(lf,{x:r},{blockSize:t,dataFormat:n})}});hy().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),ZS(this,e,t)},hy().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Kx(this,e,t,n,r,s,a)};const YS=Ly({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=Oy(e,"x","dilation2d"),o=Oy(t,"filter","dilation2d");Ld(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Ld(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Ld("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;3===i.rank&&(l=$x(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);const c=Ty.runKernel(pf,{x:l,filter:o},{strides:n,pad:r,dilations:s});return u?$x(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});hy().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),YS(this,e,t,n,r,s)};const JS=Ly({divNoNan_:function(e,t){let n=Oy(e,"a","div"),r=Oy(t,"b","div");[n,r]=vy(n,r);const s=Zx(n,r),a=mw(s),i=tv(r,a);return fw(i,a,s)}});hy().prototype.divNoNan=function(e){return this.throwIfDisposed(),JS(this,e)},hy().prototype.div=function(e){return this.throwIfDisposed(),Zx(this,e)};const QS=Ly({dot_:function(e,t){const n=Oy(e,"t1","dot"),r=Oy(t,"t2","dot");Ld(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Ld(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),1===n.rank&&1===r.rank){const e=$x(n,[1,-1]),t=$x(r,[-1,1]),s=Ow(e,t);return $x(s,[])}if(1===n.rank&&2===r.rank){const e=$x(n,[1,-1]),t=$x(r,[r.shape[0],r.shape[1]]),s=Ow(e,t);return $x(s,[s.size])}if(2===n.rank&&1===r.rank){const e=$x(r,[-1,1]),t=Ow(n,e);return $x(t,[t.size])}{const e=$x(r,[r.shape[0],r.shape[1]]);return Ow(n,e)}}});hy().prototype.dot=function(e){return this.throwIfDisposed(),QS(this,e)},hy().prototype.elu=function(){return this.throwIfDisposed(),Yx(this)},hy().prototype.equal=function(e){return this.throwIfDisposed(),tv(this,e)};const eC=Ly({erf_:function(e){let t=Oy(e,"x","erf");return Ld("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=kb(t,"float32")),Ty.runKernel(vf,{x:t})}});hy().prototype.erf=function(){return this.throwIfDisposed(),eC(this)},hy().prototype.exp=function(){return this.throwIfDisposed(),dv(this)},hy().prototype.expandDims=function(e){return this.throwIfDisposed(),nv(this,e)};const tC=Ly({expm1_:function(e){const t=Oy(e,"x","expm1");return Ty.runKernel(Nf,{x:t})}});hy().prototype.expm1=function(){return this.throwIfDisposed(),tC(this)},hy().prototype.fft=function(){return this.throwIfDisposed(),vw(this)},hy().prototype.flatten=function(){return this.throwIfDisposed(),$x(this,[this.size])},hy().prototype.floor=function(){return this.throwIfDisposed(),iv(this)},hy().prototype.floorDiv=function(e){return this.throwIfDisposed(),Xx(this,e)},hy().prototype.gather=function(e,t){return this.throwIfDisposed(),ov(this,e,t)},hy().prototype.greaterEqual=function(e){return this.throwIfDisposed(),uv(this,e)},hy().prototype.greater=function(e){return this.throwIfDisposed(),lv(this,e)},hy().prototype.ifft=function(){return this.throwIfDisposed(),kw(this)},hy().prototype.irfft=function(){return this.throwIfDisposed(),Iw(this)};const nC=Ly({isFinite_:function(e){const t=Oy(e,"x","isFinite");return Ty.runKernel(zf,{x:t})}});hy().prototype.isFinite=function(){return this.throwIfDisposed(),nC(this)};const rC=Ly({isInf_:function(e){const t=Oy(e,"x","isInf");return Ty.runKernel(Pf,{x:t})}});hy().prototype.isInf=function(){return this.throwIfDisposed(),rC(this)};const sC=Ly({isNaN_:function(e){const t=Oy(e,"x","isNaN");return Ty.runKernel(Bf,{x:t})}});hy().prototype.isNaN=function(){return this.throwIfDisposed(),sC(this)},hy().prototype.leakyRelu=function(e){return this.throwIfDisposed(),cv(this,e)},hy().prototype.lessEqual=function(e){return this.throwIfDisposed(),uk(this,e)},hy().prototype.less=function(e){return this.throwIfDisposed(),ZN(this,e)};const aC=Ly({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=Oy(e,"x","localResponseNormalization");Ld(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),Ld(Ud(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;3===a.rank&&(o=!0,i=$x(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l=Ty.runKernel(Zf,{x:i},{depthRadius:t,bias:n,alpha:r,beta:s});return o?$x(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});hy().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),aC(this,e,t,n,r)};const iC=Ly({logSigmoid_:function(e){const t=Oy(e,"x","logSigmoid");return ox(e=>({value:Dv(sw(Dv(e))),gradFunc:t=>fv(t,Yv(Dv(e)))}))(t)}});hy().prototype.logSigmoid=function(){return this.throwIfDisposed(),iC(this)},hy().prototype.logSoftmax=function(e){return this.throwIfDisposed(),yv(this,e)},hy().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ck(this,e,t)},hy().prototype.log=function(){return this.throwIfDisposed(),hv(this)},hy().prototype.log1p=function(){return this.throwIfDisposed(),Sk(this)},hy().prototype.logicalAnd=function(e){return this.throwIfDisposed(),bv(this,e)},hy().prototype.logicalNot=function(){return this.throwIfDisposed(),SS(this)};const oC=Ly({logicalOr_:function(e,t){const n=Oy(e,"a","logicalOr","bool"),r=Oy(t,"b","logicalOr","bool");return ev(n.shape,r.shape),Ty.runKernel(Xf,{a:n,b:r})}});hy().prototype.logicalOr=function(e){return this.throwIfDisposed(),oC(this,e)};const lC=Ly({logicalXor_:function(e,t){const n=Oy(e,"a","logicalXor","bool"),r=Oy(t,"b","logicalXor","bool");return ev(n.shape,r.shape),bv(oC(e,t),SS(bv(e,t)))}});hy().prototype.logicalXor=function(e){return this.throwIfDisposed(),lC(this,e)},hy().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Ow(this,e,t,n)},hy().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),xv(this,e,t,n,r)},hy().prototype.max=function(e,t){return this.throwIfDisposed(),pv(this,e,t)},hy().prototype.maximum=function(e){return this.throwIfDisposed(),wv(this,e)},hy().prototype.mean=function(e,t){return this.throwIfDisposed(),kv(this,e,t)},hy().prototype.min=function(e,t){return this.throwIfDisposed(),mk(this,e,t)},hy().prototype.minimum=function(e){return this.throwIfDisposed(),Iv(this,e)};const uC=Ly({mirrorPad_:function(e,t,n){Ld("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=Oy(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Ld(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let a=0;a<r.rank;a++)Ld(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ld(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return Ty.runKernel(lm,{x:r},{paddings:t,mode:n})}});hy().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),uC(this,e,t)};const cC=Ly({mod_:function(e,t){let n=Oy(e,"a","mod"),r=Oy(t,"b","mod");return[n,r]=vy(n,r),Ty.runKernel(um,{a:n,b:r})}});hy().prototype.mod=function(e){return this.throwIfDisposed(),cC(this,e)},hy().prototype.mul=function(e){return this.throwIfDisposed(),fv(this,e)},hy().prototype.neg=function(){return this.throwIfDisposed(),Dv(this)},hy().prototype.norm=function(e,t,n){return this.throwIfDisposed(),bk(this,e,t,n)},hy().prototype.notEqual=function(e){return this.throwIfDisposed(),Ov(this,e)},hy().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Mv(this,e,t,n)},hy().prototype.onesLike=function(){return this.throwIfDisposed(),Pv(this)},hy().prototype.pad=function(e,t){return this.throwIfDisposed(),Bv(this,e,t)};const hC=Ly({pool_:function(e,t,n,r,s,a){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const i=Oy(e,"x","maxPool");let o=i,l=!1;3===i.rank&&(l=!0,o=$x(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ld(Cx(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const u=gx(o.shape,t,a,s,r),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),s=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],s[t]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(e,t,n){const r=n.map(e=>e[0]),s=n.map(e=>e[1]),a=e.concat(r,s),i=t.map((e,t)=>(e-a[t]%e)%e),o=s.map((e,t)=>e+i[t]);return[t.map((e,t)=>[r[t],o[t]]),t.map((e,t)=>[0,i[t]])]}([u.inHeight,u.inWidth],c,h),m=d?r:"valid",g=d?o:sN(o,c,p),y=("avg"===n?()=>Ex(g,t,a,m):()=>xv(g,t,a,m))(),b=d?y:LS(y,c,f);return l?$x(b,[b.shape[1],b.shape[2],b.shape[3]]):b}});hy().prototype.pool=function(e,t,n,r,s){return this.throwIfDisposed(),hC(this,e,t,n,r,s)},hy().prototype.pow=function(e){return this.throwIfDisposed(),gk(this,e)},hy().prototype.prelu=function(e){return this.throwIfDisposed(),Vv(this,e)};const dC=Ly({prod_:function(e,t=null,n=!1){let r=Oy(e,"x","prod");return"bool"===r.dtype&&(r=kb(r,"int32")),Ty.runKernel(Im,{x:r},{axis:t,keepDims:n})}});hy().prototype.prod=function(e,t){return this.throwIfDisposed(),dC(this,e,t)};const pC=Ly({reciprocal_:function(e){const t=Oy(e,"x","reciprocal");return Ty.runKernel(Cm,{x:t})}});hy().prototype.reciprocal=function(){return this.throwIfDisposed(),pC(this)},hy().prototype.relu=function(){return this.throwIfDisposed(),qv(this)},hy().prototype.relu6=function(){return this.throwIfDisposed(),Sw(this)},hy().prototype.reshapeAs=function(e){return this.throwIfDisposed(),$x(this,e.shape)},hy().prototype.reshape=function(e){return this.throwIfDisposed(),$x(this,e)},hy().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),ik(this,e,t,n)},hy().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),ok(this,e,t,n)},hy().prototype.reverse=function(e){return this.throwIfDisposed(),Kv(this,e)},hy().prototype.rfft=function(){return this.throwIfDisposed(),ww(this)},hy().prototype.round=function(){return this.throwIfDisposed(),ck(this)},hy().prototype.rsqrt=function(){return this.throwIfDisposed(),AN(this)},hy().prototype.selu=function(){return this.throwIfDisposed(),Xv(this)},hy().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Zv(this,e,t,n,r,s,a)},hy().prototype.sigmoid=function(){return this.throwIfDisposed(),Yv(this)};const fC=Ly({sign_:function(e){const t=Oy(e,"x","sign");return Ty.runKernel(Um,{x:t})}});hy().prototype.sign=function(){return this.throwIfDisposed(),fC(this)},hy().prototype.sin=function(){return this.throwIfDisposed(),gN(this)},hy().prototype.sinh=function(){return this.throwIfDisposed(),bN(this)},hy().prototype.slice=function(e,t){return this.throwIfDisposed(),Jv(this,e,t)},hy().prototype.softmax=function(e){return this.throwIfDisposed(),rw(this,e)},hy().prototype.softplus=function(){return this.throwIfDisposed(),sw(this)},hy().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),sN(this,e,t)},hy().prototype.split=function(e,t){return this.throwIfDisposed(),aw(this,e,t)},hy().prototype.sqrt=function(){return this.throwIfDisposed(),iw(this)},hy().prototype.square=function(){return this.throwIfDisposed(),Rv(this)},hy().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Nk(this,e)},hy().prototype.squeeze=function(e){return this.throwIfDisposed(),ow(this,e)},hy().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof cy?[this,e]:[this,...e];return lw(n,t)},hy().prototype.step=function(e){return this.throwIfDisposed(),Cw(this,e)};const mC=Ly({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u=Oy(e,"x","stridedSlice","string_or_numeric");return Ty.runKernel(sg,{x:u},{begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l})}});hy().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),mC(this,e,t,n,r,s,a,i,o)},hy().prototype.sub=function(e){return this.throwIfDisposed(),mv(this,e)},hy().prototype.sum=function(e,t){return this.throwIfDisposed(),gv(this,e,t)};const gC=Ly({tan_:function(e){const t=Oy(e,"x","tan");return Ty.runKernel(ug,{x:t})}});hy().prototype.tan=function(){return this.throwIfDisposed(),gC(this)},hy().prototype.tanh=function(){return this.throwIfDisposed(),uw(this)},hy().prototype.tile=function(e){return this.throwIfDisposed(),rv(this,e)},hy().prototype.toBool=function(){return this.throwIfDisposed(),kb(this,"bool")},hy().prototype.toFloat=function(){return this.throwIfDisposed(),kb(this,"float32")},hy().prototype.toInt=function(){return this.throwIfDisposed(),kb(this,"int32")};const yC=Ly({topk_:function(e,t=1,n=!0){const r=Oy(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=Ty.runKernel(dg,a,i);return{values:o,indices:l}}});hy().prototype.topk=function(e,t){return this.throwIfDisposed(),yC(this,e,t)},hy().prototype.transpose=function(e){return this.throwIfDisposed(),gw(this,e)};const bC=Ly({unique_:function(e,t=0){const n=Oy(e,"x","unique","string_or_numeric");Ld(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=Ty.runKernel(mg,r,s);return{values:a,indices:i}}});let xC;function vC(){return null==xC&&(xC=Ty.backend.epsilon()),xC}hy().prototype.unique=function(e){return this.throwIfDisposed(),bC(this,e)},hy().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),FN(this,e,t)},hy().prototype.unstack=function(e){return this.throwIfDisposed(),dw(this,e)},hy().prototype.where=function(e,t){return this.throwIfDisposed(),fw(e,this,t)},hy().prototype.zerosLike=function(){return this.throwIfDisposed(),mw(this)};class wC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wC.prototype)}}class kC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kC.prototype)}}class IC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IC.prototype)}}class NC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NC.prototype)}}class SC extends Error{constructor(e){super(e),Object.setPrototypeOf(this,SC.prototype)}}function CC(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function TC(e,t){if(!e)throw new SC(t)}function $C(e,t){let n=0;for(const r of e)r===t&&n++;return n}function EC(e){return 1===e.length?e[0]:e}function _C(e){return Array.isArray(e)?e:[e]}function AC(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function RC(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}Error;let FC={};function DC(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function OC(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>OC(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?OC(t):e[n]=t.value)}}}function MC(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in FC)a=FC[s];else if(a=t[s],null==a)throw new IC(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new IC(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in FC?[o,l]=FC.className:i in t&&([o,l]=t[i]),null==o)throw new IC(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(FC))e[n]=FC[n];for(const s of Object.keys(n))e[s]=n[s];a.config.customObjects=e;const t=Object.assign({},FC);for(const s of Object.keys(n))FC[s]=n[s];OC(a.config);const r=l(o,a.config,n,s);return FC=Object.assign({},t),r}{const e=Object.assign({},FC);for(const r of Object.keys(n))FC[r]=n[r];const t=new o(a.config);return FC=Object.assign({},e),t}}}function LC(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function zC(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function PC(e){if(null==e)throw new IC(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function BC(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new IC(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function VC(e,t,n=0,r=1/0){return TC(n>=0),TC(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function WC(e,t){Array.isArray(e)?(Ld(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>WC(e,`element ${n+1} of ${t}`))):Ld(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${UC(e)}.`)}function UC(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>UC(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function HC(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function GC(e,t){return rx(()=>iw(gv(fv(e,e),t,!0)))}class jC extends Jb{getConfig(){return{}}}ex((()=>{class e extends jC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return rx(()=>{const t=GC(e,this.axis),n=Ox(t,0,this.maxValue);return fv(e,Zx(n,hx(vC(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return e.className="MaxNorm",e})()),ex((()=>{class e extends jC{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return rx(()=>Zx(e,hx(vC(),GC(e,this.axis))))}getConfig(){return{axis:this.axis}}}return e.className="UnitNorm",e})()),ex((()=>{class e extends jC{apply(e){return qv(e)}}return e.className="NonNeg",e})()),ex((()=>{class e extends jC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return rx(()=>{const t=GC(e,this.axis),n=hx(fv(this.rate,Ox(t,this.minValue,this.maxValue)),fv(1-this.rate,t));return fv(e,Zx(n,hx(vC(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return e.className="MinMaxNorm",e})());const qC={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function KC(e){return DC(e)}function XC(e,t={}){return MC(e,Qb.getMap().classNameMap,t,"constraint")}function ZC(e){return null==e?null:"string"==typeof e?XC({className:e in qC?qC[e]:e,config:{}}):e instanceof jC?e:XC(e)}const YC=["channelsFirst","channelsLast"],JC=["nearest","bilinear"],QC=["valid","same","causal"],eT=["max","avg"],tT=["sum","mul","concat","ave"],nT=new Map;function rT(e){BC(YC,"DataFormat",e)}function sT(e){BC(QC,"PaddingMode",e)}function aT(e){BC(eT,"PoolMode",e)}const iT=[];function oT(e,t){iT.push(e);try{const e=t();return iT.pop(),e}catch(n){throw iT.pop(),n}}function lT(e){if(!hT(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===iT.length?"":iT.join("/")+"/")+e}function uT(e){if(!hT(e))throw new Error("Not a valid tensor name: '"+e+"'");nT.has(e)||nT.set(e,0);const t=nT.get(e);if(nT.set(e,nT.get(e)+1),t>0){const n=`${e}_${t}`;return nT.set(n,1),n}return e}const cT=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function hT(e){return!!e.match(cT)}function dT(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function pT(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function fT(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function mT(e,t){if(t<e)throw new IC(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}function gT(e,t){return e.asType(t)}function yT(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function bT(e,t,n){return rx(()=>{switch(e.rank){case 1:return Qv(e,t,n);case 2:return ew(e,[t,0],[n,e.shape[1]]);case 3:return tw(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return nw(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Jv(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Jv(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new IC(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function xT(e,t,n){return rx(()=>{switch(e.rank){case 1:return Qv(e,t,n);case 2:return ew(e,[0,t],[e.shape[0],n]);case 3:return tw(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return nw(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new IC(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function vT(e,t,n,r){return rx(()=>{switch(e.rank){case 1:return Qv(e,t,n);case 2:switch(r){case 1:return bT(e,t,n);case 2:return xT(e,t,n);default:throw new IC(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return bT(e,t,n);case 2:return tw(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return xT(e,t,n);default:throw new IC(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return bT(e,t,n);case 2:return nw(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return nw(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return xT(e,t,n);default:throw new IC(`The axis is not within the rank of the tensor ${r}`)}default:throw new IC(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function wT(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Mx(e,t)}function kT(e,t){switch(e.rank){case 1:return Lx([e,t]);case 2:return zx([e,t],0);case 3:return Px([e,t],0);case 4:return Bx([e,t],0);default:throw new IC(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function IT(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new IC(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return rv(e,t)}function NT(e,t=0,n=1,r,s){return Gv(e,t,n,r,s)}function ST(e,t,n,r){if(e.rank<2||t.rank<2)throw new NC(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new NC(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return Mw({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?$T(e.rank,r,"channelsLast"):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=e.reshape([-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=t.transpose(c).reshape([l,-1]);const h=[...s,...u];return Mw({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?$T(e.rank,r,"channelsLast"):null,activation:n}).reshape(h)}}function CT(e,t,n){return rx(()=>(t=Array.isArray(t)?cw(t,"int32"):t.toInt(),ov(e,t,n)))}function TT(e){return fv(e,e)}function $T(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new IC(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(e<3)return t;throw new IC(`Unsupported input rank by biasAdd: ${t.rank}`)}function ET(e,t,n){return rx(()=>(null==n&&(n="channelsLast"),rT(n),e.add($T(e.rank,t,n))))}function _T(e,t,n,r){return rx(()=>yw(e,t,n,r))}function AT(e,t,n=!1){return n?e():t()}const RT=["fanIn","fanOut","fanAvg"],FT=["normal","uniform","truncatedNormal"];class DT extends Jb{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}ex((()=>{class e extends DT{apply(e,t){return Lv(e,t)}}return e.className="Zeros",e})());let OT=(()=>{class e extends DT{apply(e,t){return zv(e,t)}}return e.className="Ones",e})();ex(OT),ex((()=>{class e extends DT{constructor(e){if(super(),"object"!=typeof e)throw new IC(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new IC(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return rx(()=>fv(lx(this.value),zv(e,t)))}getConfig(){return{value:this.value}}}return e.className="Constant",e})()),ex((()=>{class e extends DT{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return jv(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return e.className="RandomUniform",e})()),ex((()=>{class e extends DT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NC(`randomNormal does not support dType ${t}.`);return NT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return e.className="RandomNormal",e})()),ex((()=>{class e extends DT{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NC(`truncatedNormal does not support dType ${t}.`);return hw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return e.className="TruncatedNormal",e})()),ex((()=>{class e extends DT{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return rx(()=>{if(2!==e.length||e[0]!==e[1])throw new IC("Identity matrix initializer can only be used for 2D square matrices.");return fv(this.gain,sv(e[0]))})}getConfig(){return{gain:this.gain}}}return e.className="Identity",e})());let MT=(()=>{class e extends DT{constructor(e){if(super(),e.scale<0)throw new IC(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,BC(RT,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,BC(FT,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(rT(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=dT(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=dT(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=dT(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,r):"fanOut"===this.mode?Math.max(1,s):Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NC(`${this.getClassName()} does not support dType ${t}.`);return hw(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return jv(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return e.className="VarianceScaling",e})();ex(MT);let LT=(()=>{class e extends MT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="GlorotUniform",e})();ex(LT);let zT=(()=>{class e extends MT{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="GlorotNormal",e})();ex(zT);let PT=(()=>{class e extends MT{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="HeNormal",e})();ex(PT);let BT=(()=>{class e extends MT{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="HeUniform",e})();ex(BT);let VT=(()=>{class e extends MT{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="LeCunNormal",e})();ex(VT);let WT=(()=>{class e extends MT{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return MT.className}}return e.className="LeCunNormal",e})();ex(WT),ex((()=>{class e extends DT{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new NC("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return rx(()=>{if(e.length<2)throw new NC("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=NT(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Ok.gramSchmidt(t);return e[0]>e[1]&&(n=n.transpose()),fv(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return e.className="Orthogonal",e})());const UT={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function HT(e,t={}){return MC(e,Qb.getMap().classNameMap,t,"initializer")}function GT(e){return DC(e)}function jT(e){if("string"==typeof e){const t=e in UT?UT[e]:e;if("GlorotNormal"===t)return new zT;if("GlorotUniform"===t)return new LT;if("HeNormal"===t)return new PT;if("HeUniform"===t)return new BT;if("LeCunNormal"===t)return new VT;if("LeCunUniform"===t)return new WT;{const e={};return e.className=t,e.config={},HT(e)}}return e instanceof DT?e:HT(e)}let qT=0;function KT(){return qT++}const XT={};function ZT(e=""){return e in XT||(XT[e]=0),XT[e]+=1,e+XT[e].toString()}function YT(e){return Array.isArray(e)&&Array.isArray(e[0])}function JT(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function QT(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new IC(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function e$(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new IC(`Expected exactly 1 Shape; got ${e.length}`)}return e}function t$(e){let t=0;for(const n of e)t+=0===n.shape.length?1:n.shape.reduce((e,t)=>e*t);return t}class n${constructor(e,t="float32",n="Variable",r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=KT(),this.originalName=lT(n=null==n?"Variable":n),this.name=uT(this.originalName),this.trainable_=r,this.constraint=s,this.val=function(e,t=!0,n,r){return Ty.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function r$(e){return e.map(e=>e.read())}function s$(e){e.forEach(e=>{e[0].write(e[1])})}class a${constructor(e){this.dtype=e.dtype,this.shape=e.shape,this.ndim=null!=e.shape?e.shape.length:e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class i${constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=KT(),null!=a&&(this.originalName=lT(a),this.name=uT(this.originalName)),this.rank=t.length}}let o$=0;class l${constructor(e,t){this.callArgs=t,this.id=o$++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)e.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let u$=0;class c$ extends Jb{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=u$++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=AC(e)+"_"+ZT(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=e.weights?e.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new kC(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new IC(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return EC(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return EC(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new wC(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new wC(`Layer ${this.name} is not connected, no input to return.`);return EC(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new wC(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new wC(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return EC(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=_C(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=_C(this.inputSpec);if(e.length!==t.length)throw new IC(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],s=t[n];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new IC(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new IC(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new IC(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new IC(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const e=r.shape;for(const t in s.axes){const r=Number(t),a=s.axes[t],i=r>=0?e[r]:e[e.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new IC(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${e}.`)}}if(null!=s.shape)for(let e=0;e<s.shape.length;++e){const t=s.shape[e],a=r.shape[e];if(null!=t&&null!=a&&t!==a)throw new IC(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=_C(e);let r=!0;for(const a of n)if(!(a instanceof i$)){r=!1;break}let s=!0;for(const a of n)if(a instanceof i$){s=!1;break}if(r===s)throw new IC("Arguments to apply() must be all SymbolicTensors or all Tensors");return oT(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of _C(e))t.push(n.shape);this.build(EC(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);const s=_C(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=EC(a),null!=this.activityRegularizer)throw new NC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=_C(e);const t=[];for(const n of e)t.push(n.shape);return EC(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new i$(a,n,this,_C(e),t,this.name,r)):new i$(a,r,this,_C(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new NC("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new wC(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new wC(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new kC(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return t$(this.weights)}build(e){this.built=!0}getWeights(e=!1){return r$(e?this.trainableWeights:this.weights)}setWeights(e){rx(()=>{const t=this.weights;if(t.length!==e.length)throw new IC(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=r$(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!Wd(a.shape,o.shape))throw new IC(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}s$(n)})}addWeight(e,t,n,r,s,a,i){if(-1!==this._addedWeightNames.indexOf(e))throw new IC(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=jT("zeros"));const o=r.apply(t,n),l=new n$(o,n,e,a,i);return o.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=_C(e),null!=this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}addInboundNode(e,t,n,r,s,a,i=null){const o=_C(e);t=_C(t),n=_C(n),r=_C(r),s=JT(s),a=JT(a);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new l$({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function h$(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=h$(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}let d$=(()=>{class e extends c${constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:ZT("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new IC("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new IC("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new IC("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new i$(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new l$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new IC(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return e.className="InputLayer",e})();function p$(e){return f$.apply(this,arguments)}function f$(){return(f$=_d(function*(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=yield Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];sx(r)}})).apply(this,arguments)}function m$(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}ex(d$);class g${constructor(){this.validationData=null}setParams(e){this.params=e}onEpochBegin(e,t){return _d(function*(){})()}onEpochEnd(e,t){return _d(function*(){})()}onBatchBegin(e,t){return _d(function*(){})()}onBatchEnd(e,t){return _d(function*(){})()}onTrainBegin(e){return _d(function*(){})()}onTrainEnd(e){return _d(function*(){})()}setModel(e){}}class y${constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}onEpochBegin(e,t){var n=this;return _d(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onEpochBegin(e,t)})()}onEpochEnd(e,t){var n=this;return _d(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onEpochEnd(e,t)})()}onBatchBegin(e,t){var n=this;return _d(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onBatchBegin(e,t)})()}onBatchEnd(e,t){var n=this;return _d(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onBatchEnd(e,t)})()}onTrainBegin(e){var t=this;return _d(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainBegin(e)})()}onTrainEnd(e){var t=this;return _d(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainEnd(e)})()}}class b$ extends g${constructor(){super()}onEpochBegin(e){var t=this;return _d(function*(){t.seen=0,t.totals={}})()}onBatchEnd(e,t){var n=this;return _d(function*(){null==t&&(t={});const e=null==t.size?0:t.size;n.seen+=e;for(const r in t){const s=t[r];if("number"==typeof s)n.totals.hasOwnProperty(r)||(n.totals[r]=0),n.totals[r]=n.totals[r]+s*e;else{let t;r in n.totals?t=n.totals[r]:n.totals[r]=0;const a=rx(()=>hx(n.totals[r],fv(s,e)));n.totals[r]=a,null!=t&&t.dispose()}}})()}onEpochEnd(e,t){var n=this;return _d(function*(){if(null!=t)for(const e of n.params.metrics)null!=n.totals[e]&&("number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:rx(()=>{const r=fv(Zx(1,n.seen),n.totals[e]);t[e]=r,n.totals[e].dispose(),ax(t[e])}))})()}}class x$ extends g${onTrainBegin(e){var t=this;return _d(function*(){t.epoch=[],t.history={}})()}onEpochEnd(e,t){var n=this;return _d(function*(){null==t&&(t={}),n.epoch.push(e);for(const e in t)null==n.history[e]&&(n.history[e]=[]),n.history[e].push(t[e])})()}syncData(){var e=this;return _d(function*(){const t=[],n=[],r=[];for(const a in e.history){const s=e.history[a];for(let e=0;e<s.length;++e)"number"!=typeof s[e]&&(t.push(s[e].data()),n.push(a),r.push(e))}const s=yield Promise.all(t);for(let a=0;a<s.length;++a)e.history[n[a]][r[a]].dispose(),e.history[n[a]][r[a]]=s[a][0]})()}}class v$ extends g${constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");np(this.yieldEvery)&&(this.maybeWait=function(e,t){let n,r=Xg();return(...s)=>{const a=Xg();return a-r<t||(r=a,n=e(...s)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}maybeWait(e,t,n){var r=this;return _d(function*(){const s=[];null!=r.yield&&(yield p$(n),s.push(r.yield(e,t,n))),s.push(Kk()),yield Promise.all(s)})()}onEpochBegin(e,t){var n=this;return _d(function*(){n.currentEpoch=e,null!=n.epochBegin&&(yield p$(t),yield n.epochBegin(e,t))})()}onEpochEnd(e,t){var n=this;return _d(function*(){const r=[];null!=n.epochEnd&&(yield p$(t),r.push(n.epochEnd(e,t))),"epoch"===n.yieldEvery&&r.push(Kk()),yield Promise.all(r)})()}onBatchBegin(e,t){var n=this;return _d(function*(){null!=n.batchBegin&&(yield p$(t),yield n.batchBegin(e,t))})()}onBatchEnd(e,t){var n=this;return _d(function*(){const r=[];null!=n.batchEnd&&(yield p$(t),r.push(n.batchEnd(e,t))),"batch"===n.yieldEvery?r.push(Kk()):np(n.yieldEvery)&&r.push(n.maybeWait(n.currentEpoch,e,t)),yield Promise.all(r)})()}onTrainBegin(e){var t=this;return _d(function*(){null!=t.trainBegin&&(yield p$(e),yield t.trainBegin(e))})()}onTrainEnd(e){var t=this;return _d(function*(){null!=t.trainEnd&&(yield p$(e),yield t.trainEnd(e))})()}}function w$(e,t){return null==e&&(e={}),e instanceof g$?[e]:Array.isArray(e)&&e[0]instanceof g$?e:_C(e).map(e=>new v$(e,t))}let k$=(()=>{class e{constructor(){}static registerCallbackConstructor(t,n){Ld(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(const n in e.constructors)e.constructors[+n].forEach(e=>{if(e===t)throw new IC("Duplicate callback constructor.")})}static clear(){e.constructors={}}static createCallbacks(t){const n=[];for(const r in e.constructors){const s=+r;t>=s&&n.push(...e.constructors[s])}return n.map(e=>new e)}}return e.constructors={},e})();function I$(e,t,n,r,s,a,i,o,l){const u=new x$,c=[new b$,...k$.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const h=new y$(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function N$(e,t={},n=!1){return MC(e,Qb.getMap().classNameMap,t,"layer",n)}function S$(e,t){return rx(()=>{"float32"!==e.dtype&&(e=e.asType("float32"));const n=gv(TT(e),t,!0),r=av(n.shape,vC()),s=iw(wv(n,r));return Zx(e,s)})}function C$(e,t){return rx(()=>kv(TT(mv(t,e)),-1))}function T$(e,t){return rx(()=>kv(cx(mv(t,e)),-1))}function $$(e,t){return rx(()=>{const n=mv(e,t),r=Ox(cx(e),vC(),Number.MAX_VALUE),s=cx(Zx(n,r));return fv(100,kv(s,-1))})}function E$(e,t,n=!1){return rx(()=>{if(n)t=rw(t);else{const e=gv(t,t.shape.length-1,!0);t=Zx(t,e)}return t=Ox(t,vC(),1-vC()),Dv(gv(fv(e.toFloat(),hv(t)),t.shape.length-1))})}function _$(e,t,n=!1){return rx(()=>{const r=iv(function(e){const t=[dT(e.shape)];return e.reshape(t)}(e)).toInt(),s=(t=Ox(t,vC(),1-vC())).shape;return E$(Mv(r,s[s.length-1]).reshape(s),t,n)})}function A$(e,t){return rx(()=>{let n;return n=Ox(t,vC(),1-vC()),n=hv(Zx(n,mv(1,n))),kv(function(e,t){if(!Wd(e.shape,t.shape))throw new IC(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return rx(()=>{const n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())})}(e,n),-1)})}function R$(e,t){return rx(()=>{const n=S$(e,-1),r=S$(t,-1),s=fv(n,r);return Dv(gv(s,-1))})}const F$={meanSquaredError:C$,meanAbsoluteError:T$,meanAbsolutePercentageError:$$,meanSquaredLogarithmicError:function(e,t){return rx(()=>{const n=Ox(t,vC(),Number.MAX_VALUE),r=hv(hx(1,n)),s=Ox(e,vC(),Number.MAX_VALUE),a=hv(hx(1,s));return kv(TT(mv(r,a)),-1)})},squaredHinge:function(e,t){return rx(()=>{const n=wv(0,mv(1,fv(e,t)));return kv(TT(n),-1)})},hinge:function(e,t){return rx(()=>{const n=wv(0,mv(1,fv(e,t)));return kv(n,-1)})},categoricalHinge:function(e,t){return rx(()=>{const n=gv(fv(e,t),-1),r=pv(fv(mv(1,e),t),-1);return wv(0,hx(1,mv(r,n)))})},logcosh:function(e,t){return rx(()=>{const n=Math.log(2),r=mv(t,e),s=mv(hx(r,sw(fv(-2,r))),n);return kv(s,-1)})},categoricalCrossentropy:E$,sparseCategoricalCrossentropy:_$,binaryCrossentropy:A$,kullbackLeiblerDivergence:function(e,t){return rx(()=>{const n=Ox(e,vC(),1),r=Ox(t,vC(),1);return gv(fv(e,hv(Zx(n,r))),-1)})},poisson:function(e,t){return rx(()=>{const n=hv(hx(vC(),t));return kv(mv(t,fv(e,n)),-1)})},cosineProximity:R$};function D$(e){if("string"==typeof e){if(e in F$)return F$[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new IC(t)}return e}function O$(e,t){return rx(()=>{const n=fv(.5,Pv(t)),r=gT(lv(t,n),e.dtype);return kv(tv(e,r),-1)})}function M$(e,t){return rx(()=>gT(tv(fx(e,-1),fx(t,-1)),"float32"))}function L$(e,t){return A$(e,t)}function z$(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),tv(e,t).asType("float32")}const P$=E$,B$=_$,V$={binaryAccuracy:O$,categoricalAccuracy:M$,precision:function(e,t){return rx(()=>{const n=function(e,t){return rx(()=>bv(e.equal(1),t.equal(1)).sum().cast("float32"))}(e,t),r=function(e,t){return rx(()=>bv(e.equal(0),t.equal(1)).sum().cast("float32"))}(e,t),s=n.add(r);return fw(lv(s,0),n.div(s),0).cast("float32")})},categoricalCrossentropy:P$,sparseCategoricalCrossentropy:B$,mse:C$,MSE:C$,mae:T$,MAE:T$,mape:$$,MAPE:$$,cosine:R$};function W$(e){if("string"==typeof e&&e in V$)return V$[e];if("string"!=typeof e&&null!=e)return e;throw new IC(`Unknown metric ${e}`)}function U$(e){if(TC(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(F$))if(F$[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(V$))if(V$[n]===e){t=n;break}return void 0!==t?t:e.name}}function H$(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!G$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function G$(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!G$(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!G$(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function j$(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function q$(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(_j){r="multiple"}j$([`${e.name} (${e.getClassName()})`,r,e.countParams().toString()],t,n)}function K$(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(_j){s="multiple"}const a=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e)a.push(`${u.inboundLayers[e].name}[${u.nodeIndices[e]}][${u.tensorIndices[e]}]`);const i=e.name,o=e.getClassName(),l=0===a.length?"":a[0];j$([`${i} (${o})`,s,e.countParams().toString(),l],t,r);for(let u=1;u<a.length;++u)j$(["","","",a[u]],t,r)}function X$(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function Z$(e,t){if(null===e)return null;if("string"==typeof e)return RC(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];X$(t,s,r)?n.push(r):n.push(Z$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=RC(n);t[e]=Z$(r,e)}}return t}}function Y$(e,t){if(null==e)return null;if("string"==typeof e)return AC(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];X$(t,s,r)?n.push(r):n.push(Y$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[AC(n)]="name"!==n&&"className"!==n||"string"!=typeof r?Y$(r,n):r}return t}}class J${constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof J$)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new IC(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return kb(t,e.dtype)}catch(_j){throw new IC(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof i$){if(null==this.id2Value[e.id])throw new IC(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new IC(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof i$){if(null==this.id2Value[e.id])throw new IC(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new IC(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&sx(this.id2Mask)}}const Q$={},eE={};function tE(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(e=>e.name),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().join(",");let h,d;if(null==Q$[c]){const e=function(e,t){Ld(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){const s=rE(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=rE(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach(e=>r[t].add(e))}}return{sorted:n,recipientCounts:nE(r)}}(i,t);h=e.sorted,d=e.recipientCounts,Q$[c]=h,eE[c]=d}h=Q$[c],d={},s||Object.assign(d,eE[c]);const p=new J$(t);for(let f=0;f<h.length;++f){if(null!=r){const e=nx().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],a=e.sourceLayer;if(a instanceof d$)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),s||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=_C(a.apply(i,n));let y=null;a.supportsMasking&&(y=a.computeMask(i,u));const b=sE(e),x=Array.isArray(b)?b:[b];for(let t=0;t<x.length;++t){p.hasKey(x[t])||p.add(x[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(x[t].name);-1!==e&&(l[e]=g[t])}s||sx(c)}return p.disposeMasks(),a?l:l[0]}function nE(e){const t={};for(const n in e)t[n]=e[n].size;return t}function rE(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function sE(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class aE extends c${constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=ZT(e)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(e.inputs)?e.inputs.slice():[e.inputs],this.outputs=Array.isArray(e.outputs)?e.outputs.slice():[e.outputs],zC(this.inputs).length!==this.inputs.length)throw new IC(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);zC(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.nodeIndex,t=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(t)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;TC(0===t,"input layer has >1 nodes"),TC(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof d$))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new kC(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(aE.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let a=0;a<c;a++)o(u.inputTensors[a],t,n,u.inboundLayers[a],u.nodeIndices[a],u.tensorIndices[a]);for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];e=Math.max(e,null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id]),r[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r].inboundNodes[y.nodeIndices[r]];t[s.id]=Math.max(e+1,null==t[s.id]?0:t[s.id]),n[s.id]=s}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in r){const e=r[y];e in d||(d[e]=[]),d[e].push(s[y])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(LC);this.layers=[];for(const y of p){const e=d[y];e.sort((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0});for(const t of e)t instanceof aE&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(LC);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new kC(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const y of g){const e=g.filter(e=>e===y).length;if(1!==e)throw new kC(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new l$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new IC("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const a of this.layers)for(const e of a.weights){if(null!=n[e.originalName])throw new IC(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}const s=[];for(const a in e){let r=a;if(null==n[a]){const e=a.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[a]]);else if(t)throw new IC(`Provided weight data has no target variable: ${a}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new IC(`${e.length} of ${r} weights are not set: ${e}`)}s$(s)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers 3.7.0",t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Y$(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return rx(()=>{e=_C(e);const n=new J$;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return tE(this.outputs,n,t)})}computeMask(e,t){return rx(()=>{let n;return e=_C(e),n=null==t?CC(null,e.length):_C(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=JT(e);if(t.length!==this.inputLayers.length)throw new IC(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++)n[this.inputLayers[i].name+"_0_0"]=t[i];const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(LC);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++)r.push(n[`${t.inboundLayers[i].name}_${t.nodeIndices[i]}_${t.tensorIndices[i]}`]);const s=JT(e.computeOutputShape(EC(r))),a=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++)n[`${e.name}_${a}_${t}`]=s[t]}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++)a.push(`${this.outputLayers[i].name}_${this.outputLayersNodeIndices[i]}_${this.outputLayersTensorIndices[i]}`);for(let i=0;i<a.length;i++){const e=a[i];TC(e in n),s.push(n[e])}return EC(s)}runInternalGraph(e,t){null==t&&(t=CC(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[e[o],t[o]];const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(LC);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===a.length){const[t,n]=a[0];null==u.mask&&(u.mask=n),o=_C(e.call(t,u)),l=_C(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map(e=>e[0]),i=a.map(e=>e[1]),null==u.mask&&(u.mask=i),o=_C(e.call(r,u)),l=_C(e.computeMask(r,i));if(e.activityRegularizer)throw new NC("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e)n[s[e].id]=[o[e],l[e]]}}}const s=[],a=[],i=[];for(const o of this.outputs){TC(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof aE?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=aE.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new IC(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new IC("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new IC(`No such layer: ${e}`)}calculateLosses(){return rx(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=aE.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=aE.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(_j){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.tensorIndices[r];let o=t[aE.nodeKey(s,e.nodeIndices[r])];null==o&&(o=0),n.push([s.name,o,a,i])}s.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=r,i.inboundNodes=s,n.push(i)}e.layers=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=aE.nodeKey(e,this.inputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let s=t[n];null==s&&(s=0),r.push([e.name,s,this.inputLayersTensorIndices[a]])}e.inputLayers=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=aE.nodeKey(e,this.outputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let r=t[n];null==r&&(r=0),s.push([e.name,r,this.outputLayersTensorIndices[a]])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&e.apply(EC(n),r)}function l(e){const n=e.name,a=N$(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new IC(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)})}const u=t.name,c=t.layers;for(const m of c)l(m);for(;!PC(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],d=[],p=t.inputLayers;for(const m of p){const e=m[0],t=m[1],n=m[2];TC(e in s),h.push(s[e].inboundNodes[t].outputTensors[n])}const f=t.outputLayers;for(const m of f){const e=m[0],t=m[1],n=m[2];TC(e in s),d.push(s[e].inboundNodes[t].outputTensors[n])}return new e({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new IC("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){rx(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function iE(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided classWeight is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{n.push(t in e?e[t]:null)}),n}throw new Error(`The model has multiple (${r}) outputs, so classWeight must be either an array with ${r} elements or an object with ${t} keys. Provided classWeight not understood: ${JSON.stringify(e)}`)}(e,t)}function oE(e,t,n,r){return lE.apply(this,arguments)}function lE(){return(lE=_d(function*(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=rx(()=>{if(1===e.shape.length)return e.clone();if(2===e.shape.length){if(e.shape[1]>1)return e.argMax(1);if(1===e.shape[1])return e.reshape([e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(yield t.data());sx(t);const s=[];return r.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])}),cw(s,"float32")}return null})).apply(this,arguments)}function uE(e,t){return fv(e,t)}function cE(e,t){let n,r;n=t.xs,r=t.ys,Ld(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=hE("input",e.inputNames,n),a=hE("output",e.outputNames,r),i=s[0].shape[0];Ld(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Ld(a.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let o=0;o<s.length;o++)Ld(s[o].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[o]} has ${s[o].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let o=0;o<a.length;o++)Ld(a[o].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[o]} has ${a[o].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:s,ys:a}}function hE(e,t,n){if(n instanceof cy)return[n];if(Array.isArray(n))return Ld(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(null==n[s])throw new IC(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function dE(e){if(3===e.length)throw new NC("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function pE(){return(pE=_d(function*(e,t,n){const r=null!=n.batchesPerEpoch;if(Ld(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Ld(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Ld(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Ld(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Ld(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(mE(n.validationData))Ld(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=dE(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(e=>"val_"+e)):l.slice();const c=w$(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=I$(c,h,n.epochs,null,null,fE(t,n),null,s,u);d.setModel(e),e.history=p,yield d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield t.iterator();for(;f<n.epochs;){const u={};yield d.onEpochBegin(f);let c=0,h=0;for(r||(m=yield t.iterator());!r||c<n.batchesPerEpoch;){const t=yield m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=cE(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],yield d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=iE(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(yield oE(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);sx(u);for(let e=0;e<l.length;++e){const t=p[e];a[l[e]]=t,ax(t)}yield d.onBatchEnd(h,a),m$(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=mE(n.validationData)?_C(yield e.evaluateDataset(n.validationData,{batches:n.validationBatches})):_C(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(yield d.onEpochEnd(f,u),f++,e.stopTraining_)break}return yield d.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})).apply(this,arguments)}function fE(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function mE(e){return"function"==typeof e.iterator}function gE(e){return"function"==typeof e.next}function yE(){return(yE=_d(function*(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new NC("Verbose mode is not implemented yet.");Ld(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=gE(t)?t:yield t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=yield i.next();if(a=rx(()=>{if(t.value){const{xs:n,ys:r}=cE(e,t.value),i=n.concat(r),u=rx(()=>s(i));if(sx(i),0===l)for(let e=0;e<u.length;++e)a.push(lx(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=rx(()=>hx(a[e],fv(c,t))),l>0&&sx(n)}sx(u),o+=c,++l}return a}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const e=a[u];a[u]=Zx(a[u],o),sx(e)}return EC(a)})).apply(this,arguments)}function bE(e){Ld(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function xE(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>bT(e,t,n-t)):bT(e,t,n-t)}function vE(e,t){return rx(()=>null==e?null:Array.isArray(e)?e.map(e=>vE(e,t)):CT(e,"int32"===t.dtype?t:t.toInt()))}function wE(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function kE(e,t,n,r,s,a,i,o,l,u,c,h,d,p,f){return IE.apply(this,arguments)}function IE(){return(IE=_d(function*(e,t,n,r,s,a,i,o,l,u,c,h,d,p,f){null==s&&(s=32),null==a&&(a=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==p))throw new IC("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,s,p,"steps_per_epoch");let y;null!=g&&(y=mT(0,g)),null==i&&(i=1);const{callbackList:b,history:x}=I$(o,i,a,d,g,p,s,m,h);b.setModel(e),e.history=x,yield b.onTrainBegin(),e.stopTraining_=!1;for(let v=d;v<a;++v){yield b.onEpochBegin(v);const a={};if(null!=p)throw new NC("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new NC("batch shuffling is not implemneted yet");c&&Dd(y);const i=cw(y),o=wE(g,s);for(let c=0;c<o.length;++c){const h={};if(yield b.onBatchBegin(c,h),rx(()=>{const d=o[c][0],p=o[c][1],f=bT(i,d,p-d);h.batch=c,h.size=p-d;const g=vE(n,f),y=t(g);for(let e=0;e<r.length;++e){const t=y[e];h[r[e]]=t,ax(t)}if(c===o.length-1&&m){const t=e.testLoop(l,u,s);for(let e=0;e<r.length;++e){const n=r[e],s=t[e];ax(s),a["val_"+n]=s}}}),yield b.onBatchEnd(c,h),m$(h),e.stopTraining_)break}i.dispose()}if(yield b.onEpochEnd(v,a),e.stopTraining_)break}return yield b.onTrainEnd(),yield e.history.syncData(),e.history})).apply(this,arguments)}function NE(){return(NE=_d(function*(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,a,i,o,l,u,c;e.isTraining=!0;try{const h=null==r.batchSize?32:r.batchSize;bE(h);const d=!1,p=yield e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,d,h);s=p[0],a=p[1],c=p[2];let f,m=!1;if(null!=r.validationData&&r.validationData.length>0){if(m=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NC("validationData including sample weights is not supported yet."):new IC(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);i=r.validationData[0],o=r.validationData[1];const t=!0,n=yield e.standardizeUserData(i,o,null,null,t,h);l=n[0],u=n[1],f=l.concat(u)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){m=!0;const e=Math.floor(s[0].shape[0]*(1-r.validationSplit)),t=s[0].shape[0];l=xE(s,e,t),s=xE(s,0,e),u=xE(a,e,t),a=xE(a,0,e),f=l.concat(u)}else null!=r.validationSteps&&(m=!0);const g=s.concat(a).concat(c);e.checkTrainableWeightsConsistency();const y=e.makeTrainFunction(),b=e.getDedupedMetricsNames();let x,v;m?(e.makeTestFunction(),x=e.testFunction,v=b.slice().concat(b.map(e=>"val_"+e))):(x=null,f=[],v=b.slice());const w=w$(r.callbacks,r.yieldEvery);return yield kE(e,y,g,b,h,r.epochs,r.verbose,w,x,f,r.shuffle,v,r.initialEpoch,null,null)}finally{e.isTraining=!1,CE(s,t),CE(a,n),CE(l,i),CE(u,o),null!=c&&sx(c)}})).apply(this,arguments)}function SE(e){const t=[];e instanceof cy&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(yT(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function CE(e,t){if(null==e)return;const n=[];if(t instanceof cy)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const s in t)n.push(t[s].id);const r=[];if(e instanceof cy)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&r.push(e)});else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach(e=>{e.isDisposed||e.dispose()})}function TE(e){return Array.isArray(e)}function $E(e){return!function(e){return e instanceof cy}(e)&&!TE(e)}function EE(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(TE(e)&&e.length>0)t=!0;else if($E(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new IC(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let a;if($E(e)){e=e,a=[];for(const n of t){if(null==e[n])throw new IC(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(TE(e)){if((e=e).length!==t.length)throw new IC(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new IC(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=SE(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new IC(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;const o=e.shape[a],l=n[i][a];if(null!=l&&l>=0&&o!==l)throw new IC(`Error when checking ${s}: expected ${t[i]} to have shape [${n[i]}], but got array with shape [${e.shape}].`)}}return a}function _E(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new IC(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new IC(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new IC(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;const o=e.shape[a],l=n[i][a];if(null!=l&&l!==o)throw new IC(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}let AE=(()=>{class e extends aE{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new IC("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Output shape","Param #"];let i;if(s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),j$(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?q$(o[c],n,r):K$(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;return t=t$(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),t}(e),u=t$(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>jk.adagrad(.01),Adadelta:()=>jk.adadelta(1,.95,vC()),Adam:()=>jk.adam(.001,.9,.999,vC()),Adamax:()=>jk.adamax(.002,.9,.999,vC(),0),RMSProp:()=>jk.rmsprop(.001,.9,0,vC()),SGD:()=>jk.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new IC(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ux))throw new IC("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new IC(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>D$(e))}else{const n=D$(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new IC(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(D$(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],oT("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};oT("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===A$?-1!==["accuracy","acc"].indexOf(i)?r=O$:-1!==["crossentropy","ce"].indexOf(i)&&(r=L$):this.lossFunctions[e]===_$?-1!==["accuracy","acc"].indexOf(i)?r=z$:-1!==["crossentropy","ce"].indexOf(i)&&(r=B$):-1!==["accuracy","acc"].indexOf(i)?r=M$:-1!==["crossentropy","ce"].indexOf(i)&&(r=P$),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=W$(i);a=e,n=""+U$(i)}let t;oT(n,()=>{t=a}),s(e,n,t)}})(r[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;bE(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const a=s[0].concat(s[1]);return this.makeTestFunction(),EC(this.testLoop(this.testFunction,a,r,n.verbose,n.steps))}finally{CE(s[0],e),CE(s[1],t)}}evaluateDataset(e,t){var n=this;return _d(function*(){return n.makeTestFunction(),function(e,t,n){return yE.apply(this,arguments)}(n,e,t)})()}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new IC(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new IC(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new IC("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=this.retrieveSymbolicTensors(n?t:[t]),s=new J$;if(e instanceof cy&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new IC(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new IC(`No value is provided for the model's input ${i.name}`);s.add(i,t)}const a=tE(r,s);return n?a:a[0]}retrieveSymbolicTensors(e){const t=CC(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map(e=>e.name);for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,r)=>{null==t&&n.push(e[r])}),new IC(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return rx(()=>{const r=this.checkNumSamples(e);if(n)throw new NC("Verbose predictLoop() is not implemented yet.");const s=wE(r,t),a=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t)rx(()=>{const n=xE(e,s[t][0],s[t][1]),r=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)r.push({key:this.inputs[e],value:n[e]});else r.push({key:this.inputs[0],value:n});const a=new J$(r);return tE(this.outputs,a)}).forEach((e,t)=>a[t].push(e));return EC(a.map(e=>Mx(e,0)))})}predict(e,t={}){const n=SE(e);_E(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==t.batchSize?32:t.batchSize;return bE(r),this.predictLoop(n,r)}finally{CE(n,e)}}predictOnBatch(e){_E(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new kC("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];s.push(this.feedLossFns[a]===_$?e.slice(0,e.length-1).concat([1]):e)}if(function(e,t,n){const r=zC(e.map(e=>e.shape[0]));r.sort();const s=zC(t.map(e=>e.shape[0]));if(s.sort(),r.length>1)throw new IC(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(s.length>1)throw new IC(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(r.length>0&&s.length>0&&!Wd(r,s))throw new IC(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=EE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=EE(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[C$,A$,E$];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===E$&&1===a.shape[a.shape.length-1])throw new IC(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new IC(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new IC(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}standardizeUserData(e,t,n,r,s=!0,a){var i=this;return _d(function*(){const[o,l]=i.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){const e=iE(r,i.outputNames);u=[];for(let t=0;t<e.length;++t)u.push(yield oE(l[t],null,e[t]))}return[o,l,u]})()}testLoop(e,t,n,r=0,s){return rx(()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new NC("Verbose mode is not implemented yet.");if(null!=s)throw new NC("steps mode in testLoop() is not implemented yet");{const r=wE(a,n),s=cw(mT(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=bT(s,a,o-a),u=vE(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(lx(0));for(let e=0;e<c.length;++e)i[e]=hx(i[e],fv(o-a,c[e]))}for(let e=0;e<i.length;++e)i[e]=Zx(i[e],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;$C(e,r)>1&&(s+=`_${$C(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new J$(e),o=tE(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=uE(e,s[n]));const a=kv(e);t.push(a),l=0===n?e:hx(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][1];e=kv((0,this.metricsTensors[n][0])(r[t],o[t]))}ax(e),a.push(e)}return l=kv(l),this.calculateLosses().forEach(e=>{l=hx(l,e)}),l},!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>rx(()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new J$(a),o=tE(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=kv((0,this.lossFunctions[e])(s[e],o[e]));n=0===e?r:hx(n,r),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][1],r=kv((0,this.metricsTensors[e][0])(s[n],o[n]));t.push(r)}return t})}fit(e,t,n={}){var r=this;return _d(function*(){return function(e,t,n){return NE.apply(this,arguments)}(r,e,t,n)})()}fitDataset(e,t){var n=this;return _d(function*(){return function(e,t,n){return pE.apply(this,arguments)}(n,e,t)})()}trainOnBatch(e,t){var n=this;return _d(function*(){const r=yield n.standardizeUserData(e,t),s=r[0],a=r[1],i=n.makeTrainFunction()(s.concat(a)),o=[];for(const e of i){const t=yield e.data();o.push(t[0])}return sx(i),EC(o)})()}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=nx().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-nx().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=AC(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>AC(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=AC(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[AC(U$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>AC(U$(e)));{const e={};for(const t in this.metrics)e[t]=AC(U$(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=N$(Z$(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=RC(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>RC(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=RC(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map(e=>RC(e));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=RC(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}save(e,t){var n=this;return _d(function*(){if("string"==typeof e){const t=Yy(e);if(0===t.length)throw new IC(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new IC(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new IC("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=yield Wy(n.getNamedWeights(t)),s={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.7.0",convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=n.optimizer){s.trainingConfig=n.getTrainingConfig();const e="optimizer",{data:t,specs:a}=yield Wy(yield n.optimizer.getWeights(),e);r.specs.push(...a),r.data=qy([r.data,t])}return null!=n.userDefinedMetadata&&(H$(n.userDefinedMetadata,n.name,!0),s.userDefinedMetadata=n.userDefinedMetadata),s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)})()}setUserDefinedMetadata(e){H$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return e.className="Model",e})();ex(AE),ex((()=>{class e extends AE{}return e.className="Functional",e})()),ex((()=>{class e extends AE{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:ZT("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new IC(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof e||t instanceof AE;let r;if(n){if(r=t,1!==r.outputs.length)throw new IC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new IC("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new IC("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new IC("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new d$({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==t.inboundNodes.length)throw new IC(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new IC("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=h$(this.outputs[0])}this.inboundNodes=[],new l$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:CC(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(e$(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new AE({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new kC("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}evaluateDataset(e,t){var n=this;return _d(function*(){if(!n.built)throw new kC("The model needs to be compiled before being used.");return n.model.evaluateDataset(e,t)})()}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,t,n={}){var r=this;return _d(function*(){if(!r.built)throw new kC("The model needs to be compiled before being used.");return r.model.fit(e,t,n)})()}fitDataset(e,t){var n=this;return _d(function*(){if(!n.built)throw new kC("The model needs to be compiled before being used.");return n.model.fitDataset(e,t)})()}trainOnBatch(e,t){var n=this;return _d(function*(){return n.model.trainOnBatch(e,t)})()}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new IC("Legacy serialization format not supported yet.");a=n}else Ld(null!=n.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof e))throw new NC(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const e of a){const t=N$(e,void 0,s);s&&t.setFastWeightInitDuringBuild(!0),o.add(t)}return o}set stopTraining(e){if(null==this.model)throw new IC("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new IC("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}return e.className="Sequential",e})());class RE extends Jb{getConfig(){return{}}}ex((()=>{class e extends RE{apply(e,t=1){return function(e,t=1){if(1!==t)throw new NC(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Yx(e)}(e,t)}}return e.className="elu",e})()),ex((()=>{class e extends RE{apply(e){return Xv(e)}}return e.className="selu",e})()),ex((()=>{class e extends RE{apply(e){return qv(e)}}return e.className="relu",e})()),ex((()=>{class e extends RE{apply(e){return rx(()=>Iv(6,qv(e)))}}return e.className="relu6",e})()),ex((()=>{class e extends RE{apply(e){return e}}return e.className="linear",e})()),ex((()=>{class e extends RE{apply(e){return Yv(e)}}return e.className="sigmoid",e})()),ex((()=>{class e extends RE{apply(e){return function(e){return rx(()=>{const t=hx(.5,fv(.2,e));return Ox(t,0,1)})}(e)}}return e.className="hardSigmoid",e})()),ex((()=>{class e extends RE{apply(e){return sw(e)}}return e.className="softplus",e})()),ex((()=>{class e extends RE{apply(e){return function(e){return rx(()=>Zx(e,cx(e).add(1)))}(e)}}return e.className="softsign",e})()),ex((()=>{class e extends RE{apply(e){return uw(e)}}return e.className="tanh",e})());let FE=(()=>{class e extends RE{apply(e,t=-1){return rw(e,t)}}return e.className="softmax",e})();function DE(e){return e.getClassName()}function OE(e,t={}){return MC(e,Qb.getMap().classNameMap,t,"activation")}function ME(e){if(null==e)return OE({className:"linear",config:{}});if("string"==typeof e){const t={};return t.className=e,t.config={},OE(t)}return e instanceof RE?e:OE(e)}ex(FE),ex((()=>{class e extends RE{apply(e,t=-1){return yv(e,t)}}return e.className="logSoftmax",e})()),ex((()=>{class e extends RE{apply(e,t=1){return rx(()=>Yv(e.mul(t)).mul(e))}}return e.className="swish",e})()),ex((()=>{class e extends RE{apply(e){return rx(()=>fv(e,uw(sw(e))))}}return e.className="mish",e})());class LE extends Jb{}ex((()=>{class e extends LE{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return rx(()=>{let t=Lv([1]);return this.hasL1&&(t=hx(t,gv(fv(this.l1,cx(e))))),this.hasL2&&(t=hx(t,gv(fv(this.l2,TT(e))))),t.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}return e.className="L1L2",e})());const zE={l1l2:"L1L2"};function PE(e){return DC(e)}function BE(e,t={}){return MC(e,Qb.getMap().classNameMap,t,"regularizer")}function VE(e){return null==e?null:"string"==typeof e?BE({className:e in zE?zE[e]:e,config:{}}):e instanceof LE?e:BE(e)}function WE(e,t,n){if("number"==typeof e)return CC(e,t);if(e.length!==t)throw new IC(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new IC(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function UE(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function HE(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+fT([n-t,0]);else{if("same"!==r)throw new IC(`Unsupport padding mode: ${r}.`);e*=t}return e}function GE(e,t){return rx(()=>(rT(t),"channelsFirst"===t?gw(e,[0,2,3,1]):e))}function jE(e,t){return rx(()=>(rT(t),"channelsFirst"===t?gw(e,[0,2,3,4,1]):e))}function qE(e,t,n,r=[1,1],s="valid",a,i,o=null){return rx(()=>{if(null==a&&(a="channelsLast"),rT(a),3!==e.rank&&4!==e.rank)throw new IC(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new IC(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=GE(e,a);if("causal"===s)throw new NC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Aw({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=gw(l,[0,3,1,2])),l})}ex((()=>{class e extends c${constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=QT(e);let n=qv(e);return null!=this.maxValue&&(n=Ox(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}return e.className="ReLU",e})()),ex((()=>{class e extends c${constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=QT(e);return cv(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}return e.className="LeakyReLU",e})()),ex((()=>{class e extends c${constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=jT(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=VE(e.alphaRegularizer),this.alphaConstraint=ZC(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new IC(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=e$(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new a$({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=QT(e),Vv(e,this.alpha.read())}getConfig(){const e={alphaInitializer:GT(this.alphaInitializer),alphaRegularizer:PE(this.alphaRegularizer),alphaConstraint:KC(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}return e.className="PReLU",e})()),ex((()=>{class e extends c${constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new NC(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=QT(e);return Yx(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}return e.className="ELU",e})()),ex((()=>{class e extends c${constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=QT(e);return n.mul(gT(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}return e.className="ThresholdedReLU",e})()),ex((()=>{class e extends c${constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new FE).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=QT(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Softmax",e})());class KE extends c${constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",KE.verifyArgs(t),this.rank=e,WC(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new NC(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=WE(t.kernelSize,e,"kernelSize"),this.strides=WE(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,sT(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,rT(this.dataFormat),this.activation=ME(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=jT(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ZC(t.biasConstraint),this.biasRegularizer=VE(t.biasRegularizer),this.activityRegularizer=VE(t.activityRegularizer),this.dilationRate=WE(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new IC(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new IC(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new IC(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(TC("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!VC(e.kernelSize,"number",1,3))throw new IC(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:DE(this.activation),useBias:this.useBias,biasInitializer:GT(this.biasInitializer),biasRegularizer:PE(this.biasRegularizer),activityRegularizer:PE(this.activityRegularizer),biasConstraint:KC(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class XE extends KE{constructor(e,t){super(e,t),this.kernel=null,XE.verifyArgs(t),this.filters=t.filters,WC(this.filters,"filters"),this.kernelInitializer=jT(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ZC(t.kernelConstraint),this.kernelRegularizer=VE(t.kernelRegularizer)}build(e){e=e$(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IC(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return rx(()=>{let t;e=QT(e);const n=null==this.bias?null:this.bias.read(),r=HC(this.activation.getClassName());if(null!=r&&2===this.rank)t=qE(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return rx(()=>{if(null==a&&(a="channelsLast"),rT(a),3!==e.shape.length)throw new IC(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new IC(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new IC(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=gw(e,[0,2,1])),"causal"===s)throw new NC("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Wx(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=ET(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=qE(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new NC("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return rx(()=>{if(null==a&&(a="channelsLast"),rT(a),4!==e.rank&&5!==e.rank)throw new IC(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new IC(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=jE(e,a);if("causal"===s)throw new NC("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Gx(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=ET(o,n)),"channelsFirst"===a&&(o=gw(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=e$(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=UE(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:GT(this.kernelInitializer),kernelRegularizer:PE(this.kernelRegularizer),kernelConstraint:KC(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new IC(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}let ZE=(()=>{class e extends XE{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!VC(e.kernelSize,"number",1,2))throw new IC(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return e.className="Conv2D",e})();ex(ZE);let YE=(()=>{class e extends XE{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new IC(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return e.className="Conv3D",e})();ex(YE),ex((()=>{class e extends ZE{constructor(e){if(super(e),this.inputSpec=[new a$({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new IC(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=e$(e)).length)throw new IC("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IC("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new a$({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return rx(()=>{let t=QT(e);if(4!==t.shape.length)throw new IC(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const a=n[s],i=this.kernelSize[1],o=this.strides[1],l=[n[0],HE(n[r],this.strides[0],this.kernelSize[0],this.padding),HE(a,o,i,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=gw(t,[0,2,3,1]));let u=Hx(t,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=gw(u,[0,3,1,2])),null!=this.bias&&(u=ET(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(e){const t=(e=e$(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=HE(t[r],o,a,this.padding),t[s]=HE(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return e.className="Conv2DTranspose",e})()),ex((()=>{class e extends YE{constructor(e){if(super(e),this.inputSpec=[new a$({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new IC(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=e$(e)).length)throw new IC("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new IC("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new a$({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return rx(()=>{let t=QT(e);if(5!==t.shape.length)throw new IC(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let r,s,a;"channelsFirst"===this.dataFormat?(a=2,r=3,s=4):(a=1,r=2,s=3);const i=n[r],o=n[s],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[1],h=this.strides[2],d=[n[0],HE(n[a],this.strides[0],this.kernelSize[0],this.padding),HE(i,c,l,this.padding),HE(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=gw(t,[0,2,3,4,1]));let p=qx(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=gw(p,[0,4,1,2,3])),null!==this.bias&&(p=ET(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=e$(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=HE(t[r],u,i,this.padding),t[s]=HE(t[s],c,o,this.padding),t[a]=HE(t[a],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return e.className="Conv3DTranspose",e})());let JE=(()=>{class e extends XE{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new IC("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new IC("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new IC(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=jT(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=VE(t.depthwiseRegularizer),this.depthwiseConstraint=ZC(t.depthwiseConstraint),this.pointwiseInitializer=jT(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=VE(t.pointwiseRegularizer),this.pointwiseConstraint=ZC(t.pointwiseConstraint)}build(e){if((e=e$(e)).length<this.rank+2)throw new IC(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new IC(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new a$({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return rx(()=>{let t;if(e=QT(e),1===this.rank)throw new NC("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=gw(e,[0,2,3,1])),t=Zv(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=ET(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=gw(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=GT(this.depthwiseInitializer),e.pointwiseInitializer=GT(this.pointwiseInitializer),e.depthwiseRegularizer=PE(this.depthwiseRegularizer),e.pointwiseRegularizer=PE(this.pointwiseRegularizer),e.depthwiseConstraint=KC(this.depthwiseConstraint),e.pointwiseConstraint=KC(this.pointwiseConstraint),e}}return e.className="SeparableConv",e})();function QE(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new IC("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function e_(e,t,n,r=!1,s,a,i=!1,o=!1){return rx(()=>{const l=t.shape.length;if(l<3)throw new IC(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(mT(2,l));if(t=gw(t,u),null!=a)throw new NC("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===l-1&&(s=nv(s,-1)),s=gw(s,u)),r&&(t=Kv(t,0),null!=s&&(s=Kv(s,0)));const c=[];let h,d=n;const p=t.shape[0],f=dw(t);let m,g;null!=s&&(m=dw(s));for(let t=0;t<p;++t){const n=f[t],r=rx(()=>e(n,d));if(null==s)h=r[0],d=r[1];else{const e=rx(()=>{const e=m[t],n=Pv(e).sub(e);return{output:r[0].mul(e).add(d[0].mul(n)),newStates:d.map((t,s)=>r[1][s].mul(e).add(t.mul(n)))}});h=e.output,d=e.newStates}o&&c.push(h)}return o&&(g=lw(c,1)),[h,g,d]})}ex((()=>{class e extends JE{constructor(e){super(2,e)}}return e.className="SeparableConv2D",e})()),ex((()=>{class e extends XE{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!VC(e.kernelSize,"number",1,1))throw new IC(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return e.className="Conv1D",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return rx(()=>{if(e=QT(e),"channelsLast"===this.dataFormat){const t=vT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return vT(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=vT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return vT(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Cropping2D",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,rT(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,BC(JC,"InterpolationFormat",this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,t){return rx(()=>{let t=QT(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=gw(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r]);return gw(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}return e.className="UpSampling2D",e})()),ex((()=>{class e extends KE{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=jT(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ZC(e.depthwiseConstraint),this.depthwiseRegularizer=VE(e.depthwiseRegularizer)}build(e){if((e=e$(e)).length<4)throw new IC(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new IC(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return rx(()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return rx(()=>{null==s&&(s="channelsLast"),rT(s);let i=GE(e,s);if(4!==e.rank)throw new IC(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new IC(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Kx(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=gw(i,[0,3,1,2])),i})}(e=QT(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=ET(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=e$(e);const t="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=UE("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),s=UE(t,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],n,r,s]:[e[0],r,s,n]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=GT(this.depthwiseInitializer),e.depthwiseRegularizer=PE(this.depthwiseRegularizer),e.depthwiseConstraint=KC(this.depthwiseRegularizer),e}}return e.className="DepthwiseConv2D",e})());let t_=(()=>{class e extends c${constructor(e){let t;if(super(e),null==e.cell)throw new IC("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new i_({cells:e.cell}):e.cell,null==t.stateSize)throw new IC("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new a$({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?mT(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){YT(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return rx(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new NC("Constants support is not implemented in RNN yet.");YT(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new a$({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Wd(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new IC(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(e=>new a$({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){rx(()=>{if(!this.stateful)throw new wC("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new IC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>Lv([n,e])):[Lv([n,this.cell.stateSize])];else if(null==e)sx(this.states_),null!=this.keptStates&&(sx(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>Lv([n,e])):this.states_[0]=Lv([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new IC(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):sx(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!Wd(r.shape,a))throw new IC(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>ax(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=QE(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new a$({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof i$){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return rx(()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=QT(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new IC(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=e_((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(e){return rx(()=>{let t=Lv(e.shape);return t=gv(t,[1,2]),t=yT(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?IT(t,[1,e]):t):this.cell.stateSize>1?[IT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign({},r,t,n)}static fromConfig(e,t,n={}){const r=N$(t.cell,n);return new e(Object.assign(t,{cell:r}))}}return e.className="RNN",e})();ex(t_);class n_ extends c${}let r_=(()=>{class e extends n_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,WC(this.units,"units"),this.activation=ME(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VE(e.kernelRegularizer),this.recurrentRegularizer=VE(e.recurrentRegularizer),this.biasRegularizer=VE(e.biasRegularizer),this.kernelConstraint=ZC(e.kernelConstraint),this.recurrentConstraint=ZC(e.recurrentConstraint),this.biasConstraint=ZC(e.biasConstraint),this.dropout=pT([1,fT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=pT([1,fT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=e$(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return rx(()=>{if(2!==(e=e).length)throw new IC(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o_({ones:()=>Pv(e),rate:this.dropout,training:r})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o_({ones:()=>Pv(n),rate:this.recurrentDropout,training:r}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=ST(null!=a?fv(e,a):e,this.kernel.read()),null!=this.bias&&(s=ET(s,this.bias.read())),null!=i&&(n=fv(n,i));let o=hx(s,ST(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DE(this.activation),useBias:this.useBias,kernelInitializer:GT(this.kernelInitializer),recurrentInitializer:GT(this.recurrentInitializer),biasInitializer:GT(this.biasInitializer),kernelRegularizer:PE(this.kernelRegularizer),recurrentRegularizer:PE(this.recurrentRegularizer),biasRegularizer:PE(this.biasRegularizer),activityRegularizer:PE(this.activityRegularizer),kernelConstraint:KC(this.kernelConstraint),recurrentConstraint:KC(this.recurrentConstraint),biasConstraint:KC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}return e.className="SimpleRNNCell",e})();ex(r_),ex((()=>{class e extends t_{constructor(e){e.cell=new r_(e),super(e)}call(e,t){return rx(()=>(null!=this.cell.dropoutMask&&(sx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return new e(t)}}return e.className="SimpleRNN",e})());let s_=(()=>{class e extends n_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new IC("GRUCell does not support reset_after parameter set to true.");this.units=e.units,WC(this.units,"units"),this.activation=ME(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ME(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VE(e.kernelRegularizer),this.recurrentRegularizer=VE(e.recurrentRegularizer),this.biasRegularizer=VE(e.biasRegularizer),this.kernelConstraint=ZC(e.kernelConstraint),this.recurrentConstraint=ZC(e.recurrentConstraint),this.biasConstraint=ZC(e.biasConstraint),this.dropout=pT([1,fT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=pT([1,fT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=e$(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return rx(()=>{if(2!==(e=e).length)throw new IC(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o_({ones:()=>Pv(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o_({ones:()=>Pv(r),rate:this.recurrentDropout,training:n,count:3}));const s=this.recurrentDropoutMask;let a,i,o;0<this.dropout&&this.dropout<1&&(e=fv(e,this.dropoutMask[0]));let l=ST(e,this.kernel.read());this.useBias&&(l=ET(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=fv(r,s[0]));const u=this.recurrentKernel.read(),[c,h]=aw(u,[2*this.units,this.units],u.rank-1),d=ST(r,c),[p,f,m]=aw(l,3,l.rank-1),[g,y]=aw(d,2,d.rank-1);a=this.recurrentActivation.apply(hx(p,g)),i=this.recurrentActivation.apply(hx(f,y));const b=ST(fv(i,r),h);o=this.activation.apply(hx(m,b));const x=hx(fv(a,r),fv(hx(1,Dv(a)),o));return[x,x]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DE(this.activation),recurrentActivation:DE(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GT(this.kernelInitializer),recurrentInitializer:GT(this.recurrentInitializer),biasInitializer:GT(this.biasInitializer),kernelRegularizer:PE(this.kernelRegularizer),recurrentRegularizer:PE(this.recurrentRegularizer),biasRegularizer:PE(this.biasRegularizer),activityRegularizer:PE(this.activityRegularizer),kernelConstraint:KC(this.kernelConstraint),recurrentConstraint:KC(this.recurrentConstraint),biasConstraint:KC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}return e.className="GRUCell",e})();ex(s_),ex((()=>{class e extends t_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new s_(e),super(e)}call(e,t){return rx(()=>(null!=this.cell.dropoutMask&&(sx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}return e.className="GRU",e})());let a_=(()=>{class e extends n_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,WC(this.units,"units"),this.activation=ME(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ME(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=jT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jT(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=VE(e.kernelRegularizer),this.recurrentRegularizer=VE(e.recurrentRegularizer),this.biasRegularizer=VE(e.biasRegularizer),this.kernelConstraint=ZC(e.kernelConstraint),this.recurrentConstraint=ZC(e.recurrentConstraint),this.biasConstraint=ZC(e.biasConstraint),this.dropout=pT([1,fT([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=pT([1,fT([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n;if(e=e$(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,r=this.units;n=new((t=class extends DT{apply(t,n){const s=e.apply([r]),a=(new OT).apply([r]),i=e.apply([2*r]);return kT(kT(s,a),i)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return rx(()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new IC(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o_({ones:()=>Pv(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o_({ones:()=>Pv(r),rate:this.recurrentDropout,training:n,count:4}));const a=this.recurrentDropoutMask;let i,o,l,u;0<this.dropout&&this.dropout<1&&(e=fv(e,this.dropoutMask[0]));let c=ST(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=fv(r,a[0])),c=hx(c,ST(r,this.recurrentKernel.read())),this.useBias&&(c=ET(c,this.bias.read()));const[h,d,p,f]=aw(c,4,c.rank-1);i=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),l=hx(fv(o,s),fv(i,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=fv(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:DE(this.activation),recurrentActivation:DE(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GT(this.kernelInitializer),recurrentInitializer:GT(this.recurrentInitializer),biasInitializer:GT(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:PE(this.kernelRegularizer),recurrentRegularizer:PE(this.recurrentRegularizer),biasRegularizer:PE(this.biasRegularizer),activityRegularizer:PE(this.activityRegularizer),kernelConstraint:KC(this.kernelConstraint),recurrentConstraint:KC(this.recurrentConstraint),biasConstraint:KC(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}return e.className="LSTMCell",e})();ex(a_),ex((()=>{class e extends t_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new a_(e),super(e)}call(e,t){return rx(()=>(null!=this.cell.dropoutMask&&(sx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}return e.className="LSTM",e})());let i_=(()=>{class e extends n_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return rx(()=>{let n=(e=e).slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){let t;YT(e)&&(e=e[0]),e=e,this.cells.forEach((n,r)=>{oT(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign({},e,{cells:t})}static fromConfig(e,t,n={}){const r=[];for(const s of t.cells)r.push(N$(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return r$(e)}setWeights(e){const t=[];for(const n of this.cells){const r=e.splice(n.weights.length);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}s$(t)}}return e.className="StackedRNNCells",e})();function o_(e){const{ones:t,rate:n,training:r=!1,count:s=1}=e,a=()=>_T(t(),n),i=()=>AT(a,t,r);return!s||s<=1?ax(i().clone()):Array(s).fill(void 0).map(i).map(e=>ax(e.clone()))}ex(i_);let l_=(()=>{class e extends t_{constructor(e){if(e.unroll)throw new NC("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new NC("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new a$({ndim:5})]}call(e,t){return rx(()=>{if(null!=this.cell.dropoutMask&&(sx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(sx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new IC("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return rx(()=>{const{stateSize:t}=this.cell,n=this.computeSingleOutputShape(e.shape),r=Lv([n[0],...n.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]})}resetStates(e,t=!1){rx(()=>{if(!this.stateful)throw new wC("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new IC("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Lv(s)):[Lv(s)];else if(null==e)sx(this.states_),null!=this.keptStates&&(sx(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Lv(s)):this.states_[0]=Lv(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new IC(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):sx(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!Wd(n.shape,r))throw new IC(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>ax(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?4:3],u=UE(e[o?3:2],r[0],s,a[0],i[0]),c=UE(l,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,u,c]:[u,c,n]]}}return e.className="ConvRNN2D",e})(),u_=(()=>{class e extends a_{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,WC(this.filters,"filters"),this.kernelSize=WE(n,2,"kernelSize"),this.kernelSize.forEach(e=>WC(e,"kernelSize")),this.strides=WE(r||1,2,"strides"),this.strides.forEach(e=>WC(e,"strides")),this.padding=s||"valid",sT(this.padding),this.dataFormat=a||"channelsLast",rT(this.dataFormat),this.dilationRate=WE(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>WC(e,"dilationRate"))}build(e){var t;e=e$(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new IC(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=this.kernelSize.concat([e[n],4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends DT{apply(e,t){return wT([n.apply([r]),zv([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return rx(()=>{if(3!==e.length)throw new IC(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=o_({ones:()=>Pv(r),rate:this.dropout,training:n,count:4}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?fv(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=o_({ones:()=>Pv(s),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[y,b,x,v]=aw(this.kernel.read(),4,3),[w,k,I,N]=this.useBias?aw(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,x,I,this.padding),h=this.inputConv(h,v,N,this.padding);const[S,C,T,$]=aw(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,S),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,$);const E=this.recurrentActivation.apply(hx(l,p)),_=this.recurrentActivation.apply(hx(u,f)),A=hx(fv(_,a),fv(E,this.activation.apply(hx(c,m)))),R=fv(this.recurrentActivation.apply(hx(h,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){const e=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(super.getConfig(),["units"]);return Object.assign({},e,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,t,n,r){const s=Vx(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?ET(s,n,this.dataFormat):s}recurrentConv(e,t){return Vx(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return e.className="ConvLSTM2DCell",e})();ex(u_),ex((()=>{class e extends l_{constructor(e){const t=new u_(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}return e.className="ConvLSTM2D",e})());let c_=(()=>{class e extends c${constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return AT(()=>_T(n,this.rate,r,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}return e.className="Dropout",e})();ex(c_),ex((()=>{class e extends c_{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}return e.className="SpatialDropout1D",e})()),ex((()=>{class e extends c${constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,WC(this.units,"units"),this.activation=ME(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=jT(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jT(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ZC(e.kernelConstraint),this.biasConstraint=ZC(e.biasConstraint),this.kernelRegularizer=VE(e.kernelRegularizer),this.biasRegularizer=VE(e.biasRegularizer),this.activityRegularizer=VE(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=e$(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=e$(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e),r=HC(this.activation.getClassName());let s;return null!=r?s=ST(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=ST(n,this.kernel.read()),null!=this.bias&&(s=ET(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:DE(this.activation),useBias:this.useBias,kernelInitializer:GT(this.kernelInitializer),biasInitializer:GT(this.biasInitializer),kernelRegularizer:PE(this.kernelRegularizer),biasRegularizer:PE(this.biasRegularizer),activityRegularizer:PE(this.activityRegularizer),kernelConstraint:KC(this.kernelConstraint),biasConstraint:KC(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Dense",e})()),ex((()=>{class e extends c${constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=e$(e);for(const t of e.slice(1))if(null==t)throw new IC(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],dT(e,1)]}call(e,t){return rx(()=>{this.invokeCallHook(e,t);let n=QT(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=n.transpose(e)}return function(e){if(e.rank<=1)throw new IC(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],dT(e.shape,1)];return e.reshape(t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}return e.className="Flatten",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.supportsMasking=!0,this.activation=ME(e.activation)}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e);return this.activation.apply(n)})}getConfig(){const e={activation:DE(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Activation",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return rx(()=>{return e=QT(e),t=e,n=this.n,rx(()=>{if(2!==t.shape.length)throw new IC(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return IT(yT(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}return e.className="RepeatVector",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new IC("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=dT(e);if(null!==a){if(0===s||i%s!=0)throw new IC(n);r[a]=i/s}else if(i!==s)throw new IC(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Reshape",e})()),ex((()=>{class e extends c${constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=mT(1,e.dims.length+1);if(!Wd(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new a$({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=e$(e)).slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return gw(QT(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Permute",e})()),ex((()=>{class e extends c${constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=QT(e);return px(Ov(n,this.maskValue),-1)}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e),r=px(Ov(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))})}}return e.className="Masking",e})()),ex((()=>{class e extends c${constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=null==e.inputLength?[t,null]:[t].concat(_C(e.inputLength))}this.inputDim=e.inputDim,WC(this.inputDim,"inputDim"),this.outputDim=e.outputDim,WC(this.outputDim,"outputDim"),this.embeddingsInitializer=jT(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=VE(e.embeddingsRegularizer),this.activityRegularizer=VE(e.activityRegularizer),this.embeddingsConstraint=ZC(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return rx(()=>this.maskZero?(e=QT(e),Ov(e,mw(e))):null)}computeOutputShape(e){if(e=e$(e),null==this.inputLength)return[...e,this.outputDim];const t=_C(this.inputLength);if(t.length!==e.length-1)throw new IC(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new IC(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return rx(()=>{this.invokeCallHook(e,t);let n=QT(e);return"int32"!==n.dtype&&(n=gT(n,"int32")),CT(this.embeddings.read(),n.as1D()).reshape(e$(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:GT(this.embeddingsInitializer),embeddingsRegularizer:PE(this.embeddingsRegularizer),activityRegularizer:PE(this.activityRegularizer),embeddingsConstraint:KC(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Embedding",e})());class h_ extends c${constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new NC}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new IC("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[e$(e)]),(e=e).length<2)throw new IC(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=zC(t),t.length>1)throw new IC(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map(e=>e.length);this.reshapeRequired=-1!==e.indexOf(null)||1!==zC(r).length}call(e,t){return rx(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const r=fT(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=yT(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=a.reshape([r].concat(dT(e.slice(1))));i=gw(i,[1,0]),i=i.reshape(s),t.push(i),n=!0}else if(e>1){const r=mT(1,e).concat([0]);t.push(gw(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=gw(r.reshape([-1,t]),[1,0]).reshape(n)}else if(s>1){const e=[s-1].concat(mT(0,s-1));r=gw(r,e)}return r}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=zC(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return rx(()=>{if(null==t)return null;if(!Array.isArray(t))throw new IC("`mask` should be an Array");if(!Array.isArray(e))throw new IC("`inputs` should be an Array");if(t.length!==e.length)throw new IC(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:nv(e,0)))[0];for(let e=1;e<t.length-1;++e)n=bv(n,t[e]);return n})}}function d_(e,t){for(;e<0;)e+=t;return e}function p_(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=Rx(e,t,n,r,s,a);else if(3===e.rank)i=Fx(e,t,n,r,s,a);else{if(4!==e.rank)throw new NC(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=Dx(e,t,n,r,s,a)}return i}function f_(e,t,n,r,s,a){return rx(()=>{let i;rT(s),aT(a),sT(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=GE(e,s);const o="same"===r?"same":"valid";return i="max"===a?xv(e,t,n,o):Ex(e,t,n,o),"channelsFirst"===s&&(i=gw(i,[0,3,1,2])),i})}function m_(e,t,n,r,s,a){return rx(()=>{let i;rT(s),aT(a),sT(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=jE(e,s);const o="same"===r?"same":"valid";return i="max"===a?vv(e,t,n,o):_x(e,t,n,o),"channelsFirst"===s&&(i=gw(i,[0,4,1,2,3])),i})}ex((()=>{class e extends h_{constructor(e){super(e)}mergeFunction(e){return rx(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=hx(t,e[n]);return t})}}return e.className="Add",e})()),ex((()=>{class e extends h_{constructor(e){super(e)}mergeFunction(e){return rx(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=fv(t,e[n]);return t})}}return e.className="Multiply",e})()),ex((()=>{class e extends h_{constructor(e){super(e)}mergeFunction(e){return rx(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=hx(t,e[n]);return fv(1/e.length,t)})}}return e.className="Average",e})()),ex((()=>{class e extends h_{constructor(e){super(e)}mergeFunction(e){return rx(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=wv(t,e[n]);return t})}}return e.className="Maximum",e})()),ex((()=>{class e extends h_{constructor(e){super(e)}mergeFunction(e){return rx(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Iv(t,e[n]);return t})}}return e.className="Minimum",e})()),ex((()=>{class e extends h_{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new IC("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(Wd(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new IC("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return rx(()=>wT(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new IC("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new IC("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new IC("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new IC(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return rx(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const r=[];for(let a=0;a<e.length;++a)r.push(null==t[a]?Pv(e[a]).asType("bool"):t[a].rank<e[a].rank?nv(t[a],-1):t[a]);const s=Mx(r,this.axis);return dx(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Concatenate",e})()),ex((()=>{class e extends h_{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Ld(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NC("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new IC(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new IC(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>d_(t,e[n].shape.length)):[d_(this.axes,n.shape.length),d_(this.axes,r.shape.length)],this.normalize&&(n=S$(n,t[0]),r=S$(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NC("batchDot is not implemented for tensors of 4D or higher rank yet");if(Ld(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Ld(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NC("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return rx(()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else n=0;if(i=2===e.shape.length&&2===t.shape.length?a[0]===a[1]?e.mul(t).sum(a[0]):e.transpose([1,0]).mul(t).sum(a[1]):e.matMul(t,a[0]!==e.shape.length-1,a[1]===t.shape.length-1),n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=i.squeeze(t)}return 1===i.shape.length&&(i=i.expandDims(1)),i})}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[d_(this.axes,e.length),d_(this.axes,t.length)],n}computeOutputShape(e){Ld(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NC("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}return e.className="Dot",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e);return AT(()=>NT(n.shape,0,this.stddev).add(n),()=>n,t.training||!1)})}}return e.className="GaussianNoise",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return rx(()=>{this.invokeCallHook(e,t);const n=QT(e);return this.rate>0&&this.rate<1?AT(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return n.mul(NT(n.shape,1,e))},()=>n,t.training||!1):n})}}return e.className="GaussianDropout",e})()),ex((()=>{class e extends c${constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||QT(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return rx(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return AT(()=>{const t=QT(e),r=-1.7580993408473766;let s=uv(jv(n),this.rate);s=gT(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate;return t.mul(s).add(s.add(-1).mul(r)).mul(a).add(i)},()=>QT(e),t.training||!1)}return e})}}return e.className="AlphaDropout",e})()),ex((()=>{class e extends c${constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jT(e.betaInitializer||"zeros"),this.gammaInitializer=jT(e.gammaInitializer||"ones"),this.movingMeanInitializer=jT(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jT(e.movingVarianceInitializer||"ones"),this.betaConstraint=ZC(e.betaConstraint),this.gammaConstraint=ZC(e.gammaConstraint),this.betaRegularizer=VE(e.betaRegularizer),this.gammaRegularizer=VE(e.gammaRegularizer)}build(e){e=e$(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new IC(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new a$({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return rx(()=>{const n=null!=t.training&&t.training,r=QT(e),s=r.shape,a=s.length,i=mT(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=CC(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!Wd(u,mT(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=this.movingMean.read().reshape(l),t=this.movingVariance.read().reshape(l),n=this.center?this.beta.read().reshape(l):null,s=this.scale?this.gamma.read().reshape(l):null;return p_(r,e,t,n,s,this.epsilon)}return p_(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(e,t,n,r,s=.001){return Wd(r.slice().sort(),mT(0,e.rank-1))?function(e,t,n,r,s=.001){return rx(()=>{const a=Fv(e,r),i=a.mean,o=a.variance;return[p_(e,i,o,n,t,s),i,o]})}(e,t,n,r,s):function(e,t,n,r,s=.001){return rx(()=>{const a=Fv(e,r),i=a.mean,o=a.variance,l=[];for(const t of mT(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=i.reshape(l),c=o.reshape(l),h=null==t?null:t.reshape(l),d=null==n?null:n.reshape(l);return[p_(e,u,c,d,h,s),i,o]})}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{rx(()=>{const r=1-n,s=e.read(),a=s.sub(t).mul(r);e.write(s.sub(a))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GT(this.betaInitializer),gammaInitializer:GT(this.gammaInitializer),movingMeanInitializer:GT(this.movingMeanInitializer),movingVarianceInitializer:GT(this.movingVarianceInitializer),betaRegularizer:PE(this.betaRegularizer),gammaRegularizer:PE(this.gammaRegularizer),betaConstraint:KC(this.betaConstraint),gammaConstraint:KC(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}return e.className="BatchNormalization",e})()),ex((()=>{class e extends c${constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=jT(e.betaInitializer||"zeros"),this.gammaInitializer=jT(e.gammaInitializer||"ones"),this.betaRegularizer=VE(e.betaRegularizer),this.gammaRegularizer=VE(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=e$(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==zC(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,t){const n=QT(e),r=n.shape,s=r.length;return rx(()=>{let{mean:e,variance:t}=Fv(n,this.axis,!0);const a=CC(1,s);for(const n of this.axis)a[n]=r[n];const i=e=>null!=e&&e.shape.length!==s&&this.axis!==[s-1]?e.reshape(a):e;let o=i(this.gamma.read()),l=i(this.beta.read());const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=e.tile(u),t=t.tile(u),o=o.tile(c),l=l.tile(c),p_(n,e,t,l,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GT(this.betaInitializer),gammaInitializer:GT(this.gammaInitializer),betaRegularizer:PE(this.betaRegularizer),gammaRegularizer:PE(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}return e.className="LayerNormalization",e})()),ex((()=>{class e extends c${constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new IC(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new IC(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new IC(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new a$({ndim:4})]}computeOutputShape(e){let t,n;return e=e$(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return rx(()=>{return t=QT(e),n=this.padding,r=this.dataFormat,rx(()=>{if(4!==t.rank)throw new IC(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new IC("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new IC(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Bv(t,e)});var t,n,r})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}return e.className="ZeroPadding2D",e})());class g_ extends c${constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new IC(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(WC(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new IC(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}WC(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,sT(this.padding),this.inputSpec=[new a$({ndim:3})]}computeOutputShape(e){const t=UE((e=e$(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return rx(()=>{this.invokeCallHook(e,t),e=yT(QT(e),2);const n=this.poolingFunction(QT(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ow(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}ex((()=>{class e extends g_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),f_(e,t,n,r,s,"max")}}return e.className="MaxPooling1D",e})()),ex((()=>{class e extends g_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),f_(e,t,n,r,s,"avg")}}return e.className="AveragePooling1D",e})());class y_ extends c${constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new IC(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];WC(this.poolSize,"poolSize"),WC(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,rT(this.dataFormat),sT(this.padding),this.inputSpec=[new a$({ndim:4})]}computeOutputShape(e){e=e$(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=UE(t,this.poolSize[0],this.padding,this.strides[0]),n=UE(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return rx(()=>(this.invokeCallHook(e,t),this.poolingFunction(QT(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ex((()=>{class e extends y_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),f_(e,t,n,r,s,"max")}}return e.className="MaxPooling2D",e})()),ex((()=>{class e extends y_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),f_(e,t,n,r,s,"avg")}}return e.className="AveragePooling2D",e})());class b_ extends c${constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new IC(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];WC(this.poolSize,"poolSize"),WC(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,rT(this.dataFormat),sT(this.padding),this.inputSpec=[new a$({ndim:5})]}computeOutputShape(e){e=e$(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=UE(t,this.poolSize[0],this.padding,this.strides[0]),n=UE(n,this.poolSize[1],this.padding,this.strides[1]),r=UE(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return rx(()=>(this.invokeCallHook(e,t),this.poolingFunction(QT(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ex((()=>{class e extends b_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),m_(e,t,n,r,s,"max")}}return e.className="MaxPooling3D",e})()),ex((()=>{class e extends b_{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return rT(s),sT(r),m_(e,t,n,r,s,"avg")}}return e.className="AveragePooling3D",e})());class x_ extends c${constructor(e){super(e),this.inputSpec=[new a$({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new NC}}ex((()=>{class e extends x_{constructor(e){super(e||{})}call(e,t){return rx(()=>{const t=QT(e);return kv(t,1)})}}return e.className="GlobalAveragePooling1D",e})()),ex((()=>{class e extends x_{constructor(e){super(e||{})}call(e,t){return rx(()=>{const t=QT(e);return pv(t,1)})}}return e.className="GlobalMaxPooling1D",e})());class v_ extends c${constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,rT(this.dataFormat),this.inputSpec=[new a$({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new NC}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ex((()=>{class e extends v_{call(e,t){return rx(()=>{const t=QT(e);return kv(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return e.className="GlobalAveragePooling2D",e})()),ex((()=>{class e extends v_{call(e,t){return rx(()=>{const t=QT(e);return pv(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return e.className="GlobalMaxPooling2D",e})());class w_ extends c${constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=N$(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}ex((()=>{class e extends w_{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=e$(e)).length<3)throw new IC(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=e$(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t);return[n[0],e[1]].concat(n.slice(1))}call(e,t){return rx(()=>e_((e,n)=>[QT(this.layer.call(e,t)),[]],e=QT(e),[],!1,null,null,!1,!0)[1])}}return e.className="TimeDistributed",e})()),ex((()=>{class e extends w_{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=N$(n),t.goBackwards=!0!==t.goBackwards;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=N$(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,BC(tT,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new NC("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState?(r=s.slice(1),t=s[0]):t=s[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):EC(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=QE(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new IC("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map(e=>new a$({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new NC("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof i$;for(const l of a)if(l instanceof i$!==o)throw new IC("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return rx(()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Kv(s,1)),"concat"===this.mergeMode?i=wT([r,s]):"sum"===this.mergeMode?i=hx(r,s):"ave"===this.mergeMode?i=fv(.5,hx(r,s)):"mul"===this.mergeMode?i=fv(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){oT(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),oT(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=N$(t.layer);if(delete t.layer,null!=t.numConstants)throw new NC("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}return e.className="Bidirectional",e})());var k_,I_=(()=>(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(I_||(I_={})),I_))();!function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(k_||(k_={}));const N_={};function S_(e){return N_[e]}function C_(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd;if("tensor"===a.type)return T_(t.inputNames[a.inputIndexStart],n,r,s);if("tensors"===a.type)return t.inputNames.slice(e,i).map(e=>T_(e,n,r,s));const o=T_(t.inputNames.slice(e)[0],n,r,s),l=o.dataSync();return"number"===a.type?l[0]:lp(o.shape,l)}const i=t.attrParams[e];return i&&i.value}function T_(e,t,n,r){const[s,a]=__(e);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[E_(s,e)]);return void 0!==i?t[E_(s,i)][a]:void 0}function $_(e,t){const[n,r,s]=__(e);return[E_(n,t&&t.currentContextId),r,s]}function E_(e,t){return t?`${e}-${t}`:e}function __(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),n]}function A_(e,t,n){let r=C_("pad",e,t,n);if("explicit"===r){r=C_("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function R_(e){return e.kept?e:Ib(e)}const F_=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],D_=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],O_=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],M_=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],L_=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],z_=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],P_=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],B_=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],V_=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],W_=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],U_=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],H_=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],G_=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],j_=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],q_=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],K_=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],X_=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Z_=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Y_=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class J_{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,l,u,c,h,d,p,f,m,g,y,b,x,v,w,k,I,N].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=[],r=[],s=[],a=e.node.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e),{});let i=[];const o=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const c=Object.keys(a);c.forEach(e=>{const t=a[e];t.inputNames.forEach((e,n)=>{const[r,,s]=$_(e),i=a[r];if(null!=i.outputs){const e=i.outputs.indexOf(s);-1!==e&&(t.inputNames[n]=`${r}:${e}`)}t.inputs.push(i),i.children.push(t)})}),0===Object.keys(u).length?c.forEach(e=>{const t=a[e];0===t.children.length&&o.push(t)}):Object.keys(u).forEach(e=>{const[t]=$_(e),n=a[t];null!=n&&(n.signatureKey=u[e],o.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=$_(e),n=a[t];n&&(n.signatureKey=l[e],i.push(n))}):i=n;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const d={nodes:a,inputs:i,outputs:o,weights:r,placeholders:n,signature:t,functions:h};return s.length>0&&(d.initNodes=s),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=S_(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=eA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=eA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=cA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=cA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=nA(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=nA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=uA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=uA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=tA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=tA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=dA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=dA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=lA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=lA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=hA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=hA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=aA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=iA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=sA(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=sA(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],a=[];e.signature.inputArg.forEach(e=>{const[t]=$_(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:rA(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,n)=>{const[s,,a]=$_(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);-1!==e&&(t.inputNames[n]=`${s}:${e}`)}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=$_(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))});const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Q_(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=bp().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function eA(e,t,n,r=!1){const s=e[t];return null!=s?Q_(s.s,r):n}function tA(e,t,n){const r=e[t];return r?r.b:n}function nA(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function rA(e){switch("string"==typeof e&&(e=I_[e]),e){case I_.DT_FLOAT:return"float32";case I_.DT_INT32:case I_.DT_INT64:case I_.DT_INT8:case I_.DT_UINT8:return"int32";case I_.DT_BOOL:return"bool";case I_.DT_DOUBLE:return"float32";case I_.DT_STRING:return"string";default:return null}}function sA(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function aA(e,t,n){const r=e[t];return r&&r.type?rA(r.type):n}function iA(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>rA(e)):n}function oA(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function lA(e,t,n){const r=e[t];return r&&r.shape?oA(r.shape):n}function uA(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function cA(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>Q_(e,r)):n}function hA(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>oA(e)):n}function dA(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class pA{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return T_(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return T_(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return nA(this.node.rawAttrs,e,t);if(null!=n.s)return eA(this.node.rawAttrs,e,t);if(null!=n.b)return tA(this.node.rawAttrs,e,t);if(null!=n.shape)return lA(this.node.rawAttrs,e,t);if(null!=n.type)return aA(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return uA(this.node.rawAttrs,e,t);if(null!=n.list.s)return cA(this.node.rawAttrs,e,t);if(null!=n.list.shape)return hA(this.node.rawAttrs,e,t);if(null!=n.list.b)return dA(this.node.rawAttrs,e,t);if(null!=n.list.type)return iA(this.node.rawAttrs,e,t)}return t}}const fA=Ly({addN_:function(e){Ld(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Ld(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((e,t)=>Oy(e,`tensors${t}`,"addN")),n=t[0];return t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!Wd(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),Ty.runKernel(Tp,t)}});function mA(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Ld(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],a=t[r];Ld(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function gA(e){return"number"!=typeof e&&!e.some(e=>e<0)}function yA(e,t,n){let r=bA(e,n);const s=!gA(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(e=>{r=bA(e.shape,r)}),!gA(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function bA(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class xA{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=lx(0),ax(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),mA(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ax(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return By([],[0].concat(this.elementShape));const n=this.readMany(e);return mA(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),lw(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return By([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return mA(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Mx(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,dw(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];rx(()=>{t=$x(t,[1,n,s]);for(let n=0;n<e.length;++n)a[n]=$x(Jv(t,[0,0===n?0:r[n-1],0],[1,e[n],s]),this.elementShape);return a});const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}class vA{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);mA(t,e.shape,"TensorList shape mismatch: "),ax(e)}),this.idTensor=lx(0),this.maxNumElements=r,ax(this.idTensor)}get id(){return this.idTensor.id}copy(){return new vA([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);mA(e,this.elementShape,"TensorList shape mismatch: ");const r=yA(this.elementShape,this.tensors,e);return rx(()=>{const e=this.tensors.map(e=>$x(e,r));return lw(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=yA(this.elementShape,this.tensors,e),r=this.tensors.pop();return mA(r.shape,e,"TensorList shape mismatch: "),$x(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(mA(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ax(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);mA(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=yA(this.elementShape,this.tensors,t);return $x(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);mA(this.elementShape,t.shape,"TensorList shape mismatch: "),ax(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);mA(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=yA(this.elementShape,this.tensors,n);return 0===e.length?By([],[0].concat(r)):rx(()=>{const t=e.map(e=>$x(this.tensors[e],r));return lw(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);mA(this.elementShape,t,"TensorList shape mismatch: ");const n=yA(this.elementShape,this.tensors,t);return 0===this.size()?By([],[0].concat(n)):rx(()=>{const e=this.tensors.map(e=>$x(e,n));return Mx(e,0)})}}const wA=function(){var e=_d(function*(e,t,n){switch(e.op){case"If":case"StatelessIf":{const r=C_("thenBranch",e,t,n),s=C_("elseBranch",e,t,n),a=C_("cond",e,t,n),i=C_("args",e,t,n);return(yield a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=C_("body",e,t,n),s=C_("cond",e,t,n),a=C_("args",e,t,n),i=yield n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(e=>e.id);let l=yield i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let u=a;for(;l[0];){const e=u;u=yield n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const a=yield n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=yield a[0].data(),a.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":return[R_(C_("pred",e,t,n))];case"Switch":{const r=C_("pred",e,t,n);let s=C_("data",e,t,n);return s.kept||(s=R_(s)),(yield r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==T_(e,t,n));return r?[R_(T_(r,t,n))]:void 0}case"Enter":{const r=C_("frameName",e,t,n),s=C_("tensor",e,t,n);return n.enterFrame(r),[R_(s)]}case"Exit":{const r=C_("tensor",e,t,n);return n.exitFrame(),[R_(r)]}case"NextIteration":{const r=C_("tensor",e,t,n);return n.nextIteration(),[R_(r)]}case"TensorArrayV3":{const r=C_("size",e,t,n),s=C_("dtype",e,t,n),a=C_("elementShape",e,t,n),i=C_("dynamicSize",e,t,n),o=C_("clearAfterRead",e,t,n),l=C_("identicalElementShapes",e,t,n),u=C_("name",e,t,n),c=new xA(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,lx(1)]}case"TensorArrayWriteV3":{const r=C_("tensorArrayId",e,t,n),s=C_("index",e,t,n),a=C_("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=C_("tensorArrayId",e,t,n),s=C_("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=C_("tensorArrayId",e,t,n),s=C_("indices",e,t,n),a=C_("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=C_("tensorArrayId",e,t,n),s=C_("indices",e,t,n),a=C_("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=C_("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=C_("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=C_("tensorArrayId",e,t,n),s=C_("tensor",e,t,n),a=C_("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=C_("tensorArrayId",e,t,n);return[lx(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=C_("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=C_("tensorListId",e,t,n),s=C_("index",e,t,n),a=C_("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=C_("tensorListId",e,t,n),s=C_("index",e,t,n),a=C_("elementShape",e,t,n),i=C_("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=C_("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new vA([],n,e.dtype,r),i=dw(e,0);return t.forEach((e,t)=>{a.setItem(e,i[t])}),a}(C_("tensor",e,t,n),r,C_("elementShape",e,t,n),C_("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=C_("elementShape",e,t,n),s=C_("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=function(e,t,n){return new vA([],e,t,n)}(r,s,C_(a,e,t,n));return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=C_("tensorListId",e,t,n),s=C_("indices",e,t,n),a=C_("elementShape",e,t,n),i=C_("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=C_("tensorListId",e,t,n),s=C_("elementShape",e,t,n),a=C_("elementDType",e,t,n),i=C_("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);mA(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=dw(e);return new vA(s,t,r)}(C_("tensor",e,t,n),C_("elementShape",e,t,n),C_("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=C_("tensorListId",e,t,n),s=n.getTensorList(r.id),a=C_("dtype",e,t,n),i=C_("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=C_("tensorListId",e,t,n),s=C_("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=C_("tensorListId",e,t,n),s=C_("elementShape",e,t,n),a=C_("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=C_("tensor",e,t,n),s=C_("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=bA(e.shape.slice(1),n),i=0===r?0:e.size/r,o=rx(()=>{const n=[];e=$x(e,[1,r,i]);for(let r=0;r<t.length;++r)n[r]=$x(Jv(e,[0,0===r?0:s[r-1],0],[1,t[r],i]),a);return e.dispose(),n}),l=new vA([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,C_("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}(),kA=Ly({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a=Oy(e,"x","maxPoolWithArgmax"),i=Ty.runKernel(sm,{x:a},{filterSize:t,strides:n,pad:r,includeBatchInIndex:s});return{result:i[0],indexes:i[1]}}});function IA(e,t,n){const[r,s]=C_("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=C_("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=C_("strides",e,t,n),h=A_(e,t,n),d=C_("dataFormat",e,t,n).toUpperCase(),p=C_("dilations",e,t,n);let[f,m]=C_("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:C_("leakyreluAlpha",e,t,n)}}function NA(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");return Ty.runKernel(Hf,{},{start:e,stop:t,num:n})}const SA=Ly({multinomial_:function(e,t,n,r=!1){const s=Oy(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o=1===i?$x(s,[1,-1]):s,l=Ty.runKernel(cm,{logits:o},{numSamples:t,seed:n,normalized:r});return 1===i?$x(l,[l.size]):l}});function CA(){return(CA=_d(function*(e){const t=Oy(e,"condition","whereAsync","bool"),n=yield t.data(),r=BI(t.shape,n);return e!==t&&t.dispose(),r})).apply(this,arguments)}const TA=function(e){return CA.apply(this,arguments)};function $A(){return($A=_d(function*(e,t){const n=Oy(e,"x","setdiff1d"),r=Oy(t,"y","setdiff1d");Ld(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Ld(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Ld(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield n.data(),a=yield r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new iy([o],n.dtype),u=new iy([o],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}function EA(e,t,n){return{boxes:C_("boxes",e,t,n),scores:C_("scores",e,t,n),maxOutputSize:C_("maxOutputSize",e,t,n),iouThreshold:C_("iouThreshold",e,t,n),scoreThreshold:C_("scoreThreshold",e,t,n),softNmsSigma:C_("softNmsSigma",e,t,n)}}const _A=function(){var e=_d(function*(e,t,n){switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}=EA(e,t,n),u=yield Dk.nonMaxSuppressionWithScoreAsync(r,s,a,i,o,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o}=EA(e,t,n),l=C_("padToMaxOutputSize",e,t,n),u=yield Dk.nonMaxSuppressionPaddedAsync(r,s,a,i,o,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o}=EA(e,t,n);return[yield Dk.nonMaxSuppressionAsync(r,s,a,i,o)]}case"Where":{const r=kb(C_("condition",e,t,n),"bool"),s=[yield TA(r)];return r.dispose(),s}case"ListDiff":return function(e,t){return $A.apply(this,arguments)}(C_("x",e,t,n),C_("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}();class AA{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=lx(0),this.tensorMap=new Map,ax(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return lx(this.size(),"int32")}import(e,t){var n=this;return _d(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return n.tensorMap.forEach(e=>e.dispose()),n.tensorMap.clear(),rx(()=>{const e=dw(t),s=r.length,a=e.length;Ld(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let t=0;t<s;t++){const s=r[t],a=e[t];ax(a),n.tensorMap.set(s,a)}return n.handle})})()}find(e,t){var n=this;return _d(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return rx(()=>{const e=[];for(let s=0;s<r.length;s++){const a=n.findWithDefault(r[s],t);e.push(a)}return lw(e)})})()}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const RA=function(){var e=_d(function*(e,t,n,r){switch(e.op){case"HashTable":case"HashTableV2":{const s=C_("keyDType",e,t,n),a=C_("valueDType",e,t,n),i=new AA(s,a);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=C_("tableHandle",e,t,n,r),a=C_("keys",e,t,n),i=C_("values",e,t,n),o=r.getHashTableById(s.id);return[yield o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=C_("tableHandle",e,t,n,r),a=C_("keys",e,t,n),i=C_("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[yield o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=C_("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r,s){return e.apply(this,arguments)}}(),FA=Ly({einsum_:function(e,...t){const n=t.map((e,t)=>Oy(e,`tensors${t}`,"einsum"));return Ty.runKernel(yf,n,{equation:e})}}),DA=Ly({sparseToDense_:function(e,t,n,r=0){const s=Oy(e,"sparseIndices","sparseToDense","int32"),a=Oy(t,"sparseValues","sparseToDense"),i=Oy(r,"defaultValue","sparseToDense",a.dtype);return function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i),Ty.runKernel(tg,{sparseIndices:s,sparseValues:a,defaultValue:i},{outputShape:n})}}),OA=Ly({denseBincount_:function(e,t,n,r=!1){const s=Oy(e,"x","denseBincount"),a=Oy(t,"weights","denseBincount");return Ld("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Ld(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Ld(n>=0,()=>`size must be non-negative, but got ${n}.`),Ld(a.size===s.size||0===a.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`),Ty.runKernel(of,{x:s,weights:a},{size:n,binaryOutput:r})}}),MA=Ly({scatterND_:function(e,t,n){const r=Oy(e,"indices","scatterND","int32"),s=Oy(t,"updates","scatterND");return oI(s,r,n),Ty.runKernel(Lm,{indices:r,updates:s},{shape:n})}}),LA=Ly({gatherND_:function(e,t){const n=Oy(t,"indices","gatherND","int32"),r=Oy(e,"x","gatherND","string_or_numeric");return Ty.runKernel(Rf,{params:r,indices:n})}});function zA(e,t,n,r){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return rx(()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[hx(C_("a",e,t,n),C_("b",e,t,n))];case"AddN":return[fA(C_("tensors",e,t,n))];case"FloorMod":case"Mod":return[cC(C_("a",e,t,n),C_("b",e,t,n))];case"Mul":return[fv(C_("a",e,t,n),C_("b",e,t,n))];case"RealDiv":case"Div":return[Zx(C_("a",e,t,n),C_("b",e,t,n))];case"DivNoNan":return[JS(C_("a",e,t,n),C_("b",e,t,n))];case"FloorDiv":return[Xx(C_("a",e,t,n),C_("b",e,t,n))];case"Sub":return[mv(C_("a",e,t,n),C_("b",e,t,n))];case"Minimum":return[Iv(C_("a",e,t,n),C_("b",e,t,n))];case"Maximum":return[wv(C_("a",e,t,n),C_("b",e,t,n))];case"Pow":return[gk(C_("a",e,t,n),C_("b",e,t,n))];case"SquaredDifference":return[Nk(C_("a",e,t,n),C_("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"basic_math":return rx(()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[cx(C_("x",e,t,n))];case"Acos":return[VS(C_("x",e,t,n))];case"Acosh":return[WS(C_("x",e,t,n))];case"Asin":return[HS(C_("x",e,t,n))];case"Asinh":return[GS(C_("x",e,t,n))];case"Atan":return[jS(C_("x",e,t,n))];case"Atan2":return[qS(C_("x",e,t,n),C_("y",e,t,n))];case"Atanh":return[KS(C_("x",e,t,n))];case"Ceil":return[XS(C_("x",e,t,n))];case"Complex":return[zy(C_("real",e,t,n),C_("imag",e,t,n))];case"Cos":return[_S(C_("x",e,t,n))];case"Cosh":return[RS(C_("x",e,t,n))];case"Elu":return[Yx(C_("x",e,t,n))];case"Erf":return[eC(C_("x",e,t,n))];case"Exp":return[dv(C_("x",e,t,n))];case"Expm1":return[tC(C_("x",e,t,n))];case"Floor":return[iv(C_("x",e,t,n))];case"Log":return[hv(C_("x",e,t,n))];case"Log1p":return[Sk(C_("x",e,t,n))];case"Imag":return[bw(C_("x",e,t,n))];case"Neg":return[Dv(C_("x",e,t,n))];case"Reciprocal":return[pC(C_("x",e,t,n))];case"Real":return[xw(C_("x",e,t,n))];case"Relu":return[qv(C_("x",e,t,n))];case"Round":return[ck(C_("x",e,t,n))];case"Selu":return[Xv(C_("x",e,t,n))];case"Sigmoid":return[Yv(C_("x",e,t,n))];case"Sin":return[gN(C_("x",e,t,n))];case"Sign":return[fC(C_("x",e,t,n))];case"Sinh":return[bN(C_("x",e,t,n))];case"Softplus":return[sw(C_("x",e,t,n))];case"Sqrt":return[iw(C_("x",e,t,n))];case"Square":return[Rv(C_("x",e,t,n))];case"Tanh":return[uw(C_("x",e,t,n))];case"Tan":return[gC(C_("x",e,t,n))];case"ClipByValue":return[Ox(C_("x",e,t,n),C_("clipValueMin",e,t,n),C_("clipValueMax",e,t,n))];case"Relu6":return[Sw(C_("x",e,t,n))];case"Rsqrt":return[AN(T_(e.inputNames[0],t,n))];case"Prod":return[dC(C_("x",e,t,n),C_("axes",e,t,n))];case"LeakyRelu":return[cv(C_("x",e,t,n),C_("alpha",e,t,n))];case"Prelu":return[Vv(C_("x",e,t,n),C_("alpha",e,t,n))];case"IsNan":return[sC(T_(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"control":return wA(e,t,n);case"convolution":return rx(()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const r=C_("stride",e,t,n),s=C_("pad",e,t,n),a=C_("dataFormat",e,t,n).toUpperCase(),i=C_("dilation",e,t,n);return[Wx(C_("x",e,t,n),C_("filter",e,t,n),r,s,a,i)]}case"Conv2D":{const r=C_("strides",e,t,n),s=A_(e,t,n),a=C_("dataFormat",e,t,n).toUpperCase(),i=C_("dilations",e,t,n);return[Vx(C_("x",e,t,n),C_("filter",e,t,n),[r[1],r[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:a,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=IA(e,t,n);return[Aw({x:C_("x",e,t,n),filter:C_("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:a,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=IA(e,t,n);return[Dw({x:C_("x",e,t,n),filter:C_("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=C_("outputShape",e,t,n),s=C_("strides",e,t,n),a=A_(e,t,n);return[Hx(C_("x",e,t,n),C_("filter",e,t,n),r,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=C_("strides",e,t,n),s=A_(e,t,n),a=C_("dilations",e,t,n),i=C_("dataFormat",e,t,n).toUpperCase();return[Kx(C_("input",e,t,n),C_("filter",e,t,n),[r[1],r[2]],s,i,[a[1],a[2]])]}case"Conv3D":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("dataFormat",e,t,n).toUpperCase(),i=C_("dilations",e,t,n);return[Gx(C_("x",e,t,n),C_("filter",e,t,n),[r[1],r[2],r[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("kernelSize",e,t,n);return[Ex(C_("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("kernelSize",e,t,n);return[xv(C_("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("kernelSize",e,t,n),i=C_("includeBatchInIndex",e,t,n),{result:o,indexes:l}=kA(C_("x",e,t,n),[a[1],a[2]],[r[1],r[2]],s,i);return[o,l]}case"AvgPool3D":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("kernelSize",e,t,n);return[_x(C_("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("kernelSize",e,t,n);return[vv(C_("x",e,t,n),[a[1],a[2],a[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=C_("strides",e,t,n),s=C_("pad",e,t,n),a=C_("dilations",e,t,n),i=r[1],o=r[2],l=a[1],u=a[2];return[YS(C_("x",e,t,n),C_("filter",e,t,n),[i,o],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"creation":return rx(()=>((e,t,n)=>{switch(e.op){case"Fill":{const r=C_("shape",e,t,n),s=C_("dtype",e,t,n);return[av(r,C_("value",e,t,n),s)]}case"LinSpace":return[NA(C_("start",e,t,n),C_("stop",e,t,n),C_("num",e,t,n))];case"Multinomial":{const r=C_("logits",e,t,n),s=C_("numSamples",e,t,n),a=C_("seed",e,t,n);return[SA(r,s,a)]}case"OneHot":{const r=C_("indices",e,t,n),s=C_("depth",e,t,n),a=C_("onValue",e,t,n),i=C_("offValue",e,t,n);return[Mv(r,s,a,i)]}case"Ones":return[zv(C_("shape",e,t,n),C_("dtype",e,t,n))];case"OnesLike":return[Pv(C_("x",e,t,n))];case"RandomUniform":return[jv(C_("shape",e,t,n),C_("minval",e,t,n),C_("maxval",e,t,n),C_("dtype",e,t,n))];case"Range":return[hk(C_("start",e,t,n),C_("stop",e,t,n),C_("step",e,t,n),C_("dtype",e,t,n))];case"TruncatedNormal":{const r=C_("shape",e,t,n),s=C_("mean",e,t,n),a=C_("stdDev",e,t,n),i=C_("seed",e,t,n);return[hw(r,s,a,C_("dtype",e,t,n),i)]}case"Zeros":return[Lv(C_("shape",e,t,n),C_("dtype",e,t,n))];case"ZerosLike":return[mw(C_("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"dynamic":return _A(e,t,n);case"evaluation":return rx(()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const r=C_("x",e,t,n),s=C_("k",e,t,n),a=C_("sorted",e,t,n),i=yC(r,s,a);return[i.values,i.indices]}case"Unique":{const r=C_("x",e,t,n),s=bC(r);return[s.values,s.indices]}case"UniqueV2":{const r=C_("x",e,t,n),s=C_("axis",e,t,n),a=bC(r,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"image":return rx(()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=C_("images",e,t,n),s=C_("size",e,t,n),a=C_("alignCorners",e,t,n),i=C_("halfPixelCenters",e,t,n);return[Dk.resizeBilinear(r,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{const r=C_("images",e,t,n),s=C_("size",e,t,n),a=C_("alignCorners",e,t,n),i=C_("halfPixelCenters",e,t,n);return[Dk.resizeNearestNeighbor(r,[s[0],s[1]],a,i)]}case"CropAndResize":{const r=C_("image",e,t,n),s=C_("boxes",e,t,n),a=C_("boxInd",e,t,n),i=C_("cropSize",e,t,n),o=C_("method",e,t,n),l=C_("extrapolationValue",e,t,n);return[Dk.cropAndResize(r,s,a,i,o,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"graph":return rx(()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=C_("default",e,t,n);return[T_(e.name,t,n)||r];case"Placeholder":return[T_(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[R_(C_("x",e,t,n))];case"IdentityN":return C_("x",e,t,n).map(e=>R_(e));case"Snapshot":return[R_(C_("x",e,t,n))];case"Shape":return[cw(C_("x",e,t,n).shape,"int32")];case"ShapeN":return C_("x",e,t,n).map(e=>cw(e.shape));case"Size":return[lx(C_("x",e,t,n).size,"int32")];case"Rank":return[lx(C_("x",e,t,n).rank,"int32")];case"NoOp":return[lx(1)];case"Print":const s=C_("x",e,t,n),a=C_("data",e,t,n),i=C_("message",e,t,n),o=C_("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<a.length;e++)console.log(Array.prototype.slice.call(a[e].dataSync()).slice(0,o));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"logical":return rx(()=>((e,t,n)=>{switch(e.op){case"Equal":return[tv(C_("a",e,t,n),C_("b",e,t,n))];case"NotEqual":return[Ov(C_("a",e,t,n),C_("b",e,t,n))];case"Greater":return[lv(C_("a",e,t,n),C_("b",e,t,n))];case"GreaterEqual":return[uv(C_("a",e,t,n),C_("b",e,t,n))];case"Less":return[ZN(C_("a",e,t,n),C_("b",e,t,n))];case"LessEqual":return[uk(C_("a",e,t,n),C_("b",e,t,n))];case"LogicalAnd":return[bv(C_("a",e,t,n),C_("b",e,t,n))];case"LogicalNot":return[SS(C_("a",e,t,n))];case"LogicalOr":return[oC(C_("a",e,t,n),C_("b",e,t,n))];case"Select":case"SelectV2":return[fw(C_("condition",e,t,n),C_("a",e,t,n),C_("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"matrices":return rx(()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ow(C_("a",e,t,n),C_("b",e,t,n),C_("transposeA",e,t,n),C_("transposeB",e,t,n))];case"Einsum":return[FA(C_("equation",e,t,n),...C_("tensors",e,t,n))];case"Transpose":return[gw(C_("x",e,t,n),C_("perm",e,t,n))];case"_FusedMatMul":const[r,s]=C_("fusedOps",e,t,n),a="biasadd"===r,i="prelu"===s,o=C_("numArgs",e,t,n),l=C_("leakyreluAlpha",e,t,n);if(a){if(i&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=C_("args",e,t,n);return[Mw({a:C_("a",e,t,n),b:C_("b",e,t,n),transposeA:C_("transposeA",e,t,n),transposeB:C_("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"normalization":return rx(()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Ax(C_("x",e,t,n),C_("mean",e,t,n),C_("variance",e,t,n),C_("offset",e,t,n),C_("scale",e,t,n),C_("epsilon",e,t,n))];case"LRN":return[aC(C_("x",e,t,n),C_("radius",e,t,n),C_("bias",e,t,n),C_("alpha",e,t,n),C_("beta",e,t,n))];case"Softmax":return[rw(C_("x",e,t,n))];case"LogSoftmax":return[yv(C_("x",e,t,n))];case"SparseToDense":return[DA(C_("sparseIndices",e,t,n),C_("outputShape",e,t,n),C_("sparseValues",e,t,n),C_("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"reduction":return rx(()=>((e,t,n)=>{switch(e.op){case"Max":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[pv(C_("x",e,t,n),r,s)]}case"Mean":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[kv(C_("x",e,t,n),r,s)]}case"Min":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[mk(C_("x",e,t,n),r,s)]}case"Sum":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[gv(C_("x",e,t,n),r,s)]}case"All":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[dx(C_("x",e,t,n),r,s)]}case"Any":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[px(C_("x",e,t,n),r,s)]}case"ArgMax":{const r=C_("axis",e,t,n);return[fx(C_("x",e,t,n),r)]}case"ArgMin":{const r=C_("axis",e,t,n);return[US(C_("x",e,t,n),r)]}case"Prod":{const r=C_("axis",e,t,n),s=C_("keepDims",e,t,n);return[dC(C_("x",e,t,n),r,s)]}case"Cumsum":{const r=C_("axis",e,t,n),s=C_("exclusive",e,t,n),a=C_("reverse",e,t,n);return[vN(C_("x",e,t,n),r,s,a)]}case"Bincount":const r=C_("x",e,t,n),s=C_("weights",e,t,n),a=C_("size",e,t,n);return[lk(r,s,a)];case"DenseBincount":{const r=C_("x",e,t,n),s=C_("weights",e,t,n),a=C_("size",e,t,n),i=C_("binaryOutput",e,t,n);return[OA(r,s,a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"slice_join":return rx(()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=C_("n",e,t,n),s=C_("axis",e,t,n);let a=C_("tensors",e,t,n);return a=a.slice(0,r),[Mx(a,s)]}case"Gather":{const r=C_("x",e,t,n),s=C_("indices",e,t,n);return[ov(r,kb(s,"int32"),0)]}case"GatherV2":{const r=C_("axis",e,t,n),s=C_("batchDims",e,t,n),a=C_("x",e,t,n),i=C_("indices",e,t,n);return[ov(a,kb(i,"int32"),r,s)]}case"Reverse":{const r=C_("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const a=C_("x",e,t,n);return[Kv(a,s)]}case"ReverseV2":{const r=C_("axis",e,t,n),s=C_("x",e,t,n);return[Kv(s,r)]}case"Slice":{const r=C_("begin",e,t,n),s=C_("size",e,t,n);return[Jv(C_("x",e,t,n),r,s)]}case"StridedSlice":{const r=C_("begin",e,t,n),s=C_("end",e,t,n),a=C_("strides",e,t,n),i=C_("beginMask",e,t,n),o=C_("endMask",e,t,n),l=C_("ellipsisMask",e,t,n),u=C_("newAxisMask",e,t,n),c=C_("shrinkAxisMask",e,t,n),h=C_("x",e,t,n);return[mC(h,r,s,a,i,o,l,u,c)]}case"Pack":return rx(()=>{const r=C_("axis",e,t,n),s=C_("tensors",e,t,n),a=s[0].shape,i=ow(s[0]).shape,o=s.map(e=>{const t=Wd(e.shape,a);if(!t&&!Wd(ow(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:$x(e,a)});return[lw(o,r)]});case"Unpack":{const r=C_("axis",e,t,n),s=C_("tensor",e,t,n);return dw(s,r)}case"Tile":{const r=C_("reps",e,t,n);return[rv(C_("x",e,t,n),r)]}case"Split":case"SplitV":{const r=C_("axis",e,t,n),s=C_("numOrSizeSplits",e,t,n),a=C_("x",e,t,n);return aw(a,s,r)}case"ScatterNd":{const r=C_("indices",e,t,n),s=C_("values",e,t,n),a=C_("shape",e,t,n);return[MA(r,s,a)]}case"GatherNd":{const r=C_("x",e,t,n),s=C_("indices",e,t,n);return[LA(r,s)]}case"SparseToDense":{const r=C_("sparseIndices",e,t,n),s=C_("outputShape",e,t,n),a=C_("sparseValues",e,t,n),i=C_("defaultValue",e,t,n);return[DA(r,a,s,a.dtype===i.dtype?i:kb(i,a.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"sparse":return rx(()=>((e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:a,reverseIndexMap:i}=Mk.sparseFillEmptyRows(C_("indices",e,t,n),C_("values",e,t,n),C_("denseShape",e,t,n),C_("defaultValue",e,t,n));return[r,s,a,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=Mk.sparseReshape(C_("inputIndices",e,t,n),C_("inputShape",e,t,n),C_("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[Mk.sparseSegmentMean(C_("data",e,t,n),C_("indices",e,t,n),C_("segmentIds",e,t,n))];case"SparseSegmentSum":return[Mk.sparseSegmentSum(C_("data",e,t,n),C_("indices",e,t,n),C_("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"spectral":return rx(()=>((e,t,n)=>{switch(e.op){case"FFT":return[vw(C_("x",e,t,n))];case"IFFT":return[kw(C_("x",e,t,n))];case"RFFT":return[ww(C_("x",e,t,n))];case"IRFFT":return[Iw(C_("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"string":return rx(()=>((e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=Lk.stringNGrams(C_("data",e,t,n),C_("dataSplits",e,t,n),C_("separator",e,t,n),C_("nGramWidths",e,t,n),C_("leftPad",e,t,n),C_("rightPad",e,t,n),C_("padWidth",e,t,n),C_("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:a}=Lk.stringSplit(C_("input",e,t,n),C_("delimiter",e,t,n),C_("skipEmpty",e,t,n));return[r,s,a]}case"StringToHashBucketFast":return[Lk.stringToHashBucketFast(C_("input",e,t,n),C_("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"transformation":return rx(()=>((e,t,n)=>{switch(e.op){case"Cast":return[kb(C_("x",e,t,n),C_("dtype",e,t,n))];case"ExpandDims":{const r=C_("axis",e,t,n);return[nv(C_("x",e,t,n),r)]}case"Squeeze":{const r=C_("axis",e,t,n);return[ow(C_("x",e,t,n),r)]}case"Reshape":return[$x(C_("x",e,t,n),C_("shape",e,t,n))];case"MirrorPad":return[uC(C_("x",e,t,n),C_("padding",e,t,n),C_("mode",e,t,n))];case"PadV2":case"Pad":return[Bv(C_("x",e,t,n),C_("padding",e,t,n),C_("constantValue",e,t,n))];case"SpaceToBatchND":{const r=C_("blockShape",e,t,n),s=C_("paddings",e,t,n);return[sN(C_("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=C_("blockShape",e,t,n),s=C_("crops",e,t,n);return[LS(C_("x",e,t,n),r,s)]}case"DepthToSpace":{const r=C_("blockSize",e,t,n),s=C_("dataFormat",e,t,n).toUpperCase();return[ZS(C_("x",e,t,n),r,s)]}case"BroadcastTo":return[pw(C_("x",e,t,n),C_("shape",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"hash_table":return RA(e,t,n,r);case"custom":const s=S_(e.op);if(s&&s.customExecutor)return s.customExecutor(new pA(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return mp(s)?s.then(e=>[].concat(e)):[].concat(s)}class PA{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function BA(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=Object.keys(e).map(e=>__(e)[0]);let c=[];null!=r&&(c=r.map(e=>__(e.name)[0]));const h=[...t];for(;h.length>0;){const e=h.pop();(HA(e)||GA(e)||jA(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&-1===u.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{l.has(e.name)||(l.add(e.name),h.push(e))}):a.push(e.name))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}const VA=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],WA=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],UA=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function HA(e){return VA.indexOf(e.op)>=0}function GA(e){return WA.indexOf(e.op)>=0}function jA(e){return UA.indexOf(e.op)>=0}class qA{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new qA(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=BA(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:s}=n,a=[],i=Object.keys(s).map(e=>__(e)[0]).map(t=>e.nodes[t]),o=e.initNodes;i.forEach(e=>{r.has(e.name)&&a.push(e)}),e.weights.forEach(e=>{r.has(e.name)&&a.push(e)}),null!=o&&o.forEach(e=>{r.has(e.name)&&a.push(e)});const l=new Set,u=[];for(;a.length>0;){const e=a.pop();l.add(e.name),t[e.name]||u.push(e),e.children.forEach(e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every(e=>l.has(e.name))&&a.push(e)})}return u}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[__(e)[0]]),s=t.map(e=>__(e)[0]);let a=s.map(e=>this.graph.nodes[e]);0===a.length&&(a=this._outputs);const i=this.getCompilationKey(r,a);let o=this.compiledMap.get(i);null==o&&(o=this.compile(e,a),this.compiledMap.set(i,o));const l={},u={};return rx(()=>{const n=new PA(this.weightMap,l,u,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,s]=__(t),a=[];a[s]=e[t],r[n]=a});const a=this.getFrozenTensorIds(r),i={};for(let e=0;e<o.length;e++){const t=o[e];if(!r[t.name]){const e=zA(t,r,n,this._resourceManager);if(mp(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,a,s,i)}}return null==this.parent&&n.dispose(a),t.map(e=>T_(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){"control"!==t.category&&-1===a.indexOf(e)&&(n[e].forEach(e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=function(e,t,n){return t[E_(e,n.currentContextId)]}(e.name,n,r);null!=t&&t.forEach(e=>{if(e&&!e.kept&&!s.has(e.id)){const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}})}}))}executeAsync(e,t){var n=this;return _d(function*(){return n._executeAsync(e,t)})()}_executeAsync(e,t,n=!1,r={},s={}){var a=this;return _d(function*(){n||(e=a.mapInputs(e),a.checkInputs(e),a.checkInputShapeAndType(e),t=a.mapOutputs(t),a.checkOutputs(t));const i=new PA(a.weightMap,r,s,a.functionExecutorMap),o=yield a.executeWithControlFlow(e,i,t,n),l=t.map(e=>T_(e,o,i)),u=l.map(e=>e.id),c=Object.keys(e).map(t=>e[t].id),h=new Set([...u,...c,...a.weightIds]);return Object.keys(o).forEach(e=>{o[e].forEach(e=>{!e||e.kept||e.isDisposed||h.has(e.id)||e.dispose()})}),null==a.parent&&i.dispose(h),l})()}executeFunctionAsync(e,t,n){var r=this;return _d(function*(){const s=e.reduce((e,t,n)=>(e[r.inputs[n].name]=t,e),{});return r._executeAsync(s,r.outputNodes,!0,t,n)})()}executeWithControlFlow(e,t,n,r){var s=this;return _d(function*(){const a=Object.keys(e),i=a.map(e=>s.graph.nodes[__(e)[0]]),o=n.map(e=>__(e)[0]);let l=o.map(e=>s.graph.nodes[e]);0===l.length&&(l=s._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:d}=BA(e,l,s.weightMap,s._initNodes),p=[...i,...s.graph.weights,...s._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},s.weightMap);Object.keys(e).forEach(t=>{const[n,r]=__(t),s=[];s[r]=e[t],f[n]=s});const m={},g=s.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=s.processStack(i,p,t,f,y,g,o,m,u);yield Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter(e=>!HA(e)&&!T_(e.name,f,t)).map(e=>e.name);if(b.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f})()}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&C_("isConstant",e.node,r,n)&&([c]=$_(e.node.name,n)),null==r[e.node.name]){const h=zA(e.node,r,n,this._resourceManager);c||([c]=$_(e.node.name,n));const d=n.currentContext;mp(h)?u.push(h.then(u=>(r[c]=u,n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u))):(r[c]=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach(e=>{const[i]=$_(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!T_(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!T_(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=__(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Ld(e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&Ld(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=__(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(e){e.forEach(e=>{const[t]=__(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class KA{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class XA{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new KA}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=Fb(e,this.loadOptions);else{const t=Zy.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(Fb(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){var e=this;return _d(function*(){if(e.findIOHandler(),null==e.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=yield e.handler.load();return e.loadSync(t)})()}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=function(e,t){const n={};let r,s=0;for(const a of t){const t=a.name,i=a.dtype,o=a.shape,l=Vd(o);let u;if("quantization"in a){const n=a.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${a.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${a.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${a.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const o=Vy[n.dtype],c=e.slice(s,s+l*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let e=0;e<h.length;e++)u[e]=h[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=Xy()),u=r(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let e=0;e<h.length;e++)u[e]=Math.round(h[e]*n.scale+n.min)}s+=l*o}else if("string"===i){const t=Vd(a.shape);u=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+4))[0];s+=4;const n=new Uint8Array(e.slice(s,s+t));u.push(n),s+=t}}else{const r=Vy[i],a=e.slice(s,s+l*r);if("float32"===i)u=new Float32Array(a);else if("int32"===i)u=new Int32Array(a);else if("bool"===i)u=new Uint8Array(a);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);{u=new Float32Array(a);const e=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let t=0;t<e.length;t++)e[t]=u[2*t],r[t]=u[2*t+1];const s=By(e,o,"float32"),i=By(r,o,"float32");n[t]=zy(s,i),s.dispose(),i.dispose()}}s+=l*r}"complex64"!==i&&(n[t]=By(u,o,i))}return n}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new qA(J_.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=J_.Instance.transformGraph(e.modelInitializer);this.initializer=new qA(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(e,t){var n=this;return _d(function*(){if("string"==typeof e){const t=Yy(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(n.artifacts)})()}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof cy||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}executeAsync(e,t){var n=this;return _d(function*(){e=n.normalizeInputs(e),t=n.normalizeOutputs(t);const r=yield n.executor.executeAsync(e,t);return r.length>1?r:r[0]})()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function ZA(){return(ZA=_d(function*(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new XA(e,t);return yield n.load(),n})).apply(this,arguments)}function YA(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ld("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const JA=BI;let QA=(()=>{class e extends Rd{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ad(this,tx())}nextDataId(){return e.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,bp().get("IS_NODE")&&yI("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&tp(n[0])){const s=n.map(e=>Zg(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}read(e){var t=this;return _d(function*(){return t.readSync(e)})()}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?xI(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>Yg(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return wb(e.shape,e.dtype,n)}makeOutput(e,t,n){const r=this.write(e,t,n);return tx().makeTensorFromDataId(r,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return _d(function*(){const t=Xg();return e(),{kernelMs:Xg()-t}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){YA([e],"where");const t=this.readSync(e.dataId);return JA(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return e.nextDataId=0,e})();function eR(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;if(YA(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,l=o.data.get(i.dataId).values,u=Vd(i.shape),c=n||i.dtype,h=Yd(c,u);for(let e=0;e<u;++e)h[e]=t(l[e],s);return o.makeTensorInfo(i.shape,c,h)}}function tR(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;if(YA(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,l=o.data.get(i.dataId).values,u=n||i.dtype,c=t(l,u,s);return o.makeTensorInfo(i.shape,u,c)}}ix("cpu",()=>new QA,1);const nR=eR(bf,e=>e>=0?e:Math.exp(e)-1),rR={kernelName:bf,backendName:"cpu",kernelFunc:nR};function sR(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const aR={kernelName:Of,backendName:"cpu",kernelFunc:sR};function iR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;YA([s],"leakyRelu");const i=Vd(s.shape),o=n.data.get(s.dataId).values,l=Zd("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const oR={kernelName:Vf,backendName:"cpu",kernelFunc:iR};function lR(e){return(t,n,r,s,a)=>{const i=ev(t,n),o=i.length,l=ip(i),u=Zd(a,Vd(i)),c=t.length,h=n.length,d=ip(t),p=ip(n),f=Jx(t,i),m=Jx(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<u.length;++g){const t=fp(g,o,l),n=t.slice(-c);f.forEach(e=>n[e]=0);const a=pp(n,c,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const y=pp(i,h,p);u[g]=e(r[a],s[y])}return[u,i]}}const uR=lR((e,t)=>e<0?t*e:e);function cR(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;YA([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=uR(r.shape,s.shape,a,i,r.dtype);return n.makeTensorInfo(l,r.dtype,o)}const hR={kernelName:km,backendName:"cpu",kernelFunc:cR},dR=eR(Tm,e=>Math.max(0,e)),pR={kernelName:Tm,backendName:"cpu",kernelFunc:dR},fR=eR(Fm,e=>Math.min(Math.max(0,e),6)),mR={kernelName:Fm,backendName:"cpu",kernelFunc:fR},gR=eR(Hm,e=>1/(1+Math.exp(-e))),yR={kernelName:Hm,backendName:"cpu",kernelFunc:gR};function bR(e,t,n,r,s){if("linear"===n)return sR({inputs:{x:t},backend:e});if("relu"===n)return dR({inputs:{x:t},backend:e});if("elu"===n)return nR({inputs:{x:t},backend:e});if("relu6"===n)return fR({inputs:{x:t},backend:e});if("prelu"===n)return cR({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return iR({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return gR({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function xR(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const vR={kernelName:qp,backendName:"cpu",kernelFunc:xR};function wR(e,t,n="float32"){if("complex64"===n)return xR({inputs:{real:wR(e,t,"float32"),imag:wR(e,t,"float32")},backend:e});const r=cp(Vd(t),n);return e.makeTensorInfo(t,n,r)}function kR(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const IR={kernelName:Sm,backendName:"cpu",kernelFunc:kR};function NR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return sR({inputs:{x:s},backend:n});const e=wR(n,s.shape,s.dtype),t=NR({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=xR({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=kR({inputs:{input:s},backend:n}),t=NR({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Jd(s.dtype,a)){const e=sR({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a){const e=n.data.get(s.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(s.shape,"int32",t)}if("bool"===a){const e=n.data.get(s.dataId).values,t=Kg([0],s.dtype),[r,a]=lR((e,t)=>e!==t?1:0)(s.shape,[],e,t,"bool");return n.makeTensorInfo(a,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const SR={kernelName:Hp,backendName:"cpu",kernelFunc:NR};function CR(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:a,b:i}=n,o=s;YA([a,i],e);const l=o.data.get(a.dataId).values,u=o.data.get(i.dataId).values,c="string"===a.dtype?zI(l):l,h="string"===a.dtype?zI(u):u,d=r||a.dtype,[p,f]=t(a.shape,i.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:e,backend:s})=>{const{a:a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=NR({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.imag,s=o.data.get(t.complexTensorInfos.real.dataId).values,l=o.data.get(r.dataId).values,u=NR({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(u.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(a.shape,i.shape,s,l,d,p),y=o.makeTensorInfo(g,"float32",f),b=o.makeTensorInfo(g,"float32",m),x=xR({inputs:{real:y,imag:b},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(b),x}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[l,u]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(u,s,l)}}}function TR(e){return(t,n,r,s,a,i)=>{const o=ev(t,n),l=Vd(o),u=o.length,c=ip(o),h=Zd("float32",l),d=Zd("float32",l),p=Jx(t,o),f=Jx(n,o),m=xI(r,s),g=xI(a,i),y=t.length,b=ip(t),x=n.length,v=ip(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=fp(w,u,c),n=t.slice(-y);p.forEach(e=>n[e]=0);const r=pp(n,y,b),s=t.slice(-x);f.forEach(e=>s[e]=0);const a=pp(s,x,v),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);h[w]=i.real,d[w]=i.imag}return[h,d,o]}}const $R=lR((e,t)=>e+t),ER=TR((e,t,n,r)=>({real:e+n,imag:t+r})),_R=CR(Cp,$R,ER),AR={kernelName:Cp,backendName:"cpu",kernelFunc:_R};function RR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Vd(s.shape),o=qd(a,i),l=Vd(o);Ld(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=o,e.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const FR={kernelName:$m,backendName:"cpu",kernelFunc:RR};function DR(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;YA([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],h=o?a.shape[u-1]:a.shape[u-2],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Vd(f),y=Vd(m);Ld(l>=2&&u>=2&&(g===y||1===g||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const b=(g>y?s.shape.slice(0,-2):a.shape.slice(0,-2)).concat([d,p]);Ld(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const x=o?[y,p,h]:[y,h,p],v=RR({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,d]:[g,d,c]}}),w=RR({inputs:{x:a},backend:n,attrs:{shape:x}}),k=i?v.shape[1]:v.shape[2],I=i?v.shape[2]:v.shape[1],N=o?w.shape[1]:w.shape[2],S=Math.max(g,y),C=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,$=ip(v.shape),E=ip(w.shape),[_,A,R]=i?[$[0],1,$[1]]:[$[0],$[1],1],[F,D,O]=o?[1,E[1],E[0]]:[E[1],1,E[0]],M=I*N,L=wb([S,I,N],v.dtype),z=L.values,P=n.blockSize;for(let B=0;B<S;B++)for(let e=0;e<I;e+=P)for(let t=0;t<N;t+=P)for(let n=0;n<k;n+=P){const r=Math.min(e+P,I),s=Math.min(t+P,N),a=Math.min(n+P,k);for(let i=e;i<r;i++)for(let e=t;e<s;e++){let t=0;for(let r=n;r<a;r++){const n=Math.min(B,g-1)*_,s=Math.min(B,y-1)*O;t+=C[n+i*A+r*R]*T[r*F+e*D+s]}z[B*M+(i*N+e)]+=t}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const OR={kernelName:Vp,backendName:"cpu",kernelFunc:DR},MR={kernelName:kg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=DR({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=_R({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=bR(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function LR(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const zR={kernelName:Ip,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;YA(t,"abs");let r=new Float32Array(Vd(t.shape));return r=LR(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,"float32")}},PR=eR(Np,e=>Math.acos(e)),BR={kernelName:Np,backendName:"cpu",kernelFunc:PR},VR=eR(Sp,e=>Math.acosh(e)),WR={kernelName:Sp,backendName:"cpu",kernelFunc:VR},UR={kernelName:Tp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;YA(t,"addN");const s=r.map(e=>n.data.get(e.dataId).values),a=wb(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function HR(e,t,n,r,s){const a=t.length,i=Vd(t),o=ip(t),l=ip(s),u=Zd(n,Vd(s));for(let c=0;c<i;++c){const t=fp(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[pp(n,a,l)]=e[c]}return u}function GR(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;YA(s,"transpose");const i=new Array(s.shape.length);for(let l=0;l<i.length;l++)i[l]=s.shape[a[l]];const o=HR(r.data.get(s.dataId).values,s.shape,s.dtype,a,i);return{dataId:r.write(o,i,s.dtype),shape:i,dtype:s.dtype}}const jR={kernelName:fg,backendName:"cpu",kernelFunc:GR},qR={kernelName:$p,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;YA(s,"all");const o=Kd(a,s.shape);let l=o;const u=Ev(l,s.shape.length);let c=s;null!=u&&(c=GR({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Av(l.length,s.shape.length)),$v("all",l,c.shape.length);const[h,d]=Cv(c.shape,l),p=Vd(d),f=cp(Vd(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=RR({inputs:{x:g},backend:n,attrs:{shape:Tv(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},KR={kernelName:Ep,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;YA(s,"any");const o=Kd(a,s.shape);let l=o;const u=Ev(l,s.shape.length);let c=s;null!=u&&(c=GR({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Av(l.length,s.shape.length)),$v("any",l,c.shape.length);const[h,d]=Cv(c.shape,l),p=Vd(d),f=cp(Vd(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=RR({inputs:{x:g},backend:n,attrs:{shape:Tv(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},XR={kernelName:_p,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;YA(s,"argMax");let i=Kd(a,s.shape);const o=Ev(i,s.shape.length);let l=s;const u=[];null!=o&&(l=GR({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Av(i.length,l.shape.length)),i=[i[0]],$v("argMax",i,l.shape.length);const[c,h]=Cv(l.shape,i),d=cp(Vd(c),"int32"),p=Vd(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}d[m]=n}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},ZR={kernelName:Ap,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;YA(s,"argMin");let i=Kd(a,s.shape);const o=Ev(i,s.shape.length);let l=s;const u=[];null!=o&&(l=GR({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Av(i.length,l.shape.length)),i=[i[0]],$v("argMin",i,l.shape.length);const[c,h]=Cv(l.shape,i),d=cp(Vd(c),"int32"),p=Vd(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}d[m]=n}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},YR=eR(Rp,e=>Math.asin(e)),JR={kernelName:Rp,backendName:"cpu",kernelFunc:YR},QR=eR(Fp,e=>Math.asinh(e)),eF={kernelName:Fp,backendName:"cpu",kernelFunc:QR},tF=eR(Dp,e=>Math.atan(e)),nF={kernelName:Dp,backendName:"cpu",kernelFunc:tF},rF=lR((e,t)=>Math.atan2(e,t)),sF=CR(Mp,rF),aF={kernelName:Mp,backendName:"cpu",kernelFunc:sF},iF=eR(Op,e=>Math.atanh(e)),oF={kernelName:Op,backendName:"cpu",kernelFunc:iF};function lF(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=wb(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){const t=v*y,n=v*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const v=y*i-d,w=Math.max(0,v),k=Math.min(s.inHeight,c+v),I=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,c=Math.max(0,i),d=Math.min(s.inWidth,h+i);let y=f,b=0,v=0;for(let t=w;t<k;t+=l){const s=n+t*r[1];for(let t=c;t<d;t+=u){const n=e[s+t*r[2]+m];"max"===a&&n>y?y=n:"avg"===a&&(b+=n,v++)}if(isNaN(y))break}g[I+t*x+m]="avg"===a?b/v:y}}}return m}function uF(e,t,n,r,s=!1,a=!1){const i=wb(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=wb(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const x=Math.min(r.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<x;n+=c){const o=n-h,l=m.get(g,t,n,e);l>v&&(v=l,w=s?a?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(w,g,t,o,e)}}return i}function cF(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=wb(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],N=s.outShape[4];for(let S=0;S<s.batchSize;++S){const t=S*w,n=S*r[0];for(let x=0;x<s.inChannels;++x)for(let w=0;w<s.outDepth;++w){const S=w*i-m;let C=S;for(;C<0;)C+=u;const T=Math.min(s.inDepth,d+S),$=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+i),w=$+t*I;for(let t=0;t<s.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=w+t*N;let k=b,I=0,S=0;for(let t=C;t<T;t+=u){const s=n+t*r[1];for(let t=d;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=h){const s=e[n+t*r[3]+x];if("max"===a&&s>k?k=s:"avg"===a&&(I+=s,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[g+x]="avg"===a?I/S:k}}}}return x}const hF={kernelName:Lp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;YA(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ld(Cx(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=gx(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Wd(u.inShape,u.outShape))c=sR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ip(s.shape),r=lF(e,0,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},dF={kernelName:Pp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;YA(s,"avgPool3d");const c=yx(s.shape,a,i,1,o,l,u),h=cF(n.data.get(s.dataId).values,0,s.dtype,ip(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},pF={kernelName:Bp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;YA([s,a],"avgPool3DGrad");const c=yx(a.shape,i,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=v-1-c.padInfo.front,N=k-1-c.padInfo.left,S=w-1-c.padInfo.top,C=wb(a.shape,"float32"),T=1/(f*m*g),$=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-I,a=n-S,i=r-N;let o=0;for(let t=0;t<v;t+=y){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(a+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=x){const s=(i+t)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(o+=$.get(E,n,r,s,e))}}}C.set(o*T,E,t,n,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},fF={kernelName:zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;YA([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=gx(i.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,v=y-1-c.padInfo.top,w=wb(i.shape,"float32"),k=1/(p*f),I=n.data.get(s.dataId).values,N=wb(s.shape,"float32",I);for(let S=0;S<c.batchSize;++S)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-v,s=n-x;let a=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(s+t)/d;r<0||r>=c.outWidth||Math.floor(r)!==r||(a+=N.get(S,n,r,e))}}w.set(a*k,S,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},mF={kernelName:_f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Ld(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ld(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ld(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),YA([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,x=h.length;let v=0,w=0,k=0,I=0;for(let N=0;N<c.length;++N)m[N]=f[v++]+(c[N]-h[w++])*p[k++]/Math.sqrt(d[I++]+u),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function gF(e,t,n,r,s){const a=Kb(r,t,n),i=Vd(n),o=ip(r);if(a){const n=Xb(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=wb(r,s,"string"===s?zI(e):e),u=wb(n,s);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map((e,n)=>e+t[n]);u.set(l.get(...n),...e)}return"string"===s?PI(u.values):u.values}function yF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;YA(s,"slice");const[o,l]=Zb(s,a,i);Mb(s,o,l);const u=gF(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const bF={kernelName:Bm,backendName:"cpu",kernelFunc:yF},xF={kernelName:Wp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;YA([s],"batchToSpaceND");const o=a.reduce((e,t)=>e*t),l=eI(s.shape,a,o),u=tI(l.length,a.length),c=nI(s.shape,a,o),h=rI(i,a.length),d=sI(c,i,a.length),p=RR({inputs:{x:s},backend:n,attrs:{shape:l}}),f=GR({inputs:{x:p},backend:n,attrs:{perm:u}}),m=RR({inputs:{x:f},backend:n,attrs:{shape:c}}),g=yF({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function vF(e,t,n,r,s){const a=Vd(r),i=cp(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function wF(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=wb([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||i.set(r?1:t.size>0?i.get(o,a)+t.get(o,s):i.get(o,a)+1,o,a)}return i}const kF={kernelName:Up,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=vF(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}};function IF(e){return(t,n,r)=>{const s=Zd(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}const NF=IF(e=>Math.ceil(e)),SF=tR(Gp,NF),CF={kernelName:Gp,backendName:"cpu",kernelFunc:SF},TF=eR(jp,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),$F={kernelName:jp,backendName:"cpu",kernelFunc:TF},EF={kernelName:Kp,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Vd(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.imag,i=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;l++)r[l]=Math.hypot(i[l],o[l]);return n.makeOutput(r,t.shape,"float32")}};function _F(e,t,n,r){const s=Yd(n,Vd(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=Vd(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const a="string"===n?zI(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]})}return s}function AF(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const RF={kernelName:Lf,backendName:"cpu",kernelFunc:AF};function FF(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Kd(s,t[0].shape)[0];let i=Zk(t.map(e=>e.shape),a);if(0===Vd(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>Vd(e.shape)>0);if(1===o.length)return sR({inputs:{x:o[0]},backend:n});if(Xk(o.map(e=>e.shape),a),"complex64"===o[0].dtype){const e=o.map(e=>kR({inputs:{input:e},backend:n})),t=o.map(e=>AF({inputs:{input:e},backend:n})),r=FF({inputs:e,backend:n,attrs:{axis:a}}),s=FF({inputs:t,backend:n,attrs:{axis:a}}),i=xR({inputs:{real:r,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map(e=>{const t=Vd(e.shape.slice(a));return RR({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),u=l.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=Zk(l.map(e=>e.shape),1);const c=_F(u,i,t[0].dtype,1===l[0].shape[0]),h=Zk(o.map(e=>e.shape),a),d=n.makeTensorInfo(h,t[0].dtype,c);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const DF={kernelName:Xp,backendName:"cpu",kernelFunc:FF};function OF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;YA([s,a],"conv2d");const h=Tx(l),d=bx(s.shape,a.shape,i,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new iy(d.outShape,s.dtype),w=ip(s.shape),k=ip(a.shape),I=w[0],N=x?w[1]:w[2],S=x?w[2]:1,C=x?1:w[1],T=v.strides[0],$=x?v.strides[1]:v.strides[2],E=x?v.strides[2]:1,_=x?1:v.strides[1],A=n.data.get(s.dataId).values,R=n.data.get(a.dataId).values,F=v.values;for(let D=0;D<d.batchSize;++D){const e=D*I,t=D*T;for(let n=0;n<d.outHeight;++n){const r=t+n*$,s=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const a=t*k[0],i=e+n*N;for(let e=0;e<d.outWidth;++e){const t=r+e*E,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const s=i+r*S;let o=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[s+e*C];for(let e=0;e<d.outChannels;++e)F[t+e*_]+=n*R[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,F)}const MF={kernelName:Zp,backendName:"cpu",kernelFunc:OF},LF={kernelName:Yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;YA([s,a],"conv2dBackpropFilter");const h=Tx(l),d=bx(s.shape,c,i,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new iy(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=new iy(s.shape,s.dtype,w),N=new iy(a.shape,a.dtype,k);for(let S=0;S<m;++S){const e=Math.max(0,Math.ceil((v-S)/p)),t=Math.min(d.outHeight,(d.inHeight+v-S)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let a=0;a<d.inChannels;++a)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){const e=S+u*p-v;for(let t=r;t<s;++t){const r=n+t*f-x;o+=y?I.get(l,e,r,a)*N.get(l,u,t,i):I.get(l,a,e,r)*N.get(l,i,u,t)}}b.set(o,S,n,a,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},zF={kernelName:Jp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;YA([s,a],"conv2dBackpropInput");const h=ip(a.shape),d=ip(s.shape);let p=Tx(u);const f=bx(i,a.shape,o,1,l,c,!1,p),m=new iy(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,v,w]=h,{batchSize:k,filterHeight:I,filterWidth:N,inChannels:S,inHeight:C,inWidth:T,outChannels:$,outHeight:E,outWidth:_,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;const F=I-1-f.padInfo.top,D=N-1-f.padInfo.left,O="channelsLast"===p,M=m.strides[0],L=O?m.strides[1]:m.strides[2],z=O?m.strides[2]:1,P=O?1:m.strides[1],B=d[0],V=O?d[1]:d[2],W=O?d[2]:1,U=O?1:d[1];for(let H=0;H<k;++H)for(let e=0;e<S;++e)for(let t=0;t<C;++t){const n=t-F,r=Math.max(0,Math.ceil(n/A)),s=Math.min(E,(I+n)/A);for(let a=0;a<T;++a){const i=a-D,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(N+i)/R);let u=0;for(let t=r;t<s;++t){const r=t*A-n;for(let n=o;n<l;++n){const s=B*H+V*t+W*n,a=x*(I-1-r)+v*(N-1-(n*R-i))+w*e;for(let e=0;e<$;++e)u+=y[s+U*e]*b[a+e]}}g[M*H+L*t+z*a+P*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},PF={kernelName:Qp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;YA([s,a],"conv3d");const u=xx(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new iy(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,I=v.values,N=ip(s.shape),S=ip(a.shape);for(let C=0;C<u.batchSize;++C){const e=C*N[0],t=C*v.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*v.strides[1],s=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const a=t*S[0],i=e+n*N[1];for(let e=0;e<u.outHeight;++e){const t=r+e*v.strides[2],n=e*u.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*S[1],o=i+r*N[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=o+t*u.inChannels;let i=s+e*S[2];for(let e=0;e<u.inChannels;++e){const t=w[a+e];for(let e=0;e<u.outChannels;++e)I[n+e]+=t*k[i+e];i+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},BF={kernelName:ef,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;YA([s,a],"conv3dBackpropFilterV2");const u=ip(s.shape),c=ip(a.shape),h=xx(s.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new iy(h.filterShape,"float32"),x=b.values,[v,w,k,I]=b.strides,N=n.data.get(a.dataId).values,[S,C,T,$]=c,E=n.data.get(s.dataId).values,[_,A,R,F]=u,D=h.padInfo.front,O=h.padInfo.left,M=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((D-L)/d)),t=Math.min(h.outDepth,(h.inDepth+D-L)/d),n=L*v;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((M-r)/p)),a=Math.min(h.outHeight,(h.inHeight+M-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((O-n)/f)),l=Math.min(h.outWidth,(h.inWidth+O-n)/f),u=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*I+u;for(let u=0;u<h.outChannels;++u){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*_,g=c*S;for(let c=e;c<t;++c){const e=(L+c*d-D)*A+h,t=c*C+g;for(let c=s;c<a;++c){const s=(r+c*p-M)*R+e,a=c*T+t;for(let e=o;e<l;++e)m+=E[(n+e*f-O)*F+s+i]*N[e*$+a+u]}}}x[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},VF={kernelName:tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;YA([s],"conv3dBackpropInputV2");const u=ip(s.shape),c=ip(a.shape),h=xx(l,a.shape,o,1,i),d=new iy(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(s.dataId).values,[x,v,w,k]=u,I=n.data.get(a.dataId).values,[N,S,C,T]=c,{batchSize:$,filterDepth:E,filterHeight:_,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:O,outChannels:M,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:V,strideWidth:W}=h,U=E-1-h.padInfo.front,H=_-1-h.padInfo.top,G=A-1-h.padInfo.left;for(let j=0;j<$;++j)for(let e=0;e<R;++e)for(let t=0;t<F;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),s=Math.min(L,(E+n)/B);for(let a=0;a<D;++a){const i=a-H,o=Math.max(0,Math.ceil(i/V)),l=Math.min(z,(_+i)/V);for(let u=0;u<O;++u){const c=u-G,h=Math.max(0,Math.ceil(c/W)),d=Math.min(P,(A+c)/W);let $=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<l;++n){const s=n*V-i;for(let a=h;a<d;++a){const i=x*j+v*t+w*n+k*a,o=N*(E-1-r)+S*(_-1-s)+C*(A-1-(a*W-c))+T*e;for(let e=0;e<M;++e)$+=b[i+e]*I[o+e]}}}p[f*j+m*t+g*a+y*u+e]=$}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},WF=eR(nf,e=>Math.cos(e)),UF={kernelName:nf,backendName:"cpu",kernelFunc:WF},HF=eR(rf,e=>Math.cosh(e)),GF={kernelName:rf,backendName:"cpu",kernelFunc:HF},jF={kernelName:af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=a.shape[0],[m,g]=o,y=wb([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=ip(s.shape),k=ip(y.shape);for(let I=0;I<f;I++){const e=4*I,t=b[e],n=b[e+1],r=b[e+2],s=b[e+3],a=x[I];if(a>=c)continue;const i=m>1?(r-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++)y.values[e+t*k[2]+c*k[1]+I*k[0]]=u;else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++)y.values[t+e*k[2]+c*k[1]+I*k[0]]=u;continue}const h=Math.floor(l),f=Math.ceil(l),m=l-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+a*w[0];const o=v[s];s=n+f*w[2]+t*w[1]+a*w[0];const l=v[s];s=n+h*w[2]+r*w[1]+a*w[0];const u=v[s];s=n+f*w[2]+r*w[1]+a*w[0];const d=v[s],p=o+(l-o)*m;s=n+e*k[2]+c*k[1]+I*k[0],y.values[s]=p+(u+(d-u)*m-p)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++)y.values[e+t*k[2]+c*k[1]+I*k[0]]=u;continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++)y.values[e+t*k[2]+c*k[1]+I*k[0]]=v[e+i*w[2]+l*w[1]+a*w[0]]}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},qF={kernelName:sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;YA(s,"cumsum");const l=Ev([a],s.shape.length);let u=s;null!=l&&(u=GR({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Av(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=by(u.dtype,"int32"),d=cp(Vd(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=GR({inputs:{x:g},backend:n,attrs:{perm:_v(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},KF={kernelName:of,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=vF(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=wF(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},XF={kernelName:lf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Ld("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`),Ld(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*a,d=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const r=Math.floor(e/a),s=(n*a+e%a)*p;for(let e=0;e<p;++e)m[g++]=f[e+s+c*(r+u*(t+l*y))]}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function ZF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;YA([s,a],"depthwiseConv2DNative");const c=ip(s.shape),h=ip(a.shape);let d=l;null==d&&(d=[1,1]),Ld(Cx(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=bx(s.shape,a.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,k=new iy(p.outShape,s.dtype),I=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,S=k.values;for(let C=0;C<p.batchSize;++C){const e=C*c[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=i+r*p.inChannels;let o=t,l=a+e*h[1];for(let e=0;e<p.inChannels;++e){const t=I[s+e];for(let e=0;e<w;++e)S[o+e]+=t*N[l+e];o+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const YF={kernelName:uf,backendName:"cpu",kernelFunc:ZF},JF={kernelName:cf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;YA([s,a],"depthwiseConv2dNativeBackpropFilter");const h=bx(s.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new iy(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(s.dataId).values,w=new iy(s.shape,s.dtype,v),k=n.data.get(a.dataId).values,I=new iy(a.shape,a.dtype,k);for(let N=0;N<f;++N){const e=Math.max(0,Math.ceil((b-N)/d)),t=Math.min(h.outHeight,(h.inHeight+b-N)/d);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/x),o=a%x;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=e;o<t;++o){const e=N+o*d-b;for(let t=r;t<s;++t)l+=w.get(u,e,n+t*p-y,i)*I.get(u,o,t,a)}g.set(l,N,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},QF={kernelName:hf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;YA([s,a],"depthwiseConv2DNativeBackpropInput");const h=ip(s.shape),d=ip(a.shape),p=bx(c,a.shape,i,o,l,u,!0),f=new iy(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=h,I=n.data.get(a.dataId).values,[N,S,C]=d,{batchSize:T,filterHeight:$,filterWidth:E,inChannels:_,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:O,strideHeight:M,strideWidth:L}=p,z=$-1-p.padInfo.top,P=E-1-p.padInfo.left,B=F/_;for(let V=0;V<T;++V)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,r=Math.max(0,Math.ceil(n/M)),s=Math.min(D,($+n)/M);for(let a=0;a<R;++a){const i=a-P,o=Math.max(0,Math.ceil(i/L)),l=Math.min(O,(E+i)/L);let u=0;for(let t=r;t<s;++t){const r=t*M-n;for(let n=o;n<l;++n){const s=v*V+w*t+k*n,a=N*($-1-r)+S*(E-1-(n*L-i))+C*e;for(let t=0;t<B;++t)u+=x[s+(e*B+t)]*I[a+t]}}m[g*V+y*t+b*a+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},eD={kernelName:df,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Vd(r.shape),a=n.data.get(r.dataId).values,i=wb([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},tD={kernelName:pf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:I,dilationHeight:N,dilationWidth:S,outShape:C}=mx(r.shape,s.shape,a,i,"NHWC",o),T=Vd(C),$=C.length,E=Yd(r.dtype,T);for(let _=0;_<p;++_)for(let e=0;e<y;++e){const t=e*v-x.top;for(let n=0;n<b;++n){const a=n*w-x.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<I;++t){const l=a+t*S;if(l>=0&&l<m){const a=pp([_,n,l,i],c,ip(r.shape)),p=pp([e,t,i],d,ip(s.shape)),f=u[a]+h[p];f>o&&(o=f)}}}E[pp([_,e,n,i],$,ip(C))]=o}}}return{dataId:l.write(Kg(E,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},nD={kernelName:mf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=lp(r.shape,u.data.get(r.dataId).values),h=lp(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=mx(r.shape,s.shape,i,o,"NHWC",l);Ld(a.rank===S.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const C=lp(S,u.data.get(a.dataId).values),T=hp(s.shape,s.dtype);for(let $=0;$<d;++$)for(let e=0;e<g;++e){const t=e*x-b.top;for(let n=0;n<y;++n){const r=n*v-b.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<w;++e){const n=t+e*I;if(n>=0&&n<p)for(let t=0;t<k;++t){const l=r+t*N;if(l>=0&&l<f){const r=c[$][n][l][s]+h[e][t][s];r>a&&(a=r,i=e,o=t)}}}T[i][o][s]+=C[$][e][n][s]}}}return{dataId:u.write(Kg(T,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},rD={kernelName:ff,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=lp(r.shape,u.data.get(r.dataId).values),h=lp(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:I,dilationWidth:N,outShape:S}=mx(r.shape,s.shape,i,o,"NHWC",l);Ld(a.rank===S.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const C=lp(S,u.data.get(a.dataId).values),T=hp(r.shape,r.dtype);for(let $=0;$<d;++$)for(let e=0;e<g;++e){const t=e*x-b.top;for(let n=0;n<y;++n){const r=n*v-b.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<w;++e){const n=t+e*I;if(n>=0&&n<p)for(let t=0;t<k;++t){const l=r+t*N;if(l>=0&&l<f){const r=c[$][n][l][s]+h[e][t][s];r>a&&(a=r,i=n,o=l)}}}T[$][i][o][s]+=C[$][e][n][s]}}}return{dataId:u.write(Kg(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},sD=lR((e,t)=>e*t),aD=TR((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),iD=CR(hm,sD,aD),oD={kernelName:hm,backendName:"cpu",kernelFunc:iD};function lD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;YA(s,"sum"),o="bool"===s.dtype?NR({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):sR({inputs:{x:s},backend:n});const l=o.shape.length,u=Kd(a,o.shape),c=Ev(u,l);let h=u,d=o;null!=c&&(d=GR({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Av(h.length,l)),$v("sum",h,d.shape.length);const[p,f]=Cv(d.shape,h);let m=wR(n,p,by(d.dtype,"int32"));const g=Vd(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let x=0;x<y.length;++x){const e=x*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[x]=t}if(i){const e=m;m=RR({inputs:{x:m},backend:n,attrs:{shape:Tv(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const uD={kernelName:qm,backendName:"cpu",kernelFunc:lD},cD={kernelName:yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=$I(s,a.length);_I(i.length,l,a);const{path:u,steps:c}=AI(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=EI(p,l[e]);let s;RI(t)?s=a[e]:(s=GR({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Wd(s.shape,i)||(s=RR({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=iD({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=lD({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},hD={kernelName:xf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;YA([r,s],"eluGrad");const a=new Float32Array(Vd(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];a[l]=e>=1?o[l]:o[l]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}},dD=lR((e,t)=>e===t?1:0),pD=CR(wf,dD,null,"bool"),fD={kernelName:wf,backendName:"cpu",kernelFunc:pD},mD=hI,gD=dI,yD=pI,bD=fI,xD=mI,vD=gI,wD=eR(vf,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+mD*n);return t*(1-((((vD*r+xD)*r+bD)*r+yD)*r+gD)*r*Math.exp(-n*n))}),kD={kernelName:vf,backendName:"cpu",kernelFunc:wD},ID=IF(e=>Math.exp(e)),ND=tR(kf,ID),SD={kernelName:kf,backendName:"cpu",kernelFunc:ND};function CD(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Ld(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),RR({inputs:{x:s},backend:n,attrs:{shape:o}})}const TD={kernelName:If,backendName:"cpu",kernelFunc:CD},$D=IF(e=>Math.expm1(e)),ED=tR(Nf,$D),_D={kernelName:Nf,backendName:"cpu",kernelFunc:ED},AD=lR((e,t)=>e/t),RD=CR(gf,AD),FD={kernelName:gf,backendName:"cpu",kernelFunc:RD},DD=lR((e,t)=>e-t),OD=TR((e,t,n,r)=>({real:e-n,imag:t-r})),MD=CR(lg,DD,OD),LD={kernelName:lg,backendName:"cpu",kernelFunc:MD};function zD(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Vd(u),h=Zd("float32",c),d=Zd("float32",c);for(let g=0;g<s;g++){const e=yF({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=yF({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=xR({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=PD(s,t,n),c=xI(i,u);for(let t=0;t<a;t++){const e=II(c,t);h[g*a+t]=e.real,d[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=xR({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function PD(e,t,n){const r=Vd(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const s=BD(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",qg(r,"float32")),i=sR({inputs:{x:a},backend:n}),l=FD.kernelFunc({inputs:{a:e,b:a},backend:n}),u=FD.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return s}return vI(function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=CI(s*r,t,n),l=II(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),NI(r,a,i,s)}return r}(xI(a,i),r,t));var o}function BD(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=xI(e,t),i=n/2,o=wI(a),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=xR({inputs:{real:h,imag:d},backend:s}),f=kI(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),v=xR({inputs:{real:b,imag:x},backend:s}),w=BD(l,u,i,r,s),k=w.real,I=w.imag,N=[k.length],S=s.makeTensorInfo(N,"float32",k),C=s.makeTensorInfo(N,"float32",I),T=xR({inputs:{real:S,imag:C},backend:s}),$=BD(m,g,i,r,s),E=$.real,_=$.imag,A=[E.length],R=s.makeTensorInfo(A,"float32",E),F=s.makeTensorInfo(A,"float32",_),D=xR({inputs:{real:R,imag:F},backend:s}),O=SI(n,r),M=[O.real.length],L=s.makeTensorInfo(M,"float32",O.real),z=s.makeTensorInfo(M,"float32",O.imag),P=xR({inputs:{real:L,imag:z},backend:s}),B=iD({inputs:{a:P,b:D},backend:s}),V=_R({inputs:{a:T,b:B},backend:s}),W=MD({inputs:{a:T,b:B},backend:s}),U=kR({inputs:{input:V},backend:s}),H=kR({inputs:{input:W},backend:s}),G=AF({inputs:{input:V},backend:s}),j=AF({inputs:{input:W},backend:s}),q=FF({inputs:[U,H],backend:s,attrs:{axis:0}}),K=FF({inputs:[G,j],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Z=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}const VD={kernelName:Sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Vd(r.shape),a=r.shape[r.shape.length-1],i=RR({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=zD(i,!1,n),l=RR({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function WD(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||rp(s),o=Yd(i,Vd(r));return function(e,t,n){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const UD={kernelName:Cf,backendName:"cpu",kernelFunc:WD},HD={kernelName:Tf,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=Zd(n.dtype,Vd(n.shape)),[a,i,o,l]=n.shape,u=r.data.get(n.dataId).values;for(let c=0;c<a;c++){const e=c*o*i*l;for(let t=0;t<i;t++){const n=t*(o*l);for(let r=0;r<o;r++){const i=r*l;for(let c=0;c<l;c++){const h=Math.round(o-[a,t,r,c][2]),d=e+n+i+c;let p=u[d];h>=0&&h<o&&(p=u[e+n+h*l+c]),s[d]=p}}}}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},GD=IF(e=>Math.floor(e)),jD=tR($f,GD),qD={kernelName:$f,backendName:"cpu",kernelFunc:jD},KD=lR((e,t)=>Math.floor(e/t)),XD=CR(Ef,KD,null,"int32"),ZD={kernelName:Ef,backendName:"cpu",kernelFunc:XD},YD={kernelName:Ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=OF({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=_R({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=bR(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},JD={kernelName:Ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=ZF({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=_R({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=bR(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function QD(e,t,n,r,s,a,i,o,l){const u=wb([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=l/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)u.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return u}const eO={kernelName:Rf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Vd(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,h]=aI(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=QD(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,a);return n.makeTensorInfo(l,r.dtype,d.values)}};function tO(e,t,n){const r=wb(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=t.locToIndex([n[0],n[2]]);n[2]=t.values[a];const i=e.locToIndex(n);r.values[s]=e.values[i]}return r}const nO={kernelName:Af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;YA([s,a],"gatherV2");let l=o;null==o&&(l=0);const u=Vd(a.shape),c=LI(s,a,Kd(i,s.shape)[0],l),h=RR({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=RR({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}}),p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize],f=n.bufferSync(d),m=tO(n.bufferSync(h),f,p);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},rO=lR((e,t)=>e>t?1:0),sO=CR(Ff,rO,null,"bool"),aO={kernelName:Ff,backendName:"cpu",kernelFunc:sO},iO=lR((e,t)=>e>=t?1:0),oO=CR(Df,iO,null,"bool"),lO={kernelName:Df,backendName:"cpu",kernelFunc:oO},uO={kernelName:Mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Vd(r.shape),a=r.shape[r.shape.length-1],i=RR({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=zD(i,!0,n),l=RR({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},cO=eR(zf,e=>Number.isFinite(e)?1:0,"bool"),hO={kernelName:zf,backendName:"cpu",kernelFunc:cO},dO=eR(Pf,e=>Math.abs(e)===1/0?1:0,"bool"),pO={kernelName:Pf,backendName:"cpu",kernelFunc:dO},fO=eR(Bf,e=>Number.isNaN(e)?1:0,"bool"),mO={kernelName:Bf,backendName:"cpu",kernelFunc:fO},gO=lR((e,t)=>e<t?1:0),yO=CR(Wf,gO,null,"bool"),bO={kernelName:Wf,backendName:"cpu",kernelFunc:yO},xO=lR((e,t)=>e<=t?1:0),vO=CR(Uf,xO,null,"bool"),wO={kernelName:Uf,backendName:"cpu",kernelFunc:vO};function kO(e,t,n){const r=(t-e)/(n-1),s=cp(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}const IO={kernelName:Hf,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=kO(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},NO=IF(e=>Math.log(e)),SO=tR(Gf,NO),CO={kernelName:Gf,backendName:"cpu",kernelFunc:SO},TO=eR(jf,e=>Math.log1p(e)),$O={kernelName:jf,backendName:"cpu",kernelFunc:TO},EO=lR((e,t)=>e&&t),_O=CR(qf,EO,null,"bool"),AO={kernelName:qf,backendName:"cpu",kernelFunc:_O},RO=eR(Kf,e=>e?0:1,"bool"),FO={kernelName:Kf,backendName:"cpu",kernelFunc:RO},DO=lR((e,t)=>e||t),OO=CR(Xf,DO,null,"bool"),MO={kernelName:Xf,backendName:"cpu",kernelFunc:OO},LO={kernelName:Zf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;YA(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=Vd(s.shape),p=new Float32Array(d);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}},zO={kernelName:Yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;YA(i,"LRNGrad");const h=Vd(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=u*r+l;for(let s=t;s<n;s++){let e=-2*u*c*f[s]*m[b]/r;b===s&&(e+=Math.pow(r,-c)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function PO(e,t,n,r){const s=Zd(r,Vd(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}function BO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Kd(a,l);let h=c;const d=Ev(h,u);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=HR(p,l,s.dtype,d,e),h=Av(h.length,u),l=e}YA(s,"max"),$v("max",h,u);const[f,m]=Cv(l,h),g=PO(p,Vd(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;return i&&(b=Tv(f,c)),{dataId:y,shape:b,dtype:s.dtype}}const VO={kernelName:Jf,backendName:"cpu",kernelFunc:BO},WO=lR((e,t)=>Math.max(e,t)),UO=CR(Qf,WO),HO={kernelName:Qf,backendName:"cpu",kernelFunc:UO},GO={kernelName:em,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;YA(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ld(Cx(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=gx(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Wd(u.inShape,u.outShape))c=sR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ip(s.shape),r=lF(e,0,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},jO={kernelName:nm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;YA(s,"maxPool3d");const c=yx(s.shape,a,i,1,o,l,u),h=cF(n.data.get(s.dataId).values,0,s.dtype,ip(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},qO={kernelName:rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;YA([s,a],"maxPool3DGrad");const c=yx(a.shape,i,o,1,l,u),h=function(e,t){const n=wb(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-d;let x=b;for(;x<0;)x+=i;const v=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=o;const w=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const I=Math.min(t.inWidth,h+p);let N=Number.NEGATIVE_INFINITY,S=-1;for(let t=x;t<v;t+=i){const n=t-b;for(let r=d;r<w;r+=o){const s=r-u;for(let a=k;a<I;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=N&&(N=o,S=n*c*h+s*c+i)}}}n.set(S,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=v-1-c.padInfo.left,I=x-1-c.padInfo.top,N=wb(a.shape,"float32"),S=n.bufferSync(s);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-w,a=n-I,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<x;r+=g){const s=(a+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<v;a+=y){const l=(i+a)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*x*v-1-h.get(C,n,s,l,e)===t*x*v+r*v+a?1:0;0!==u&&(o+=S.get(C,n,s,l,e)*u)}}}N.set(o,C,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}},KO={kernelName:tm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;YA([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=gx(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=wb(d.outShape,o.dtype,uF(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=x-1-d.padInfo.top,I=wb(o.shape,"float32"),N=n.data.get(s.dataId).values,S=wb(s.shape,"float32",N);for(let C=0;C<d.batchSize;++C)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,s=n-w;let a=0;for(let t=0;t<x;t+=y){const n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<v;r+=b){const i=(s+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=x*v-1-f.get(C,n,i,e)===t*v+r?1:0;0!==o&&(a+=S.get(C,n,i,e)*o)}}I.set(a,C,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},XO={kernelName:sm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;YA(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=gx(r.shape,s,a,[1,1],i),[h,d]=function(e,t,n,r,s){const a=lF(e,0,n,ip(t),s,"max"),i=uF(e,t,n,s,!0,r);return[a.values,i.values]}(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},ZO={kernelName:am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Kd(a,s.shape),l=Vd(Cv(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=NR({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=RD({inputs:{a:h,b:c},backend:n});u.push(d);const p=lD({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},YO={kernelName:im,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;YA(s,"min");const o=Kd(a,s.shape);let l=o;const u=Ev(l,s.shape.length);let c=s;null!=u&&(c=GR({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Av(l.length,s.shape.length)),$v("min",l,c.shape.length);const[h,d]=Cv(c.shape,l),p=Vd(d),f=cp(Vd(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=RR({inputs:{x:g},backend:n,attrs:{shape:Tv(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},JO=lR((e,t)=>Math.min(e,t)),QO=CR(om,JO),eM={kernelName:om,backendName:"cpu",kernelFunc:QO},tM={kernelName:lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;YA(s,"mirrorPad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),l=a.map(e=>e[0]),u=a.map((e,t)=>e[0]+s.shape[t]),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=ip(s.shape),f=Vd(o),m=o.length,g=ip(o),y=Zd(s.dtype,f);for(let b=0;b<f;b++){let e=fp(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map((e,t)=>e-l[t]);const t=pp(e,d,p);y[b]=h[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},nM=lR((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),rM=CR(um,nM),sM={kernelName:um,backendName:"cpu",kernelFunc:rM};function aM(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Kd([o],s.shape),u=BO({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Tv(u.shape,l),h=RR({inputs:{x:u},backend:n,attrs:{shape:c}}),d=MD({inputs:{a:s,b:h},backend:n}),p=ND({inputs:{x:d},backend:n}),f=lD({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=RR({inputs:{x:f},backend:n,attrs:{shape:c}}),g=RD({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const iM={kernelName:Zm,backendName:"cpu",kernelFunc:aM},oM={kernelName:cm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;YA(s,"multinomial");const l=o?s:aM({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,a],p=cp(Vd(d),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=Wv.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function lM(e,t,n){const r=qg(-1,n);return sD([],t,r,e,n)}const uM={kernelName:dm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;YA(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=lM(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},cM=Kw,hM={kernelName:fm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;YA(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=cM(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},dM=Xw,pM={kernelName:mm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;YA(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=dM(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},fM=Zw,mM={kernelName:gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;YA(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=fM(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},gM=lR((e,t)=>e!==t?1:0),yM=CR(pm,gM,null,"bool"),bM={kernelName:pm,backendName:"cpu",kernelFunc:yM},xM={kernelName:bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:i,offValue:o}=r;YA(s,"oneHot");const l=Vd(s.shape),u=new Float32Array(l*a);u.fill(o);const c=n.data.get(s.dataId).values;for(let h=0;h<l;++h)c[h]>=0&&c[h]<a&&(u[h*a+c[h]]=i);return n.makeTensorInfo([...s.shape,a],"int32",u)}};function vM(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=kR({inputs:{input:r},backend:n}),t=vM({inputs:{x:e},backend:n}),s=AF({inputs:{input:r},backend:n}),a=vM({inputs:{x:s},backend:n}),i=xR({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return WD({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const wM={kernelName:bg,backendName:"cpu",kernelFunc:vM},kM={kernelName:ym,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=kR({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=AF({inputs:{input:s},backend:r}),i=vM({inputs:{x:a},backend:r}),o=xR({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return WD({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function IM(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return CD({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{zd(a,e.shape,"All tensors passed to stack must have matching shapes"),Ld(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=FF({inputs:t.map(e=>{const t=CD({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}const NM={kernelName:xm,backendName:"cpu",kernelFunc:IM},SM={kernelName:vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;YA(s,"pad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),l=a.map(e=>e[0]),u=n.data.get(s.dataId).values,c=Vd(s.shape),h=s.shape.length,d=ip(s.shape),p=Vd(o),f=o.length,m=ip(o),g=Zd(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++)g[pp(fp(y,h,d).map((e,t)=>e+l[t]),f,m)]=u[y];return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},CM=lR((e,t)=>Math.pow(e,t)),TM=CR(wm,CM),$M={kernelName:wm,backendName:"cpu",kernelFunc:TM};function EM(e,t,n,r){const[s,a]=Cv(e,r),i=by(t,"int32"),o=cp(Vd(s),i),l=Vd(a);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:s,outDtype:i}}const _M={kernelName:Im,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;YA(s,"prod");const o=s.shape.length,l=Kd(a,s.shape),u=Ev(l,o);let c=l,h=s;const d=[];null!=u&&(h=GR({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=Av(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=EM(h.shape,h.dtype,p,c);let y=m;return i&&(y=Tv(m,l)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,f)}};function AM(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return cp(0,r);const s=cp(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const RM={kernelName:Nm,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=AM(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},FM=eR(Cm,e=>1/e),DM={kernelName:Cm,backendName:"cpu",kernelFunc:FM},OM={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;YA(s,"resizeBilinear");const l=ip(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Vd([h,u,c,f])),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let x=0;const v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<u;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(d-1,Math.ceil(t)),a=k*l[0]+n*l[1],o=k*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,u=Math.min(p-1,Math.ceil(t)),c=a+n*l[2],h=o+n*l[2],d=a+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[d+e]-t)*s;g[x++]=a+(n+(m[y+e]-n)*s-a)*r}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},MM={kernelName:Rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;YA([a,s],"resizeBilinearGrad");const o=ip(s.shape),[l,u,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(l*u*c*h),m=[i&&d>1?u-1:u,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values;let v=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=e+r*o[1],i=e+s*o[1],l=n-r,d=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],w=d*u,k=d*s,I=l*u,N=l*s;for(let e=0;e<h;e++){const t=x[v++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*N}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},LM={kernelName:Em,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;YA(s,"resizeNearestNeighbor");const l=ip(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*u*c*f),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=y[0]/b[0],v=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?x*(t+.5):x*t;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*l[1];for(let e=0;e<c;e++){const t=i?v*(e+.5):v*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++)g[w++]=m[r+e]}}}return n.makeTensorInfo([h,u,c,f],s.dtype,g)}},zM={kernelName:_m,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;YA([a,s],"resizeNearestNeighborGrad");const o=ip(s.shape),l=ip(a.shape),[u,c,h,d]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,I=2*Math.ceil(w)+2,N=2*Math.ceil(k)+2;for(let S=0;S<u;S++){const e=S*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-I/2);for(let a=0;a<h;a++){const r=n+a*o[2],u=Math.floor(a*k),y=Math.floor(u-N/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<I;r++){const u=r+s;if(u<0||u>=p)continue;const d=e+u*l[1],m=u*x;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const r=d+t*l[2],s=t*v;a===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}},PM={kernelName:Dm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;YA(s,"reverse");const i=s.shape.length,o=Kd(a,s.shape);if(0===i)return sR({inputs:{x:s},backend:n});const l=new iy(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach(e=>t[e]=s.shape[e]-1-t[e]),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},BM={kernelName:wg,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=Zd(r.dtype,Vd(r.shape)),[u,c,h,d]=r.shape,[p,f]=Qk(i,c,h),m=Math.sin(s),g=Math.cos(s),y=o.data.get(r.dataId).values;for(let b=0;b<u;b++){const e=b*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let r=0;r<h;r++){const s=r*d;for(let i=0;i<d;i++){const o=[u,t,r,i],b=o[2],x=o[1];let v=(b-p)*g-(x-f)*m,w=(b-p)*m+(x-f)*g;v=Math.round(v+p),w=Math.round(w+f);let k=a;"number"!=typeof a&&(k=3===i?255:a[i]),v>=0&&v<h&&w>=0&&w<c&&(k=y[e+w*(h*d)+v*d+i]),l[e+n+s+i]=k}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},VM=eR(Om,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),WM={kernelName:Om,backendName:"cpu",kernelFunc:VM},UM=IF(e=>1/Math.sqrt(e)),HM=tR(Mm,UM),GM={kernelName:Mm,backendName:"cpu",kernelFunc:HM};function jM(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return wb(n,t.dtype);const p=wb(c,t.dtype);p.values.fill(l);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[a*s+n]+=d[f*s+n]:p.values[a*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const qM={kernelName:Lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=lI(0,s,i),d=jM(n.bufferSync(s),n.bufferSync(a),i,h,u,l,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}},KM={kernelName:zm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;YA([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=by(s.dtype,a.dtype),h=cp(Vd(s.shape),c);let d=0;const p=0===i||i>1||1===s.shape.length?1:Vd(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)h[d++]=1===o[f]?l[f]:u[f];return n.makeTensorInfo(s.shape,c,h)}},XM=uI,ZM=cI,YM=eR(Pm,e=>e>=0?ZM*e:XM*(Math.exp(e)-1)),JM={kernelName:Pm,backendName:"cpu",kernelFunc:YM},QM=eR(Um,e=>e<0?-1:e>0?1:0),eL={kernelName:Um,backendName:"cpu",kernelFunc:QM},tL=eR(Vm,e=>Math.sin(e)),nL={kernelName:Vm,backendName:"cpu",kernelFunc:tL},rL=eR(Wm,e=>Math.sinh(e)),sL={kernelName:Wm,backendName:"cpu",kernelFunc:rL},aL=Math.log(1.1920928955078125e-7)+2,iL=eR(Gm,e=>{const t=e>-aL,n=e<aL,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s}),oL={kernelName:Gm,backendName:"cpu",kernelFunc:iL},lL={kernelName:Km,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;YA([s],"spaceToBatchND");const o=Vd(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);const u=SM.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=eI(u.shape,a,o,!1),h=tI(c.length,a.length,!1),d=nI(u.shape,a,o,!1),p=RR({inputs:{x:u},backend:n,attrs:{shape:c}}),f=GR({inputs:{x:p},backend:n,attrs:{perm:h}}),m=RR({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function uL(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${o}`);return[Yd(n,0),[0,h],Yd(s,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=l)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${l}`);++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,u,c]}{const t=f[l-1],a=Yd(n,t*h),d=Yd(s,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=(0===t?0:f[t-1])+p[t];p[t]++;for(let r=0;r<h;++r)a[s*h+r]=e[n*h+r];d[s]=r[n],c[n]=s}for(let e=0;e<l;++e)if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}return[a,[t,h],d,u,c]}}const cL={kernelName:Ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=uL(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function hL(e,t,n,r,s){const a=Vd(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,l.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(`Input to reshape is a SparseTensor with ${a}\n          dense values, but the requested shape requires a multiple of ${u}. inputShape=${r} outputShape= ${l}`);l[c]=e}const h=Vd(l);if(h!==a)throw new Error(`Input to reshape is a tensor with ${a} dense values, but the requested shape has ${h}. inputShape=${r} outputShape=${l}`);const d=r.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(o>0){f[o-1]=1;for(let e=o-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=Yd(n,i*o);for(let g=0;g<i;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*p[n];for(let e=0;e<o;++e)m[g*o+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[i,o],l]}const dL={kernelName:Jm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,h]=hL(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};function pL(e,t,n,r,s,a=!1,i=0){const o=r.length;if(o!==s.length)throw new Error("segmentIds and indices should have same size.");const l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=Yd(n,h.reduce((e,t)=>e*t,1));if(0===o)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(`Segment id ${g} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);g>m&&d.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(`Bad: indices[${n}] == ${r[n]} out of range [0, ${l[0]})`);for(let n=0;n<u;n++)d[g*u+n]+=e[t*u+n]}if(a)for(let e=0;e<u;e++)d[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&d.fill(i,m*u,c*u),[d,h]}const fL={kernelName:Qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=pL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},mL={kernelName:eg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=pL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},gL={kernelName:tg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=lI(0,s,o),p=jM(n.bufferSync(s),n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],!1);return n.makeTensorInfo(o,p.dtype,p.values)}},yL={kernelName:Xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Kd(i,s.shape)[0],l=DI(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(e=>{const t=[...c];t[o]=e;const r=yF({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r})}},bL=eR(jm,e=>Math.sqrt(e)),xL={kernelName:jm,backendName:"cpu",kernelFunc:bL},vL={kernelName:rg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;YA(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){const e=s[i];a[i]=e*e}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},wL=lR((e,t)=>{const n=e-t;return n*n}),kL=CR(ng,wL),IL={kernelName:ng,backendName:"cpu",kernelFunc:kL},NL=eR(xg,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),SL={kernelName:xg,backendName:"cpu",kernelFunc:NL};function CL(e,t,n,r){const s=wb(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}const TL={kernelName:sg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;YA(s,"stridedSlice");const{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Yb(s.shape,a,i,o,l,u,c,h,d),x=RR({inputs:{x:s},backend:n,attrs:{shape:y}});let v;if(p){const e=yF({inputs:{x:x},backend:n,attrs:{begin:f,size:g}});v=RR({inputs:{x:e},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(e)}else if(b.some(e=>0===e))v=n.makeTensorInfo(b,s.dtype,[]);else{const e=CL(b,n.bufferSync(x),m,f);v=n.makeTensorInfo(e.shape,e.dtype,e.values)}const w=RR({inputs:{x:v},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),w}};class $L{constructor(e,t,n,r,s,a){this.separator=Zg(e),this.nGramWidths=t,this.leftPad=Zg(n),this.rightPad=Zg(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),h=t+(l>0?0:i-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Yd("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach(s=>{const a=this.getNumNGrams(t[o+1]-t[o],s);this.createNGrams(e,n,i,r,a,s),r+=a}),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;this.createNGrams(e,n,i,r,1,s+2*this.padWidth)}}return[i,a]}}function EL(e,t,n,r,s,a,i,o){return new $L(n,r,s,a,i,o).compute(e,t)}const _L={kernelName:ag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=EL(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function AL(e,t,n){if(!e.length)return[];if(0===t.length){const t=new Array(e.length);for(let n=0;n<e.length;++n)t[n]=e.subarray(n,n+1);return t}if(1===t.length){const r=t[0],s=[];let a=e.indexOf(r);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||s.push(t),a=(e=e.subarray(a+1)).indexOf(r)}return n&&0===e.length||s.push(e),s}const r=[];let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}return r}function RL(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let d=0;d<r;++d){const r=AL(e[d],t,n),l=r.length;o[d]=l,a+=l,i=Math.max(i,l),s.push(...r)}const l=Yd("int32",2*a),u=new Array(a),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*h]=d,l[2*h+1]=e,u[h]=s[h],++h;return[l,u,c]}const FL={kernelName:ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=RL(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function DL(e,t){const n=Yd("int32",e.length);for(let r=0;r<e.length;++r)n[r]=jg(e[r]).modulo(t).getLowBitsUnsigned();return n}const OL={kernelName:og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=DL(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},ML=eR(ug,e=>Math.tan(e)),LL={kernelName:ug,backendName:"cpu",kernelFunc:ML},zL=eR(cg,e=>Math.tanh(e));function PL(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=wb(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}function BL(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Zd(n,i*r),u=Zd("int32",i*r);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o),s=[];for(let e=0;e<n.length;e++)s.push({value:n[e],index:e});s.sort((e,t)=>t.value-e.value);const a=h*r,i=l.subarray(a,a+r),c=u.subarray(a,a+r);for(let e=0;e<r;e++)i[e]=s[e].value,c[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[wb(c,n,l),wb(c,"int32",u)]}function VL(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Od(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;return n<0?t<=1?n=0:n+=t*(Math.trunc(-n/(t-1))+1):n>t-1&&(t<=1?n=0:n-=t*Math.trunc(n/(t-1))),Od(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Od(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function WL(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function UL(e,t,n,r,s,a,i,o,l,u,c){return WL(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function HL(e,t,n,r,s,a,i,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*WL(e,t,n,r,s,a,i,h,d,u,c)+(l-d)*WL(e,t,n,r,s,a,i,h,f,u,c))+(o-h)*((f-l)*WL(e,t,n,r,s,a,i,p,d,u,c)+(l-d)*WL(e,t,n,r,s,a,i,p,f,u,c))}function GL(e,t,n,r){const s=Kd(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i={},o=new Int32Array(n[s]),l=new iy(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(l.get(t,f,n));t=e.join(",")}if(void 0!==i[t])o[f]=i[t];else{const e=Object.keys(i).length;i[t]=e,o[f]=e,u.push(f)}}const h=a.slice();h[1]=Object.keys(i).length;const d=new iy(h,r);u.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(l.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const jL=[MR,zR,BR,WR,AR,UR,qR,KR,XR,ZR,JR,eF,nF,aF,oF,hF,dF,pF,fF,OR,mF,xF,kF,SR,CF,$F,vR,EF,DF,LF,zF,MF,BF,VF,PF,UF,GF,jF,qF,KF,XF,YF,JF,QF,eD,tD,rD,nD,FD,cD,rR,hD,fD,kD,SD,TD,_D,VD,UD,HD,qD,ZD,YD,JD,eO,nO,aO,lO,aR,uO,RF,hO,pO,mO,oR,bO,wO,IO,CO,$O,AO,FO,MO,LO,zO,HO,GO,jO,qO,KO,XO,VO,ZO,YO,eM,tM,sM,oM,oD,uM,hM,pM,mM,bM,xM,kM,NM,SM,$M,hR,_M,RM,IR,DM,pR,mR,FR,OM,MM,LM,zM,PM,BM,WM,GM,qM,KM,JM,yR,eL,nL,sL,bF,iM,oL,lL,cL,dL,fL,mL,gL,yL,xL,vL,IL,SL,TL,_L,FL,OL,LD,uD,LL,{kernelName:cg,backendName:"cpu",kernelFunc:zL},{kernelName:hg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;YA(s,"tile");const i=PL(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:dg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a}=r;YA(s,"topk");const i=n.data.get(s.dataId).values,[o,l]=BL(i,s.shape,s.dtype,a);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},jR,{kernelName:pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],y=ip(s.shape),b=y[0],x=y[1],v=y[2],w=Zd(s.dtype,Vd(g));w.fill(l);const k=r.data.get(s.dataId).values,I=r.data.get(a.dataId).values;for(let N=0;N<c;++N){const e=1===a.shape[0]?I:I.subarray(8*N,8*N+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const u=(e[3]*n+e[4]*t+e[5])/a,c=VL((e[0]*n+e[1]*t+e[2])/a,d,o),p=VL(u,h,o);switch(i){case"nearest":s=UL(k,h,d,b,x,v,N,p,c,r,l);break;case"bilinear":s=HL(k,h,d,b,x,v,N,p,c,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}w[N*b+t*x+n*v+r]=s}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;YA(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=GL(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const e=yF({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=RR({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}},{kernelName:yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;YA(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let d=0;d<u;++d){const e=CD({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,l.push(e)}for(let d=0;d<i;++d){const e=qg(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=pD({inputs:{a:t,b:c},backend:n}),a=NR({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=iD({inputs:{a:a,b:s},backend:n}),u=lD({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(a),l.push(i),l.push(u)}const h=IM({inputs:o,backend:n,attrs:{axis:0}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},wM];for(const Aj of jL)_g(Aj);const qL={},KL={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function XL(e){if(!(e in qL)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete qL[e]},!1),1===e?t.getContext("webgl",KL)||t.getContext("experimental-webgl",KL):t.getContext("webgl2",KL)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;qL[e]=t}const t=qL[e];return t.isContextLost()?(delete qL[e],XL(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),qL[e])}var ZL=(()=>(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(ZL||(ZL={})),ZL))(),YL=(()=>(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(YL||(YL={})),YL))(),JL=(()=>(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(JL||(JL={})),JL))();function QL(e,t){return[t,e]}function ez(e){const t=Vd(e);return Hd(Math.ceil(t/4))}function tz(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function nz(e,t){const n=e;let r,s,a,i,o,l,u,c,h,d;return 2===bp().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT),l=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function rz(e,t){const n=t();return bp().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function sz(e){return!!(bp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function az(e,t){return dz(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const iz=/ERROR: [0-9]+:([0-9]+):/g;function oz(e,t){if(rz(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function lz(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(rz(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),rz(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),rz(e,()=>e.enableVertexAttribArray(o)),!0)}function uz(e,t,n){rz(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),rz(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function cz(e,t){rz(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),rz(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function hz(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function dz(e,t,n){const r=rz(e,()=>t());if(null==r)throw new Error(n);return r}function pz(e,t=2){return Vd(e.slice(0,e.length-t))}function fz(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function mz(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[pz(e),...fz(e)]),t}function gz(e){return e%2==0}function yz(e,t){if(Wd(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(gz(n)&&gz(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&gz(e[0])&&gz(t[0])}let bz,xz;function vz(e,t){return null!=e.getExtension(t)}function wz(e){try{if(null!=XL(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function kz(e){const t=nz(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function Iz(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ld("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Nz=bp();function Sz(){let e,t,n,r,s,a,i,o,l,u;return 2===bp().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Cz(e,t,n="index"){const r=ip(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function Tz(e){const t=ip(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Nz.registerFlag("HAS_WEBGL",()=>Nz.getNumber("WEBGL_VERSION")>0),Nz.registerFlag("WEBGL_VERSION",()=>wz(2)?2:wz(1)?1:0),Nz.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Nz.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Nz.get("WEBGL_VERSION")),Nz.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Nz.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Nz.registerFlag("WEBGL_PACK",()=>Nz.getBool("HAS_WEBGL")),Nz.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_CLIP",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_PACK_REDUCE",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_LAZILY_UNPACK",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_CONV_IM2COL",()=>Nz.getBool("WEBGL_PACK")),Nz.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==bz){const t=XL(e);bz=t.getParameter(t.MAX_TEXTURE_SIZE)}return bz}(Nz.getNumber("WEBGL_VERSION"))),Nz.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==xz){const t=XL(e);xz=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,xz)}(Nz.getNumber("WEBGL_VERSION"))),Nz.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=Nz.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=XL(e);return t=vz(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:vz(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),Nz.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Nz.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ey()),Nz.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=XL(e);if(1===e){if(!vz(t,"OES_texture_float"))return!1}else if(!vz(t,"EXT_color_buffer_float"))return!1;return kz(t)}(Nz.getNumber("WEBGL_VERSION"))),Nz.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Nz.getBool("WEBGL_FORCE_F16_TEXTURES")&&Nz.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Nz.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=XL(e);if(1!==e){if(vz(t,"EXT_color_buffer_float"))return kz(t);const e="EXT_color_buffer_half_float";if(vz(t,e)){const n=t.getExtension(e);return function(e,t){const n=nz(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}(t,n)}return!1}return!!vz(t,"OES_texture_float")&&!!vz(t,"WEBGL_color_buffer_float")&&kz(t)}(Nz.getNumber("WEBGL_VERSION"))),Nz.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=Nz.getNumber("WEBGL_VERSION"))&&null!=XL(e).fenceSync;var e}),Nz.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Nz.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Nz.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),Nz.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Ey()&&Nz.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),Nz.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);const $z="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class Ez{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ZL.DENSE;const t=ez(e),n=Sz();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Cz(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class _z{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ZL.DENSE;const t=ez(e),n=Sz();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${Cz(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Az{constructor(e){this.variableNames=["A"],this.outTexUsage=YL.DOWNLOAD;const t=Sz();this.outputShape=e,this.userCode=`\n      ${$z}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class Rz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=YL.DOWNLOAD;const t=Sz();this.outputShape=e,this.userCode=`\n      ${$z}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Fz{constructor(e,t,n=!1){this.variableNames=["A"];const r=Sz(),[s,a]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`\n      ${Tz(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class Dz{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=Sz(),[s,a]=t;this.outputShape=e;let i="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let t=0;t<=1;t++){const n=2*l+t;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${l} < ${e[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${Tz(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${i}\n\n        ${r.output} = ${o};\n      }\n    `}}function Oz(e,t,n,r,s,a){!function(e,t){const n=bp().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return dz(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return rz(e,()=>e.bindTexture(o,i)),rz(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),rz(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),rz(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),rz(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),rz(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)),rz(e,()=>e.bindTexture(e.TEXTURE_2D,null)),i}function Mz(e){return e.internalFormatFloat}function Lz(e){return e.internalFormatHalfFloat}function zz(e){return e.downloadTextureFormat}function Pz(e){return e.internalFormatPackedFloat}function Bz(e){return e.internalFormatPackedHalfFloat}class Vz{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=bp().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){qL[e]=t}(t,e)):this.gl=XL(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===bp().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=az(this.gl,"OES_texture_float"),vz(this.gl,e))this.textureHalfFloatExtension=az(this.gl,e);else if(bp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),vz(this.gl,r))this.colorBufferHalfFloatExtension=az(this.gl,r);else if(bp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",vz(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!vz(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=dz(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return rz(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),rz(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=dz(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return rz(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),rz(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return dz(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=nz(this.gl,this.textureHalfFloatExtension)}get debug(){return bp().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;rz(e,()=>e.finish()),rz(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),rz(e,()=>e.deleteFramebuffer(this.framebuffer)),rz(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),rz(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),rz(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=QL(t,n);return Oz(e,s,a,Mz(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=QL(t,n);return Oz(e,s,a,Lz(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=QL(t,n);return Oz(e,s,a,zz(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){rz(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?rz(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):rz(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),rz(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;rz(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),rz(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),rz(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=tz(t,n);return Oz(e,s,a,Bz(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=tz(t,n);return Oz(e,s,a,Pz(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(cz(this.gl,this.framebuffer),this.outputTexture=null),rz(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[s,a]=QL(t,n),i=new Uint8Array(t*n*4);return rz(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return function(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=tz(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,e,0,0,0,s,a)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const s=e.createBuffer();rz(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const a=16*t*n;return rz(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),rz(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),rz(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(bp().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return rz(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=dz(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(rz(e,()=>e.shaderSource(n,t)),rz(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=iz.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map((e,t)=>Gd((t+1).toString(),a)+e);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Gd(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=Sz();return function(e,t){const n=dz(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(rz(e,()=>e.shaderSource(n,t)),rz(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const r=function(e){return dz(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return rz(t,()=>t.attachShader(r,this.vertexShader)),rz(t,()=>t.attachShader(r,n)),function(e,t){if(rz(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,r),this.debug&&oz(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,t,n){return rz(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),lz(e,t,"clipSpacePos",n,3,20,0)&&lz(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&rz(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&oz(this.gl,this.program),rz(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return dz(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),rz(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){rz(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),rz(e,()=>e.activeTexture(e.TEXTURE0+n)),rz(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),rz(e,()=>e.uniform1i(n,r))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=tz(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&oz(this.gl,this.program),hz(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),rz(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rz(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=az(this.gl,2===bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return _d(function*(){return yield jd(()=>t.disposed||t.isQueryAvailable(e,bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||jd(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),uz(this.gl,e,this.framebuffer),this.debug&&hz(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(uz(this.gl,this.outputTexture,this.framebuffer),this.debug&&hz(this.gl)):cz(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;uz(r,e,this.framebuffer),this.debug&&hz(r),this.outputTexture=e,rz(r,()=>r.viewport(0,0,t,n)),rz(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),rz(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:Wz}=a;function Uz(e,t,n,r){const s=[];e.forEach(e=>{const t=Vd(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))});const a=s.join("\n"),i=e.map(e=>function(e,t,n=!1){let r="";return r+=n?Gz(e):Hz(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=Wz(e.shapeInfo.logicalShape,t.logicalShape),l=Jz(i),u=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+u]} = 0;`).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+u]}`).join(", ");let p="return outputValue;";const f=1===Vd(e.shapeInfo.logicalShape),m=1===Vd(t.logicalShape);if(1!==a||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===i&&null==e.shapeInfo.flatOffset&&Wd(e.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const o=Jz(i),l=Wz(e.shapeInfo.logicalShape,t.logicalShape),u=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&l.length>=1?"coords = 0;":l.map(e=>`coords.${h[e+u]} = 0;`).join("\n");let d="";return d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+u]}`).join(", "),`\n    float ${s}() {\n      ${o} coords = getOutputCoords();\n      ${c}\n      return get${r}(${d});\n    }\n  `}(e,t)),r}(e,t,r)).join("\n"),o=t.texShape,l=Sz(),u=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(l);let c,h,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${jz}\n    ${qz}\n    ${Kz}\n  `}(l);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Wd(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let a=s,i="",o="b, r, c";for(let l=2;l<e.length-1;l++)a*=e[e.length-l-1],i=`\n      int b${l} = index / ${a};\n      index -= b${l} * ${a};\n    `+i,o=`b${l}, `+o;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${o});\n    }\n  `}(e,t)}}(t.logicalShape,o),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(l)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return Wd(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=Cz(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=Cz(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=Cz(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=Cz(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,o),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(l)),r&&(d+=Xz),[d,u,h,a,c,i,n].join("\n")}function Hz(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[a,i]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${i}, ${Zz(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${Yz(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],a=r[1];if(1===a&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=Zz(t);return 1===a?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Wd(t,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:a,keptDims:i}=Xd(t);if(a.length<t.length){const t=["row","col"];return`\n      ${Hz(Qz(e,a))}\n      float ${r}(int row, int col) {\n        return ${r}(${eP(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${Yz(e)}\n      }\n    `;const o=s[0],l=s[1],u=Zz(n);return 1===l?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${o}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===o?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${u}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${u};\n    vec2 uv = uvFromFlat(${o}, ${l}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:o}=Xd(t);if(i.length<t.length){const t=["row","col","depth"];return`\n        ${Hz(Qz(e,i))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${eP(t,o)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Yz(e)}\n      }\n    `;const l=e.shapeInfo.texShape,u=l[0],c=l[1],h=e.shapeInfo.flatOffset;return c===s&&null==h?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${u}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===a&&null==h?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${u}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${Zz(n)};\n        vec2 uv = uvFromFlat(${u}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:o,keptDims:l}=Xd(t);if(o.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${Hz(Qz(e,o))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${eP(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${a}, ${s}, 1)));\n        ${Yz(e)}\n      }\n    `;const u=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],d=c[1];return d===i&&null==u?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===s&&null==u?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${Zz(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Xd(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Hz(Qz(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${eP(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${Yz(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===s&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${Zz(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Xd(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Hz(Qz(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${eP(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Yz(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${Zz(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Gz(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Sz().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Sz();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=s[0],i=s[1],o=Sz();if(null!=s&&Wd(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);\n\n        return ${o.texture2D}(${n}, uv);\n      }\n    `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${Gz(Qz(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${eP(s,n)});\n        }\n      `}const i=a[0],o=a[1],l=Math.ceil(t[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${o}, ${l*Math.ceil(t[1]/2)}, ${l}, b, row, col);\n      return ${Sz().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],o=i[0],l=i[1],u=Math.ceil(t[n-1]/2);let c=u*Math.ceil(t[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=t[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${o});\n      return ${Sz().texture2D}(${r}, uv);\n    }\n  `}(e)}}const jz="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",qz="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Kz="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Xz="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Zz(e){return`offset${e}`}function Yz(e){const t=e.name,n=Vd(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Jz(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Qz(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function eP(e,t){return t.map(t=>e[t]).join(", ")}function tP(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!Wd(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!Wd(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}const{addImpl:nP,bincountImpl:rP,bincountReduceImpl:sP,ceilImpl:aP,concatImpl:iP,equalImpl:oP,expImpl:lP,expm1Impl:uP,floorImpl:cP,gatherNdImpl:hP,gatherV2Impl:dP,greaterImpl:pP,greaterEqualImpl:fP,lessImpl:mP,lessEqualImpl:gP,linSpaceImpl:yP,logImpl:bP,maxImpl:xP,maximumImpl:vP,minimumImpl:wP,multiplyImpl:kP,negImpl:IP,notEqualImpl:NP,prodImpl:SP,rangeImpl:CP,rsqrtImpl:TP,simpleAbsImpl:$P,sliceImpl:EP,sparseFillEmptyRowsImpl:_P,sparseReshapeImpl:AP,sparseSegmentReductionImpl:RP,stridedSliceImpl:FP,stringNGramsImpl:DP,stringSplitImpl:OP,stringToHashBucketFastImpl:MP,subImpl:LP,tileImpl:zP,topKImpl:PP,transposeImpl:BP,uniqueImpl:VP}=S;function WP(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function UP(e,t){return 1===t?[e]:WP(e,t)}class HP{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=UP("rc",t),r=Jz(t),s=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),a=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),i=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)a=`${t[t.length-1-n]},`+a;n.push(a)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}}class GP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2==1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${Cz(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${Tz(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class jP{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=KP(t,n),s=XP(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=qP(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let i;return r===JL.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===JL.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===JL.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===JL.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===JL.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=KP(n,r),a=XP(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=qP(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=bp().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function qP(e,t,n,r,s){const a=function(e,t){switch(e){case JL.PACKED_2X2_FLOAT32:return Pz(t);case JL.PACKED_2X2_FLOAT16:return Bz(t);case JL.UNPACKED_FLOAT32:return Mz(t);case JL.UNPACKED_FLOAT16:return Lz(t);case JL.PACKED_4X1_UNSIGNED_BYTE:return zz(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=tz(e[0],e[1]);i=t*n}else{const[t,n]=QL(e[0],e[1]);i=t*n}return i*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,a)}function KP(e,t){if(e===YL.UPLOAD)return JL.PACKED_2X2_FLOAT32;if(e===YL.RENDER||null==e)return function(e){return bp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?JL.PACKED_2X2_FLOAT32:JL.UNPACKED_FLOAT32:e?JL.PACKED_2X2_FLOAT16:JL.UNPACKED_FLOAT16}(t);if(e===YL.DOWNLOAD||e===YL.PIXELS)return JL.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function XP(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class ZP{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const YP="return abs(x);",JP="return x;";class QP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class eB{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=UP("rc",t),r=Jz(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const tB=BI,nB={},rB=bp().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let sB=(()=>{class e extends Rd{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!bp().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=XL(bp().getNumber("WEBGL_VERSION"));this.binaryCache=((t=bp().getNumber("WEBGL_VERSION"))in nB||(nB[t]={}),nB[t]),this.gpgpu=new Vz(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new jP(this.gpgpu),this.numMBBeforeWarning=null==bp().global.screen?1024:bp().global.screen.height*bp().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Ad(this,tx())}nextDataId(){return e.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((bp().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||bp().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:YL.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(bp().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:YL.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new QP(i,JP):new ZP(i,JP);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=Xg()),c="complex64"===r?xI(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),l&&(this.downloadWaitMs+=Xg()-u),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return _d(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(null!=a){let n;n=l?new QP(s,JP):new ZP(s,JP);const r=t.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=t.read(r.dataId);return t.disposeIntermediateTensorInfo(r),a}if(null!=r)return t.convertAndCacheOnCPU(e);if(!bp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===bp().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==i&&bp().get("WEBGL_BUFFER_SUPPORTED")){u=t.decode(e);const n=t.texData.get(u.dataId);h=t.gpgpu.createBufferFromTexture(n.texture,...ez(s))}if(t.pendingRead.set(e,[]),"complex64"!==i&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===i){const e=yield Promise.all([t.read(o.real.dataId),t.read(o.imag.dataId)]);c=xI(e[0],e[1])}else if(null==h)c=t.getValuesFromTexture(e);else{const e=Vd(s);c=t.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=u&&t.disposeIntermediateTensorInfo(u);const d=t.convertAndCacheOnCPU(e,c),p=t.pendingRead.get(e);return t.pendingRead.delete(e),p.forEach(e=>e(d)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&tx().removeDataId(e,t),t.pendingDeletes--),d})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>Yg(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return wb(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!sz(n)){if(bp().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Vd(t);if(bp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...ez(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=bp().getBool("WEBGL_PACK")&&!0===r,i=a?mz(t):t,o=a?new Rz(i):new Az(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return _d(function*(){const n=t.activeTimers,r=[];let s=!1;null==t.programTimersStack?(t.programTimersStack=r,s=!0):t.activeTimers.push(r),t.activeTimers=r,e();const a=Bd(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=Bd(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,s&&(t.programTimersStack=null);const o={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(a);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Xg(),endMs:null}}endTimer(e){return bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Xg(),e)}getQueryTime(e){var t=this;return _d(function*(){return bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=rB){return bp().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Vd(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){yI("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return tB(e.shape,t)}packedUnaryOp(e,t,n){const r=new QP(e.shape,t),s=this.compileAndRun(r,[e],n);return tx().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=$P(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(bp().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,YP,e.dtype);const t=new ZP(e.shape,YP),n=this.compileAndRun(t,[e]);return tx().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&tp(n[0])){const s=n.map(e=>Zg(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return tx().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new eB(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new HP(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[pz(e.shape),...fz(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[pz(t),...fz(t)],a=new GP(s,n),i=this.runWebGLProgram(a,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,a=mz(r);let i;return i=n?new _z(a):new Ez(a),{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:a,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===ZL.DENSE){const t=ez(e.outputShape);i.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Vd(a.shape))return i.values=Zd(a.dtype,0),a;const o=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Vd(t.shape)<=bp().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),o.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!yz(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),o.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const u={shape:a.shape,texData:i,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach(e=>{r+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let s=e.constructor.name;return s+="_"+r+"_"+e.userCode,s}(e,l,u),h=this.getAndSaveBinary(c,()=>function(e,t,n,r){const s=t.userCode,a=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),i=a.map(e=>e.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=Uz(a,o,s,t.packedInputs),u=e.createProgram(l);let c=null;const h=e.getUniformLocation(u,"NAN",!1);1===bp().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(u,"INFINITY",!1));const d={};for(let p=0;p<t.variableNames.length;p++){const n=t.variableNames[p],r=!1;d[n]=e.getUniformLocation(u,n,r),d[`offset${n}`]=e.getUniformLocation(u,`offset${n}`,r)}return{program:t,source:l,webGLProgram:u,uniformLocations:d,inShapeInfos:i,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,e,l,u)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(e,t,n,r,s){tP(t.inShapeInfos,n),tP([t.outShapeInfo],[r]);const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a,i[0],i[1]):e.setOutputMatrixTexture(a,i[0],i[1]),e.setProgram(t.webGLProgram),1===bp().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const s=t.program.variableNames[r],a=t.uniformLocations[s],i=t.uniformLocations[`offset${s}`];if(null!=a)if(n.isUniform)if(Vd(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,r)}),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,l,u,r),o.forEach(e=>this.disposeIntermediateTensorInfo(e)),d&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));const f=bp().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=Xg();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!bp().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,r,s=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(bp().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=rx(()=>{if(!bp().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=bp().getBool("DEBUG");bp().set("DEBUG",!1);const t=this.abs(lx(1e-8)).dataSync()[0];if(bp().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=Xg());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=bp().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?Md(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=Xd(e);e=t.newShape}let r=Vd(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=pz(e);let n=2,s=2;return e.length&&([n,s]=fz(e)),r=t*(n/2)*(s/2),Hd(r).map(e=>2*e)}return Hd(r)}(n,o),t.texShape=c),null!=s){const e=mz(n);let a,i=c[1],h=c[0];const d=s instanceof Uint8Array;o?([i,h]=tz(c[0],c[1]),a=new Dz(e,[h,i],d)):a=new Fz(e,[h,i],d);const p=this.makeTensorInfo([h,i],r);this.texData.get(p.dataId).usage=d?YL.PIXELS:YL.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,h,s);const f=this.runWebGLProgram(a,[p],r,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),t.values=null,l&&(this.uploadWaitMs+=Xg()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ep(t)}}return e.nextDataId=0,e})();_y()&&ix("webgl",()=>new sB,2);class aB{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ev(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class iB{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ev(t,n);const s=this.outputShape.length;let a="";if(r)if(0===s||1===Vd(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${Jz(s)} coords = getOutputCoords();\n        `,1===s)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=UP("coords",s);a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function oB(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const lB={kernelName:Of,backendName:"webgl",kernelFunc:oB};function uB(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=oB({inputs:{x:r},backend:n}),l=oB({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const cB={kernelName:qp,backendName:"webgl",kernelFunc:uB},hB="return (a < 0.) ? b * a : a;",dB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",pB={kernelName:Vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",qg(a,"float32")),o=bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new iB(dB,s.shape,i.shape):new aB(hB,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],s.dtype);return n.disposeIntermediateTensorInfo(i),l}},fB="return (a < 0.) ? b * a : a;",mB="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",gB={kernelName:km,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new iB(mB,r.shape,s.shape):new aB(fB,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}};function yB({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u;return u=bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new QP(i.shape,t):new ZP(i.shape,e),o.runWebGLProgram(u,[i],l)}}function bB({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new aB(e,l.shape,u.shape);return c.runWebGLProgram(i,[s,a],by(n.dtype,r.dtype))}),a=uB({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const h=a||by(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?zI(e):e,r="string"===l.dtype?zI(t):t,[a,i]=s(l.shape,u.shape,n,r,h),o=c.makeTensorInfo(i,h);return c.texData.get(o.dataId).values=a,o}let d;return d=bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new iB(t,l.shape,u.shape,n):new aB(e,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function xB(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?mB:fB;if("leakyrelu"===e)return t?dB:hB;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class vB{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const u=Math.ceil((r?e[1]:e[2])/2),c=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";i&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",b="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(b=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${y};\n          int batchB = ${b};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class wB{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ev(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const kB="return a * b;";function IB(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=by(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new wB("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new wB("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=uB({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=kP(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new iB(kB,r.shape,s.shape):new aB(kB,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const NB={kernelName:hm,backendName:"webgl",kernelFunc:IB};function SB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Vd(s.shape),l=qd(a,o),u=Vd(l);Ld(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||yz(s.shape,l)||null!==c.texture&&yz(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[pz(e.shape),...fz(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[pz(t),...fz(t)],i=new GP(a,r),o=n.runWebGLProgram(i,[s],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}(s,l,i)}const CB={kernelName:$m,backendName:"webgl",kernelFunc:SB};class TB{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Ud(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class $B{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function EB(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Jk(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,h;c="mean"===n?0===i?new TB({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new TB({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new $B({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class _B{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=Jz(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class AB{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Jz(this.rank),s=WP("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function RB(e,t,n){const r=bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AB(e.shape,t):new _B(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function FB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=e.shape.length,a=Kd(t,e.shape);let i=a;const o=Ev(i,s),l=null!=o;let u=e;l&&(u=RB(e,o,r),i=Av(i.length,s)),$v("sum",i,s);const[c,h]=Cv(u.shape,i);let d=c;n&&(d=Tv(c,a));const p=Vd(h),f=SB({inputs:{x:u},attrs:{shape:[Vd(e.shape)/p,p]},backend:r}),m=EB(f,xy(e.dtype),"sum",r),g=SB({inputs:{x:m},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),l&&r.disposeIntermediateTensorInfo(u),g}(s,a,i,n)}const DB={kernelName:qm,backendName:"webgl",kernelFunc:FB};function OB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=new Array(s.shape.length);for(let u=0;u<o.length;u++)o[u]=s.shape[a[u]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId),t=BP(e.values,s.shape,s.dtype,a,o);l=i.makeTensorInfo(o,s.dtype),i.texData.get(l.dataId).values=t}else l=RB(s,a,i);return l}const MB={kernelName:fg,backendName:"webgl",kernelFunc:OB};function LB({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Vd(m),b=Vd(g);Ld(u>=2&&c>=2&&(y===b||1===y||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const x=(y>b?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);Ld(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const v=n?[y,h,p]:[y,p,h],w=r?[b,f,d]:[b,d,f],k=SB({inputs:{x:e},backend:s,attrs:{shape:v}}),I=SB({inputs:{x:t},backend:s,attrs:{shape:w}}),N=[k,I],S=Math.max(y,b),C=n?k.shape[1]:k.shape[2],T=null!=a,$=null!=i,E="leakyrelu"===l,_=null!=l?xB(l,!0):null;let A;if((1===p||1===f)&&C>1e3&&!1===(T||$||E||null!=_)){let e=k,t=I;n&&(e=OB({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=OB({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));const a=1===f;let i=e;1!==f&&(i=SB({inputs:{x:e},backend:s,attrs:{shape:[S,C,1]}}),N.push(i));const o=1===f?2:1;let l=t;a&&(l=SB({inputs:{x:t},backend:s,attrs:{shape:[S,1,C]}}),N.push(l));const u=IB({inputs:{a:i,b:l},backend:s});A=FB({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{const l=by(e.dtype,t.dtype),u=new vB(v,w,[S,p,f],n,r,T,_,$,E),c=[k,I];if(null!=a&&c.push(a),$&&c.push(i),E){const e=s.makeTensorInfo([],"float32",qg(o,"float32"));c.push(e),N.push(e)}A=s.runWebGLProgram(u,c,l)}const R=SB({inputs:{x:A},backend:s,attrs:{shape:x}});N.push(A);for(const F of N)s.disposeIntermediateTensorInfo(F);return R}const zB={kernelName:kg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return LB({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},PB="return abs(x);",BB={kernelName:Ip,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=$P(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new QP(r.shape,PB):new ZP(r.shape,PB),n.runWebGLProgram(s,[r],r.dtype)}},VB=yB({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),WB={kernelName:Np,backendName:"webgl",kernelFunc:VB},UB=yB({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),HB={kernelName:Sp,backendName:"webgl",kernelFunc:UB},GB="return a + b;",jB=bB({opSnippet:GB,packedOpSnippet:GB,supportsComplex:!0,cpuKernelImpl:nP}),qB={kernelName:Cp,backendName:"webgl",kernelFunc:jB};class KB{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class XB{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const ZB={kernelName:Tp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return oB({inputs:{x:s[0]},backend:r});if(s.length>bp().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map(e=>e.dtype).reduce((e,t)=>by(e,t)),i=s.map(e=>e.shape),o=bp().getBool("WEBGL_PACK")?new XB(s[0].shape,i):new KB(s[0].shape,i);return r.runWebGLProgram(o,s,a)}},YB={kernelName:$p,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Kd(a,s.shape);let u=l;const c=Ev(u,o);let h=s;null!=c&&(h=OB({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Av(u.length,o)),$v("all",u,o);const[d,p]=Cv(h.shape,u),f=SB({inputs:{x:h},backend:n,attrs:{shape:[-1,Vd(p)]}}),m=EB(f,f.dtype,"all",n);let g;return g=SB(i?{inputs:{x:m},backend:n,attrs:{shape:Tv(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},JB={kernelName:Ep,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Kd(a,s.shape);let u=l;const c=Ev(u,o);let h=s;null!=c&&(h=OB({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Av(u.length,o)),$v("any",u,o);const[d,p]=Cv(h.shape,u),f=SB({inputs:{x:h},backend:n,attrs:{shape:[-1,Vd(p)]}}),m=EB(f,f.dtype,"any",n);let g;return g=SB(i?{inputs:{x:m},backend:n,attrs:{shape:Tv(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class QB{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class eV{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ld(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,i=a.length,o=Jz(i),l=UP("coords",i);let u,c;if(1===s){c=i+1;const e=Jz(c);u=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[i-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[i-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[i-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[i-2]};`}else c=i,u=`\n        ${o} sourceLocR = coords;\n        ++${l[i-1]};\n        ${o} sourceLocG = coords;\n        ++${l[i-2]};\n        ${o} sourceLocA = coords;\n        --${l[i-1]};\n        ${o} sourceLocB = coords;\n        --${l[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(e=>"int "+e),f=UP("sourceLocR",c-1).concat("inIdx.r"),m=UP("sourceLocG",c-1).concat("inIdx.g"),g=UP("sourceLocB",c-1).concat("inIdx.b"),y=UP("sourceLocA",c-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${o} coords = getOutputCoords();\n        bool hasNextCol = ${l[i-1]} < ${a[i-1]-1};\n        bool hasNextRow = ${l[i-2]} < ${a[i-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function tV(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=Jk(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new QB(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=tV(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function nV(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=Jk(s[s.length-1]),i=new eV(s,a,n,null==r),o=e.runWebGLProgram(i,null==r?[t]:[t,r],"int32");if(o.shape.length===t.shape.length){const r=nV(e,t,n,o);return e.disposeIntermediateTensorInfo(o),r}return o}function rV(e,t,n,r){const s=[n];if($v("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!bp().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[a,i]=Cv(t.shape,s),o=Vd(i),l=SB({inputs:{x:t},backend:e,attrs:{shape:[-1,o]}});n.push(l);const u=tV(e,l,r);n.push(u);const c=SB({inputs:{x:u},backend:e,attrs:{shape:a}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return nV(e,t,r)}const sV={kernelName:_p,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Kd(a,s.shape);const o=Ev(i,s.shape.length);let l=s;const u=[];null!=o&&(l=OB({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Av(i.length,l.shape.length)),$v("argMax",[i[0]],l.shape.length);const c=rV(n,l,i[0],"max");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},aV={kernelName:Ap,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Kd(a,s.shape);const o=Ev(i,s.shape.length);let l=s;const u=[];null!=o&&(l=OB({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Av(i.length,l.shape.length)),$v("argMin",[i[0]],l.shape.length);const c=rV(n,l,i[0],"min");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},iV=yB({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),oV={kernelName:Rp,backendName:"webgl",kernelFunc:iV},lV=yB({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),uV={kernelName:Fp,backendName:"webgl",kernelFunc:lV},cV=yB({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),hV={kernelName:Dp,backendName:"webgl",kernelFunc:cV},dV=bB({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),pV={kernelName:Mp,backendName:"webgl",kernelFunc:dV},fV=yB({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),mV={kernelName:Op,backendName:"webgl",kernelFunc:fV};class gV{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const y=4*Math.floor(a/4),b=a%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class yV{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let x="0.0";if(b||(x="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const w=4*Math.floor(a/4),k=a%4,I=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const bV={kernelName:Lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Iz(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ld(Cx(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=gx(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Wd(u.inShape,u.outShape))return oB({inputs:{x:s},backend:n});const c=new gV(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},xV={kernelName:Pp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=yx(s.shape,a,i,[1,1,1],o,l,u),h=new yV(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class vV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const kV={kernelName:Bp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=yx(i.shape,o,l,[1,1,1],u,c),d=new wV(h);return n.runWebGLProgram(d,[s],i.dtype)}},IV={kernelName:zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Iz([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=gx(i.shape,o,l,1,u),h=new vV(c);return n.runWebGLProgram(h,[s],i.dtype)}},NV={kernelName:Vp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return LB({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class SV{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],ev(e,t),ev(e,n);let i="0.0";null!=r&&(ev(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(ev(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class CV{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ev(e,t),ev(e,n);let i="vec4(0.0)";null!=r&&(ev(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(ev(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const TV={kernelName:_f,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Ld(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ld(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ld(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,s,a];let c=null;null!=i&&(c=i.shape,u.push(i));let h=null;null!=o&&(h=o.shape,u.push(o));const d=bp().getBool("WEBGL_PACK_NORMALIZATION")?new CV(r.shape,s.shape,a.shape,c,h,l):new SV(r.shape,s.shape,a.shape,c,h,l);return t.runWebGLProgram(d,u,u[0].dtype)}};class $V{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Jz(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return EV.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${EV[t]} = start[${t}] + coords.${EV[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const EV=["x","y","z","w","u","v"];class _V{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=Jz(this.rank),n=UP("coords",this.rank),r=UP("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function AV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Zb(s,a,i);if(Mb(s,o,l),0===Vd(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=EP(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=Kb(s.shape,o,l);if(u||!c){const e=bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _V(l):new $V(l),t=e.getCustomSetupFunc(o);return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Xb(t,ip(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const RV={kernelName:Bm,backendName:"webgl",kernelFunc:AV},FV={kernelName:Wp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Ld(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),l=eI(s.shape,a,o),u=tI(l.length,a.length),c=nI(s.shape,a,o),h=rI(i,a.length),d=sI(c,i,a.length),p=[],f=SB({inputs:{x:s},backend:n,attrs:{shape:l}}),m=OB({inputs:{x:f},backend:n,attrs:{perm:u}}),g=SB({inputs:{x:m},backend:n,attrs:{shape:c}}),y=AV({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},DV={kernelName:Up,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=rP(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}},OV=bB({opSnippet:"return float(a != b);",cpuKernelImpl:NP,dtype:"bool"}),MV={kernelName:pm,backendName:"webgl",kernelFunc:OV};function LV(e){const{inputs:t,backend:n}=e,{input:r}=t;return oB({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const zV={kernelName:Sm,backendName:"webgl",kernelFunc:LV},PV={kernelName:Hp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return oB({inputs:{x:a},backend:r});const t=Lv(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=uB({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=LV({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Jd(a.dtype,i)){const e=oB({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new ZP(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Zd("bool",1)),t=OV({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},BV="return ceil(x);",VV=yB({opSnippet:BV,packedOpSnippet:BV,cpuKernelImpl:aP}),WV={kernelName:Gp,backendName:"webgl",kernelFunc:VV};class UV{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class HV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const GV={kernelName:jp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=bp().getBool("WEBGL_PACK_CLIP")?new HV(s.shape):new UV(s.shape);const l=o.getCustomSetupFunc(a,i);return n.runWebGLProgram(o,[s],s.dtype,l)}};class jV{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function qV(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const KV={kernelName:Kp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new jV(r.shape),i=[qV(r,s.complexTensorInfos.real),qV(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class XV{constructor(e){this.outputShape=[],this.outputShape=Zk(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<t.length;r++)n.push(`else if (yC < ${t[r]}) setOutput(getT${r}(yR, yC-${t[r-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ZV{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zk(e,t);const n=this.outputShape,r=n.length,s=Jz(r),a=UP("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const o=new Array(e.length-1);o[0]=e[0][t];for(let p=1;p<o.length;p++)o[p]=o[p-1]+e[p][t];const l=i[t],u=i.slice(-2),c=i.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let p=1;p<o.length;p++){const e=o[p-1];h+=`\n        if (${l} < ${o[p]}  && ${l} >= ${o[p-1]}) {\n          return getChannel(\n            getT${p}(${YV(i,l,e)}),\n            vec2(${YV(u,l,e)}));\n        }`}const d=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${YV(i,l,d)}),\n          vec2(${YV(u,l,d)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function YV(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function JV(e){const{inputs:t,backend:n}=e,{input:r}=t;return oB({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const QV={kernelName:Lf,backendName:"webgl",kernelFunc:JV};function eW(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>LV({inputs:{input:e},backend:n})),s=e.map(e=>JV({inputs:{input:e},backend:n})),a=eW(r,t,n),i=eW(s,t,n),o=uB({inputs:{real:a,imag:i},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=Vd(e.shape.slice(t));return SB({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),a=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=Zk(s.map(e=>e.shape),1),o=iP(a,i,r,1===s[0].shape[0]),l=Zk(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,r,o);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}if(e.length>bp().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),s=eW(e.slice(0,r),t,n),a=eW(e.slice(r),t,n),i=eW([s,a],t,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}if(bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new ZV(e.map(e=>e.shape),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:a,outShape:i}=function(e,t,n){const r=Zk(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>SB({inputs:{x:e},attrs:{shape:[-1,Vd(e.shape.slice(t))]},backend:n})),outShape:r}}(e,t,n),o=new XV(a.map(e=>e.shape)),l=n.runWebGLProgram(o,a,r);a.forEach(e=>n.disposeIntermediateTensorInfo(e));const u=SB({inputs:{x:l},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(l),u}function tW(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Kd(s,t[0].shape)[0],i=Zk(t.map(e=>e.shape),a);if(0===Vd(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>Vd(e.shape)>0);return 1===o.length?oB({inputs:{x:o[0]},backend:n}):(Xk(o.map(e=>e.shape),a),eW(o,a,n))}const nW={kernelName:Xp,backendName:"webgl",kernelFunc:tW};class rW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let x="",v="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class sW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aW{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:a,strideHeight:i,padInfo:o,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=s*r,m=Sz(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let x="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)x+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${i} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${a}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${x}\n\n        ${m.output} = result;\n      }\n    `}}function iW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=l[2]%2!=0&&!!u.isPacked;if((1!=l[0]*l[1]*l[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&bp().getBool("WEBGL_LAZILY_UNPACK")&&bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:e.dataId,shape:[1,c?l[0]*l[1]*(l[2]+1):l[0]*l[2]*(l[3]+1),n.inChannels],dtype:e.dtype},f=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Ld(yz(u.shape,p.shape),()=>`packed reshape ${u.shape} to ${p.shape} isn't free`);const m=SB({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=LB({a:p,b:m,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),y=r.texData.get(g.dataId);Ld(y.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=f,y.shape=n.outShape,h=oB({inputs:{x:g},backend:r}),h.shape=n.outShape,d.push(g)}else{const u=SB({inputs:{x:e},backend:r,attrs:{shape:[1,c?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],n.inChannels]}}),p=SB({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=LB({a:u,b:p,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});h=SB({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),d.push(u),d.push(p),d.push(f)}for(const f of d)r.disposeIntermediateTensorInfo(f);return h}function oW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,y=[m,g],b=[],x=SB({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),v=SB({inputs:{x:t},backend:r,attrs:{shape:[1,m,Vd(t.shape)/m]}});b.push(x),b.push(v);const w=new aW(y,x.shape,n),k=r.runWebGLProgram(w,[x],"float32"),I=SB({inputs:{x:k},backend:r,attrs:{shape:[1,y[0],y[1]]}});b.push(k),b.push(I);const N=null!=s,S=null!=a,C="leakyrelu"===o,T=o?xB(o,!0):null,$=new vB(I.shape,v.shape,[1,g,n.outChannels],!0,!1,N,T,S,C),E=[I,v];if(s&&E.push(s),S&&E.push(a),C){const e=r.makeTensorInfo([],"float32",qg(i,"float32"));E.push(e),b.push(e)}const _=r.runWebGLProgram($,E,"float32"),A=SB({inputs:{x:_},backend:r,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});b.push(_);for(const R of b)r.disposeIntermediateTensorInfo(R);return A}const lW={kernelName:Zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=Tx(l),d=bx(s.shape,a.shape,i,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(bp().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])p=oW({x:s,filter:a,convInfo:d,backend:n});else{const e=new rW(d);p=n.runWebGLProgram(e,[s,a],"float32")}else p=iW({x:s,filter:a,convInfo:d,backend:n});const f=SB({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class uW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const pW={kernelName:Yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=Tx(l),d=bx(s.shape,c,i,1,o,u,!1,h),p=new uW(d);return n.runWebGLProgram(p,[s,a],"float32")}},fW={kernelName:Jp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=Tx(u),d=bx(i,a.shape,o,1,l,c,!1,h),p=new cW(d);return n.runWebGLProgram(p,[s,a],"float32")}},mW={kernelName:Qp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=xx(s.shape,a.shape,i,l,o),c=new sW(u);return n.runWebGLProgram(c,[s,a],"float32")}},gW={kernelName:ef,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=xx(s.shape,l,i,1,o),c=new hW(u);return n.runWebGLProgram(c,[s,a],"float32")}},yW={kernelName:tf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=xx(l,a.shape,o,1,i),c=new dW(u);return n.runWebGLProgram(c,[s,a],"float32")}},bW=yB({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),xW={kernelName:nf,backendName:"webgl",kernelFunc:bW},vW=yB({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),wW={kernelName:rf,backendName:"webgl",kernelFunc:vW};class kW{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,x,v]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const IW={kernelName:af,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new kW(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};class NW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${SW(r,"coords")})`,a=e[e.length-1];let i="",o="";t?(i=n?"end != "+(a-1):"end != 0",o=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${a}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Jz(r)} coords = getOutputCoords();\n        int end = ${CW(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${o};\n          ${CW(r,"coords")} = idx;\n          val += getX(${SW(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function SW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function CW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const TW={kernelName:sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length,u=Ev([a],l);let c=s;null!=u&&(c=OB({inputs:{x:s},backend:n,attrs:{perm:u}}));const h=Av(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${a}`);const d=c.shape[h];let p=oB({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const e=new NW(c.shape,!1,o),t=e.getCustomSetupFunc(f),r=p;p=n.runWebGLProgram(e,[p],p.dtype,t),n.disposeIntermediateTensorInfo(r)}if(i){const e=new NW(c.shape,i,o),t=p;p=n.runWebGLProgram(e,[p],p.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=u){const e=OB({inputs:{x:p},backend:n,attrs:{perm:_v(u)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),e}return p}},$W={kernelName:of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=rP(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=sP(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class EW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const _W={kernelName:lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Ld(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),h=new EW("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(h,[s],s.dtype)}};class AW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.inHeight,i=e.inWidth,o=e.padInfo.top,l=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",y="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${o}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${a}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${y}\n        setOutput(result);\n      }\n    `}}class RW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const a=e.outChannels/e.inChannels,i=e.inHeight,o=e.inWidth,l=e.padInfo.top,u=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let y="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let w=0;w<m;w++)y+=`\n          vec4 xTexelC${2*w};\n          int xTexelC${2*w}Ready;\n          vec4 xC${w};`;for(let w=0;w<f;w++){for(let e=0;e<m;e++)y+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;y+=`\n        xR = xRCorner + ${w*d};\n        if (xR >=0 && xR < ${i}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*p;if(y+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(t<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,y+=1===p&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${o}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):y+=`\n                if (xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=u%2==0?Md(p):p;p%2==0&&u%2==1||p%2!=0&&u%2!=1?(y+=`\n                  xCOffset = xC + ${u%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):y+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${o}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(u%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(y+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(y+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(y+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}y+="\n        }\n      "}let b="",x="";n&&(b=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,x="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${u});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${y}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}}const FW={kernelName:uf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Ld(Cx(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=bx(s.shape,a.shape,i,c,o,u,!0);let d;return d=bp().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new RW(h):new AW(h),n.runWebGLProgram(d,[s,a],"float32")}};class DW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class OW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const MW={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=bx(s.shape,c,i,o,l,u,!0),d=new DW(h);return n.runWebGLProgram(d,[s,a],"float32")}},LW={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=bx(c,a.shape,i,o,l,u,!0),d=new OW(h);return n.runWebGLProgram(d,[s,a],"float32")}};class zW{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const PW={kernelName:df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Vd(r.shape),i=SB({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new zW(a),l=n.runWebGLProgram(o,[i],i.dtype),u=SB({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class BW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const VW={kernelName:pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=mx(s.shape,a.shape,i,o,"NHWC",l);let c;const h=new BW(u);c=n.runWebGLProgram(h,[s,a],"float32");const d=SB({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},WW={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=$I(s,a.length);_I(i.length,l,a);const{path:u,steps:c}=AI(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=EI(p,l[e]);let s;RI(t)?s=a[e]:(s=OB({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Wd(s.shape,i)||(s=SB({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=IB({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=FB({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},UW=yB({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),HW={kernelName:bf,backendName:"webgl",kernelFunc:UW},GW={kernelName:xf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new iB("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new aB("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},jW=bB({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:oP}),qW={kernelName:wf,backendName:"webgl",kernelFunc:jW},KW=yB({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${hI};\n  float a1 = ${dI};\n  float a2 = ${pI};\n  float a3 = ${fI};\n  float a4 = ${mI};\n  float a5 = ${gI};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),XW={kernelName:vf,backendName:"webgl",kernelFunc:KW},ZW="return exp(x);",YW=yB({opSnippet:ZW,packedOpSnippet:ZW,cpuKernelImpl:lP}),JW={kernelName:kf,backendName:"webgl",kernelFunc:YW};function QW(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Ld(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),SB({inputs:{x:a},backend:r,attrs:{shape:o}})}const eU={kernelName:If,backendName:"webgl",kernelFunc:QW},tU="return exp(x) - 1.0;",nU=yB({opSnippet:tU,packedOpSnippet:tU,cpuKernelImpl:uP}),rU={kernelName:Nf,backendName:"webgl",kernelFunc:nU};class sU{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function aU(e,t,n){const r=n.texData.get(e.dataId),s=Vd(e.shape),a=e.shape[e.shape.length-1],i=SB({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new sU("real",o,t),u=new sU("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=uB({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=SB({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const iU={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return aU(r,!1,n)}};class oU{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function lU(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||rp(s),"string"===a){const e=Yd(a,Vd(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new oU(r,s),n=e.getCustomSetupFunc(s);return t.runWebGLProgram(e,[],a,n)}}const uU={kernelName:Cf,backendName:"webgl",kernelFunc:lU};class cU{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const hU={kernelName:Tf,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new cU(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},dU="return floor(x);",pU=yB({opSnippet:dU,packedOpSnippet:dU,cpuKernelImpl:cP}),fU={kernelName:$f,backendName:"webgl",kernelFunc:pU},mU=bB({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),gU={kernelName:Ef,backendName:"webgl",kernelFunc:mU};class yU{constructor(e){this.variableNames=["A"];const t=Sz(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class bU{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Sz(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const xU={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,a];(o||i)&&(null==vU&&(vU=document.createElement("canvas").getContext("2d")),vU.canvas.width=l,vU.canvas.height=u,vU.drawImage(s,0,0,l,u),s=vU.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=YL.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=bp().getBool("WEBGL_PACK")?new bU(h):new yU(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let vU;const wU={kernelName:Ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=Tx(c),g=bx(s.shape,a.shape,l,h,u,d,!1,m);let y;const b=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(bp().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=oW({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=null!=i,t=null!=o,r="leakyrelu"===p,l=p?xB(p,!1):null,u=new rW(g,e,l,t,r),c=[s,a];if(i&&c.push(i),o&&c.push(o),r){const e=n.makeTensorInfo([],"float32",qg(f,"float32"));c.push(e),b.push(e)}y=n.runWebGLProgram(u,c,"float32")}else y=iW({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const x=SB({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),x}},kU={kernelName:Ng,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Ld(Cx(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=bx(s.shape,a.shape,l,m,u,h,!0),y=bp().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=d?xB(d,y):null,x=[s,a],v=null!=i,w=null!=o,k="leakyrelu"===d;if(v&&x.push(i),w&&x.push(o),k){const e=n.makeTensorInfo([],"float32",qg(p,"float32"));x.push(e),f.push(e)}let I;I=y?new RW(g,v,b,w,k):new AW(g,v,b,w,k);const N=n.runWebGLProgram(I,x,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),N}};class IU{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=Jz(t.length),s=Jz(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const NU={kernelName:Rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Vd(r.shape),[l,u,c,h]=aI(r,s),d=SB({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=SB({inputs:{x:r},backend:n,attrs:{shape:[Vd(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=hP(e,t,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new IU(i,h,[u,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=SB({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class SU{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Jz(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${n[s]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const CU={kernelName:Af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=LI(s,a,Kd(i,s.shape)[0],o),u=Vd(a.shape),c=[],h=SB({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=SB({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});c.push(h),c.push(d);const p=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(d),t=n.bufferSync(h),r=dP(t,e,p);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const f=new SU(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=SB({inputs:{x:m},backend:n,attrs:{shape:l.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},TU=bB({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:pP,dtype:"bool"}),$U={kernelName:Ff,backendName:"webgl",kernelFunc:TU},EU=bB({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:fP}),_U={kernelName:Df,backendName:"webgl",kernelFunc:EU},AU={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return aU(r,!0,n)}},RU=yB({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),FU={kernelName:zf,backendName:"webgl",kernelFunc:RU},DU=yB({opSnippet:"return float(isinf(x));",dtype:"bool"}),OU={kernelName:Pf,backendName:"webgl",kernelFunc:DU},MU=yB({opSnippet:"return float(isnan(x));",dtype:"bool"}),LU={kernelName:Bf,backendName:"webgl",kernelFunc:MU},zU=bB({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:mP,dtype:"bool"}),PU={kernelName:Wf,backendName:"webgl",kernelFunc:zU},BU=bB({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:gP,dtype:"bool"}),VU={kernelName:Uf,backendName:"webgl",kernelFunc:BU},WU={kernelName:Hf,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=yP(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},UU=yB({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:bP}),HU={kernelName:Gf,backendName:"webgl",kernelFunc:UU},GU=yB({opSnippet:"return log(1.0 + x);"}),jU={kernelName:jf,backendName:"webgl",kernelFunc:GU},qU=bB({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),KU={kernelName:qf,backendName:"webgl",kernelFunc:qU},XU=yB({opSnippet:"return float(!(x >= 1.0));"}),ZU={kernelName:Kf,backendName:"webgl",kernelFunc:XU},YU=bB({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),JU={kernelName:Xf,backendName:"webgl",kernelFunc:YU};class QU{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class eH{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const tH={kernelName:Zf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=bp().getBool("WEBGL_PACK_NORMALIZATION")?new eH(s.shape,a,i,o,l):new QU(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class nH{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const rH={kernelName:Yf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new nH(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function sH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Kd(a,s.shape);let u=l;const c=Ev(u,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=BP(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=RB(s,c,n);u=Av(u.length,o)}$v("max",u,o);const[f,m]=Cv(p.shape,u);let g,y=f;if(i&&(y=Tv(f,l)),d){const e=n.texData.get(p.dataId),t=xP(e.values,Vd(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Vd(t),a=SB({inputs:{x:e},attrs:{shape:[Vd(e.shape)/s,s]},backend:r}),i=EB(a,e.dtype,"max",r),o=SB({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const aH={kernelName:Jf,backendName:"webgl",kernelFunc:sH},iH=bB({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:vP}),oH={kernelName:Qf,backendName:"webgl",kernelFunc:iH},lH={kernelName:em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Iz(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ld(Cx(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=gx(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Wd(u.inShape,u.outShape))return oB({inputs:{x:s},backend:n});const c=new gV(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},uH={kernelName:nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=yx(s.shape,a,i,[1,1,1],o,u,l),h=new yV(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class cH{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hH{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const dH={kernelName:rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=yx(i.shape,o,l,[1,1,1],u,c),d=new yV(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new hH(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},pH={kernelName:tm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Iz([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=gx(o.shape,l,u,1,c,h),p=new gV(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new cH(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},fH={kernelName:sm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Ld(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];Ld(Cx(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=gx(r.shape,s,a,u,i),[h,d]=function(e,t,n,r){let s=new gV(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new gV(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,l);return[h,d]}},mH={kernelName:am,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=Kd(a,r.shape);let u=l;const c=Ev(u,o),h=null!=c,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];const n=BP(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=RB(r,c,i);p.push(f),u=Av(u.length,o)}$v("sum",u,o);const[m,g]=Cv(f.shape,u);let y=m;s&&(y=Tv(m,l));const b=function(e,t,n,r){const s=Vd(t),a=SB({inputs:{x:e},attrs:{shape:[Vd(e.shape)/s,s]},backend:r}),i=EB(a,"float32","mean",r),o=SB({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,g,y,i);for(const x of p)i.disposeIntermediateTensorInfo(x);return b}},gH={kernelName:im,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Kd(a,s.shape);let u=l;const c=Ev(u,o);let h=s;null!=c&&(h=OB({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Av(u.length,s.shape.length)),$v("min",u,o);const[d,p]=Cv(h.shape,u),f=SB({inputs:{x:h},backend:n,attrs:{shape:[-1,Vd(p)]}}),m=EB(f,f.dtype,"min",n);let g;return g=SB(i?{inputs:{x:m},backend:n,attrs:{shape:Tv(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},yH=bB({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:wP}),bH={kernelName:om,backendName:"webgl",kernelFunc:yH};class xH{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Jz(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class vH{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Jz(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=UP("rc",r),l=UP("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const wH={kernelName:lm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vH(r.shape,s,a):new xH(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},kH=bB({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),IH={kernelName:um,backendName:"webgl",kernelFunc:kH};class NH{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const SH=bB({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),CH={kernelName:gf,backendName:"webgl",kernelFunc:SH},TH="return a - b;",$H=bB({opSnippet:TH,packedOpSnippet:TH,supportsComplex:!0,cpuKernelImpl:LP}),EH={kernelName:lg,backendName:"webgl",kernelFunc:$H};function _H(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Kd([a],s.shape),o=sH({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Tv(o.shape,i),u=SB({inputs:{x:o},backend:n,attrs:{shape:l}}),c=$H({inputs:{a:s,b:u},backend:n}),h=YW({inputs:{x:c},backend:n}),d=FB({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=SB({inputs:{x:d},backend:n,attrs:{shape:l}}),f=SH({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const AH={kernelName:Zm,backendName:"webgl",kernelFunc:_H},RH={kernelName:cm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:_H({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=new NH(l.shape[0],l.shape[1],a),c=u.getCustomSetupFunc(i),h=n.runWebGLProgram(u,[l],"int32",c);return o||n.disposeIntermediateTensorInfo(l),h}},FH="return -x;",DH={kernelName:dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=IP(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new QP(r.shape,FH):new ZP(r.shape,FH),n.runWebGLProgram(s,[r],r.dtype)}},OH=Kw,MH={kernelName:fm,backendName:"webgl",kernelFunc:function(e){yI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=OH(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},LH=Xw,zH={kernelName:mm,backendName:"webgl",kernelFunc:function(e){yI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=LH(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},PH=Zw,BH={kernelName:gm,backendName:"webgl",kernelFunc:function(e){yI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=PH(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class VH{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const WH={kernelName:bm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:a,onValue:i,offValue:o}=r,l=Vd(s.shape),u=new VH(l,a,i,o),c=SB({inputs:{x:s},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const d=SB({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,a]}});return n.disposeIntermediateTensorInfo(h),d}};function UH(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=LV({inputs:{input:r},backend:n}),t=UH({inputs:{x:e},backend:n}),s=JV({inputs:{input:r},backend:n}),a=UH({inputs:{x:s},backend:n}),i=uB({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return lU({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const HH={kernelName:bg,backendName:"webgl",kernelFunc:UH},GH={kernelName:ym,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=LV({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=JV({inputs:{input:s},backend:r}),i=UH({inputs:{x:a},backend:r}),o=uB({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return lU({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},jH={kernelName:xm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return QW({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{zd(a,e.shape,"All tensors passed to stack must have matching shapes"),Ld(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=tW({inputs:t.map(e=>{const t=QW({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}};class qH{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Jz(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class KH{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Jz(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=UP("rc",r),l=UP("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const XH=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r,o=bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new KH(s.shape,a,i):new qH(s.shape,a,i),l=o.getCustomSetupFunc(i);return n.runWebGLProgram(o,[s],s.dtype,l)},ZH={kernelName:vm,backendName:"webgl",kernelFunc:XH},YH=bB({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),JH={kernelName:wm,backendName:"webgl",kernelFunc:YH},QH={kernelName:Im,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Kd(a,s.shape);let c=u;const h=Ev(c,o);let d,p=s;if(null!=h&&(p=OB({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Av(c.length,o),l.push(p)),$v("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=SP(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=Cv(p.shape,c),r=Vd(t),a=SB({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=EB(a,xy(s.dtype),"prod",n);d=SB({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(d);const e=Tv(d.shape,u);d=SB({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},eG=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=CP(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},tG={kernelName:Nm,backendName:"webgl",kernelFunc:eG},nG=yB({opSnippet:"return 1.0 / x;"}),rG={kernelName:Cm,backendName:"webgl",kernelFunc:nG},sG=yB({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),aG={kernelName:Tm,backendName:"webgl",kernelFunc:sG},iG=yB({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),oG={kernelName:Fm,backendName:"webgl",kernelFunc:iG};class lG{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class uG{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const cG={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=bp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new uG(s.shape,l,u,a,i):new lG(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class hG{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const dG={kernelName:Rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new hG(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class pG{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class fG{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const mG={kernelName:Em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=bp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fG(s.shape,l,u,a,i):new pG(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class gG{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const yG={kernelName:_m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new gG(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class bG{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=Jz(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class xG{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=UP("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Jz(n);function o(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const vG={kernelName:Dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Kd(a,s.shape);if(0===i)return oB({inputs:{x:s},backend:n});const l=bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xG(s.shape,o):new bG(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class wG{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,r){return(s,a)=>{null==this.paramsLoc&&(this.paramsLoc=s.getUniformLocationNoThrow(a,"params")),s.gl.uniform4f(this.paramsLoc,e,t,n,r)}}}const kG={kernelName:wg,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new wG(r.shape,a),[u,c]=Qk(i,r.shape[1],r.shape[2]),h=l.getCustomSetupFunc(u,c,Math.sin(s),Math.cos(s));return o.runWebGLProgram(l,[r],r.dtype,h)}},IG=yB({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),NG={kernelName:Om,backendName:"webgl",kernelFunc:IG},SG=yB({opSnippet:"return inversesqrt(x);",cpuKernelImpl:TP}),CG={kernelName:Mm,backendName:"webgl",kernelFunc:SG};class TG{constructor(e,t,n,r,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=Jz(s.length),l=Jz(a.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const $G={kernelName:Lm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=lI(0,s,i),d=[h/u,u];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=SB({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=SB({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new TG(l,o,p.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=SB({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class EG{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=Jz(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const _G={kernelName:zm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new EG(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],by(s.dtype,a.dtype))}},AG=yB({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${uI};\n  float scale = ${cI};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),RG={kernelName:Pm,backendName:"webgl",kernelFunc:AG},FG=yB({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),DG={kernelName:Hm,backendName:"webgl",kernelFunc:FG},OG=yB({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),MG={kernelName:Um,backendName:"webgl",kernelFunc:OG},LG=yB({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),zG={kernelName:Vm,backendName:"webgl",kernelFunc:LG},PG=yB({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),BG={kernelName:Wm,backendName:"webgl",kernelFunc:PG},VG=yB({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),WG={kernelName:Gm,backendName:"webgl",kernelFunc:VG},UG={kernelName:Km,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Ld(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=XH({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=eI(c.shape,a,o,!1),d=tI(h.length,a.length,!1),p=nI(c.shape,a,o,!1),f=SB({inputs:{x:c},backend:n,attrs:{shape:h}}),m=OB({inputs:{x:f},backend:n,attrs:{perm:d}}),g=SB({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},HG={kernelName:Ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=_P(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},GG={kernelName:Jm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,h]=AP(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},jG={kernelName:Qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=RP(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},qG={kernelName:eg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=RP(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},KG={kernelName:tg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,strides:c,outputSize:h}=lI(0,s,o),d=new TG(u,l,s.shape.length,a.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[a,s,i],a.dtype),f=SB({inputs:{x:p},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),f}},XG={kernelName:Xm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Kd(i,s.shape)[0],l=DI(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(e=>{const t=[...c];t[o]=e;const r=AV({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r})}},ZG=yB({opSnippet:"return sqrt(x);"}),YG={kernelName:jm,backendName:"webgl",kernelFunc:ZG},JG={kernelName:rg,backendName:"webgl",kernelFunc:yB({opSnippet:"return x * x;"})},QG="return (a - b) * (a - b);",ej=bB({opSnippet:QG,packedOpSnippet:QG}),tj={kernelName:ng,backendName:"webgl",kernelFunc:ej},nj={kernelName:xg,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=new ZP(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(s,[r],r.dtype)}};class rj{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=Jz(n.length),a=Jz(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const sj={kernelName:sg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:b}=Yb(s.shape,a,i,o,l,u,c,h,d),x=SB({inputs:{x:s},backend:n,attrs:{shape:y}});let v;if(p){const e=AV({inputs:{x:x},backend:n,attrs:{begin:f,size:g}});v=SB({inputs:{x:e},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(e)}else if(b.some(e=>0===e))v=n.makeTensorInfo(b,s.dtype,[]);else if(n.shouldExecuteOnCPU([x])){const e=n.texData.get(x.dataId),t=wb(x.shape,x.dtype,e.values),r=FP(b,t,m,f);v=n.makeTensorInfo(b,x.dtype,r.values)}else{const e=new rj(f,m,b);v=n.runWebGLProgram(e,[x],x.dtype)}const w=SB({inputs:{x:v},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),w}},aj={kernelName:ag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=DP(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},ij={kernelName:ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=OP(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},oj={kernelName:og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=MP(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},lj=yB({opSnippet:"return tan(x);"}),uj={kernelName:ug,backendName:"webgl",kernelFunc:lj},cj=yB({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),hj={kernelName:cg,backendName:"webgl",kernelFunc:cj};class dj{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=Jz(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function pj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Yg(e)):e,r=wb(s.shape,s.dtype,t),i=zP(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new dj(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const fj={kernelName:hg,backendName:"webgl",kernelFunc:pj},mj={kernelName:dg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=n.readSync(s.dataId),[l,u]=PP(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};class gj{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const yj={kernelName:pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=new gj(h,d,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}},bj={kernelName:mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Iz(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=VP(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},xj={kernelName:gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[a]=m;const e=AV({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=SB({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class vj{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const wj=[tH,rH,zB,BB,WB,HB,qB,ZB,YB,JB,sV,aV,oV,uV,pV,hV,mV,xV,bV,kV,IV,NV,TV,FV,DV,PV,WV,GV,KV,cB,nW,pW,fW,lW,gW,yW,mW,xW,wW,IW,TW,$W,_W,MW,LW,FW,PW,VW,WW,HW,GW,qW,XW,JW,eU,rU,iU,uU,hU,fU,gU,xU,wU,kU,NU,CU,$U,_U,lB,AU,QV,FU,OU,LU,pB,PU,VU,WU,jU,HU,KU,ZU,JU,aH,uH,lH,dH,pH,fH,oH,mH,gH,bH,wH,IH,RH,NB,DH,MH,zH,BH,MV,WH,GH,jH,ZH,JH,gB,QH,tG,zV,CH,rG,oG,aG,CB,cG,dG,mG,yG,vG,kG,NG,CG,$G,_G,RG,DG,MG,zG,BG,RV,AH,WG,UG,HG,GG,jG,qG,KG,XG,YG,JG,tj,nj,sj,aj,ij,oj,EH,DB,uj,hj,fj,mj,yj,MB,bj,xj,{kernelName:yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Ev([u],o);let h=s;null!=c&&(h=OB({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=Av(1,o)[0]);const d=MI(h.shape,u,i),p=Vd([h.shape[u]]),f=SB({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=xy(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=OI(o,a),c=new vj({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(l.push(h),h.shape[1]===a)return h;const d=eG({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=pj({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(p),g(h,t,p,s,a)},y=SB({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=c){l.push(y);const e=_v(c);b=OB({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},HH];for(const Aj of wj)_g(Aj);const kj={1:"person",2:"bicycle",3:"car",4:"motorcycle",5:"airplane",6:"bus",7:"train",8:"truck",9:"boat",10:"traffic light",11:"fire hydrant",13:"stop sign",14:"parking meter",15:"bench",16:"bird",17:"cat",18:"dog",19:"horse",20:"sheep",21:"cow",22:"elephant",23:"bear",24:"zebra",25:"giraffe",27:"backpack",28:"umbrella",31:"handbag",32:"tie",33:"suitcase",34:"frisbee",35:"skis",36:"snowboard",37:"sports ball",38:"kite",39:"baseball bat",40:"baseball glove",41:"skateboard",42:"surfboard",43:"tennis racket",44:"bottle",46:"wine glass",47:"cup",48:"fork",49:"knife",50:"spoon",51:"bowl",52:"banana",53:"apple",54:"sandwich",55:"orange",56:"broccoli",57:"carrot",58:"hot dog",59:"pizza",60:"donut",61:"cake",62:"chair",63:"couch",64:"potted plant",65:"bed",67:"dining table",70:"toilet",72:"tv",73:"laptop",74:"mouse",75:"remote",76:"keyboard",77:"cell phone",78:"microwave",79:"oven",80:"toaster",81:"sink",82:"refrigerator",84:"book",85:"clock",86:"vase",87:"scissors",88:"teddy bear",89:"hair drier",90:"toothbrush"},Ij=["videoPlayer"],Nj=["canvasElement"];let Sj=(()=>{class e{constructor(e){this.platformId=e,this.threshold=.7,ol(this.platformId)&&Ty.setBackend("webgl")}ngOnInit(){}ngAfterViewInit(){if(ol(this.platformId)){let e="user";/Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)&&(e="environment"),navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:e}}).then(e=>{this.videoPlayer.nativeElement.srcObject=e,function(e){return ZA.apply(this,arguments)}("assets/models/ssd_model.json").then(e=>{this.model=e})}).catch(e=>{console.log(e)})}}ngOnDestroy(){this.stopStreamedVideo()}handleOnLoad(){const e=this.videoDimensions();this.setDimmensions(e),this.detectFrame()}detectFrame(){tx().startScope(),this.model.executeAsync(this.processInput()).then(e=>{this.renderPredictions(e),requestAnimationFrame(()=>{this.detectFrame()}),tx().endScope()},e=>{console.log(e)})}setDimmensions(e){this.videoPlayer.nativeElement.width=e.width,this.canvasRef.nativeElement.width=e.width,this.videoPlayer.nativeElement.height=e.height,this.canvasRef.nativeElement.height=e.height}videoDimensions(){const e=this.videoPlayer.nativeElement.videoWidth/this.videoPlayer.nativeElement.videoHeight;let t=this.videoPlayer.nativeElement.offsetWidth,n=this.videoPlayer.nativeElement.offsetHeight;return t/n>e?t=n*e:n=t/e,{width:t,height:n}}processInput(){return Ob(this.videoPlayer.nativeElement).toInt().transpose([0,1,2]).expandDims()}buildDetectedObjects(e,t,n,r){const s=[];return e[0].forEach((e,a)=>{if(e>t){const t=[],i=n[0][a][0]*this.videoPlayer.nativeElement.offsetHeight,o=n[0][a][1]*this.videoPlayer.nativeElement.offsetWidth,l=n[0][a][2]*this.videoPlayer.nativeElement.offsetHeight,u=n[0][a][3]*this.videoPlayer.nativeElement.offsetWidth;t[0]=o,t[1]=i,t[2]=u-o,t[3]=l-i,s.push({class:r[0][a],label:kj[Math.round(r[0][a])],score:e.toFixed(4),bbox:t})}}),s}renderPredictions(e){const t=this.canvasRef.nativeElement.getContext("2d");t.clearRect(0,0,t.canvas.width,t.canvas.height);const n="16px sans-serif";t.font=n,t.textBaseline="top";const r=e[0].arraySync(),s=e[6].arraySync(),a=e[2].arraySync(),i=this.buildDetectedObjects(s,this.threshold,r,a);i.forEach(e=>{const r=e.bbox[0],s=e.bbox[1],a=e.bbox[2],i=e.bbox[3];t.strokeStyle="#00FFFF",t.lineWidth=2,t.strokeRect(r,s,a,i),t.fillStyle="#00FFFF";const o=t.measureText(e.label+" "+(100*e.score).toFixed(2)+"%").width,l=parseInt(n,10);t.fillRect(r,s,o+4,l+4)}),i.forEach(e=>{const n=e.bbox[0],r=e.bbox[1];t.fillStyle="#000000",t.fillText(e.label+" "+(100*e.score).toFixed(2)+"%",n,r)})}stopStreamedVideo(){const e=this.videoPlayer.nativeElement.srcObject;null!=e&&(e.getTracks().forEach(e=>{e.stop()}),this.videoPlayer.nativeElement.srcObject=null)}}return e.\u0275fac=function(t){return new(t||e)(ta(Gi))},e.\u0275cmp=it({type:e,selectors:[["app-detect-objects"]],viewQuery:function(e,t){if(1&e&&(Mi(Ij,5,Sa),Mi(Nj,5,Sa)),2&e){let e;Oi(e=Li())&&(t.videoPlayer=e.first),Oi(e=Li())&&(t.canvasRef=e.first)}},decls:5,vars:0,consts:[[1,"container"],["autoPlay","","playsInline","","muted","",3,"loadeddata"],["videoPlayer",""],["canvasElement",""]],template:function(e,t){1&e&&(ra(0,"div",0),ra(1,"video",1,2),la("loadeddata",function(){return t.handleOnLoad()}),sa(),aa(3,"canvas",null,3),sa())},styles:[".container[_ngcontent-%COMP%]{display:flex;width:100%;height:100%;max-width:100%;max-height:100%;position:relative;align-items:center}video[_ngcontent-%COMP%]{z-index:10}canvas[_ngcontent-%COMP%], video[_ngcontent-%COMP%]{position:absolute;max-width:100%;max-height:100%}canvas[_ngcontent-%COMP%]{z-index:11}"]}),e})();const Cj=[{path:"detect",component:Sj},{path:"**",component:Sj}];let Tj=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=ct({type:e}),e.\u0275inj=_e({imports:[[vd.forRoot(Cj,{initialNavigation:"enabled"})],vd]}),e})(),$j=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=it({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&aa(0,"router-outlet")},directives:[cd],encapsulation:2}),e})(),Ej=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=ct({type:e,bootstrap:[$j]}),e.\u0275inj=_e({providers:[],imports:[[Bl.withServerTransition({appId:"serverApp"}),Tj]]}),e})();(function(){if(vo)throw new Error("Cannot enable prod mode after platform setup.");xo=!1})(),document.addEventListener("DOMContentLoaded",()=>{zl().bootstrapModule(Ej).catch(e=>console.error(e))})},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},e=>{"use strict";e(e.s=275)}]);